<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Todi Pano Landmark Verifier</title>

<script type="importmap">
{
  "imports": {
    "three": "./node_modules/three/build/three.module.js"
  }
}
</script>

<style>

/* ================= Font Face Definitions ================= */
/* Note: Place actual font files in a /fonts directory */
/* For demonstration, using web font fallbacks */

/* Helvetica (using system Helvetica or Arial as fallback) */
/* For real implementation, add: 
   @font-face {
     font-family: 'Helvetica';
     src: url('./fonts/Helvetica.woff2') format('woff2'),
          url('./fonts/Helvetica.woff') format('woff');
     font-weight: normal;
     font-style: normal;
   }
*/

/* Times New Roman (using web-safe Times or serif fallback) */
/* For real implementation, add:
   @font-face {
     font-family: 'Times New Roman';
     src: url('./fonts/TimesNewRoman.woff2') format('woff2'),
          url('./fonts/TimesNewRoman.woff') format('woff');
     font-weight: normal;
     font-style: normal;
   }
*/

/* Caslon / Kasselin (using Libre Caslon Text from Google Fonts as open-source alternative) */
@import url('https://fonts.googleapis.com/css2?family=Libre+Caslon+Text:ital,wght@0,400;0,700;1,400&display=swap');

/* For local implementation with actual Caslon files, use:
   @font-face {
     font-family: 'Caslon';
     src: url('./fonts/Caslon.woff2') format('woff2'),
          url('./fonts/Caslon.woff') format('woff');
     font-weight: normal;
     font-style: normal;
   }
*/

/* ================= Right Dock ================= */
#rightDock{
  position:fixed;
  top:14px;
  right:14px;
  width:880px;
  max-width:calc(100vw - 28px);
  height:calc(100vh - 28px);
  z-index:60;
  display:flex;
  flex-direction:column;
  background:rgba(0,0,0,.50);
  border:1px solid rgba(255,255,255,.18);
  border-radius:14px;
  overflow:hidden;
  backdrop-filter: blur(8px);
}
#dockTabs{
  display:flex;
  gap:8px;
  align-items:center;
  padding:10px 10px;
  border-bottom:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.35);
}
.dockTab{
  cursor:pointer;
  border:none;
  background:rgba(255,255,255,.10);
  color:#fff;
  padding:8px 14px;
  border-radius:999px;
  font:700 13px/1 Helvetica, Arial, sans-serif;
  opacity:.75;
}
.dockTab.active{ opacity:1; background:rgba(255,255,255,.16); }
.dockIcon{
  cursor:pointer;
  border:none;
  width:34px;
  height:34px;
  border-radius:10px;
  background:rgba(255,255,255,.10);
  color:#fff;
  font:700 14px/1 Helvetica, Arial, sans-serif;
}
#dockBody{ flex:1; display:flex; }
.dockPanel{
  flex:1;
  overflow:hidden;
  display:none;
}
.dockPanel.active{
  display:flex;
  flex-direction:column;
  overflow:hidden;
}

/* mini collapsed launcher */
.mini-collapsed-launcher {
  position:fixed;
  top:14px;
  right:14px;
  z-index:61;
  display:none;
  gap:8px;
  background:rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.18);
  border-radius:999px;
  padding:6px;
  backdrop-filter: blur(8px);
}
.mini-collapsed-launcher button {
  cursor:pointer;
  border:none;
  background:rgba(255,255,255,.10);
  color:#fff;
  padding:8px 12px;
  border-radius:999px;
  font:700 13px/1 Helvetica, Arial, sans-serif;
}

#rightDock.dock-collapsed{ display:none; }

/* override legacy absolute positioning so panels can live inside dock */
#dockPanelVerifier #ui,
#dockPanelOverlay #uiOverlay{
  position:static !important;
  top:auto !important; left:auto !important; right:auto !important; bottom:auto !important;
  width:100% !important;
  max-width:none !important;
  max-height:none !important;
  height:100% !important;
  border:none !important;
  border-radius:0 !important;
  background:transparent !important;
}
#dockPanelVerifier #ui{ display:flex; flex-direction:column; overflow:hidden; }
#dockPanelVerifier #uiBody{ overflow:auto; }
#dockPanelVerifier #uiFooter{ overflow:auto; }

#dockPanelOverlay #uiOverlay{ display:flex; flex-direction:column; overflow:hidden; }
#dockPanelOverlay #ovBody{ overflow:auto; }



/* ================= Overlay panel (ported) ================= */

#uiOverlay{
  position:relative; top:60px; right:14px; z-index:20;
  width:640px;
  max-width:calc(100vw - 28px);
  max-height:calc(100vh - 88px);
  background:rgba(0,0,0,.55);
  border:1px solid rgba(255,255,255,.15);
  border-radius:12px;
  color:#fff;
  user-select:none;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  pointer-events:auto;
}
#ovHeader{padding:12px 12px 8px 12px;}
#ovBody{padding:0 12px 0 12px; overflow:hidden; overflow-y:auto;}
#ovFooter{
  padding:10px 12px 12px 12px;
  border-top:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.30);
}

.ovRow{display:flex;justify-content:space-between;align-items:center;margin:7px 0;font-size:13px;gap:10px}
.ovSmall{font-size:11px;opacity:.82;line-height:1.25}
.ovMini{font-size:11px;opacity:.82;line-height:1.2}
hr.ovSep{border:none;border-top:1px solid rgba(255,255,255,.12);margin:10px 0}

#uiOverlay input[type=range]{width:420px}
#uiOverlay input[type=color]{width:44px;height:26px;border:none;background:none}
#uiOverlay input[type=text]{width:260px}
#uiOverlay select,#uiOverlay button,#uiOverlay textarea{
  background:rgba(255,255,255,.1);
  border:1px solid rgba(255,255,255,.2);
  color:#fff;border-radius:8px;padding:6px 8px;font-size:12px
}
#uiOverlay option{color:#000}
#uiOverlay button{cursor:pointer}
#uiOverlay button:disabled{opacity:.5;cursor:not-allowed}
#uiOverlay textarea{
  width:100%;
  height:92px;
  resize:vertical;
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace
}

/* rules panel */
#rulesPanel{
  border:1px solid rgba(255,255,255,.12);
  border-radius:10px;
  background:rgba(255,255,255,.04);
  padding:10px;
  margin:10px 0 8px 0;
  max-height:240px;
  overflow-y:auto;
}
#rulesPanel::-webkit-scrollbar{width:10px}
#rulesPanel::-webkit-scrollbar-thumb{background:rgba(255,255,255,.18);border-radius:999px}
#rulesPanel::-webkit-scrollbar-track{background:rgba(255,255,255,.06);border-radius:999px}

/* rule card */
.rule{
  border:1px solid rgba(255,255,255,.12);
  border-radius:10px;
  padding:10px;
  background:rgba(0,0,0,.18);
  margin-bottom:10px;
}
.rule:last-child{margin-bottom:0}
.ruleHead{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:8px}
.ruleHead b{font-size:12px}
.ruleBtns{display:flex;gap:8px;align-items:center}
.ruleGrid{
  display:grid;
  grid-template-columns: 100px 1fr 110px;
  gap:8px 10px;
  align-items:center;
  font-size:12px;
}
.ruleGrid .lbl{opacity:.85}
.ruleGrid .right{justify-self:end}
.mini{font-size:11px;opacity:.82;line-height:1.2}

/* Hue picker */
.huePicker{position:relative;height:18px;margin-top:6px;cursor:pointer;}
.hueTrack{
  position:absolute; inset:0;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.18);
  background:linear-gradient(to right,
    rgb(255,0,0), rgb(255,255,0), rgb(0,255,0),
    rgb(0,255,255), rgb(0,0,255), rgb(255,0,255), rgb(255,0,0)
  );
}
.hueHandle{
  position:absolute;
  top:-3px;
  width:6px;
  height:24px;
  background:#fff;
  border:1px solid #000;
  border-radius:2px;
  cursor:ew-resize;
  box-shadow:0 0 0 1px rgba(255,255,255,.25);
  transform:translateX(-50%);
}
.hueHandle.active{
  box-shadow:0 0 0 2px rgba(255,255,255,.55), 0 0 0 1px rgba(0,0,0,.9) inset;
}
.hueSwatches{display:flex;gap:8px;margin-top:6px;align-items:center;}
.hueSwatch{width:22px;height:22px;border-radius:50%;border:1px solid rgba(255,255,255,.25);}
.hueSwatchLabel{font-size:11px;opacity:.82}
#ovStatus{font-size:11px;opacity:.85;margin-top:8px;line-height:1.25;white-space:pre-wrap}

/* collapsed */
#uiOverlay.collapsed #ovBody,
#uiOverlay.collapsed #ovFooter{ display:none; }


  html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:Arial,Helvetica,sans-serif}
  #app{position:fixed;inset:0;z-index:1}
  canvas{display:block}

  #ui{
    position:relative;top:14px;left:14px;z-index:10;
    width:760px;max-width:calc(100vw - 28px);
    background:rgba(0,0,0,.60);
    border:1px solid rgba(255,255,255,.16);
    border-radius:12px;color:#fff;user-select:none;overflow:hidden;
    display:flex;flex-direction:column;backdrop-filter: blur(6px);
  }
  #uiHeader{padding:12px 12px 10px 12px;border-bottom:1px solid rgba(255,255,255,.10);}
  #uiTitle{font-weight:800;letter-spacing:.5px;font-size:14px;opacity:.95}
  #uiSub{margin-top:4px;font-size:12px;opacity:.75;line-height:1.25}
  #uiBody{padding:10px 12px 12px 12px;display:flex;flex-direction:column;gap:10px}
  #row1{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  select,button,input,label{
    border-radius:10px;border:1px solid rgba(255,255,255,.16);
    background:rgba(0,0,0,.40); color:#fff;
    padding:8px 10px; font-size:12px; outline:none;
  }
  label{display:inline-flex;gap:8px;align-items:center;cursor:pointer}
  label input{border:none;background:transparent;padding:0;margin:0}
  button{cursor:pointer}
  button:hover{border-color:rgba(255,255,255,.28)}
  button:active{transform:translateY(1px)}
  .btnSmall{padding:8px 10px}
  .grow{flex:1;min-width:260px}
  #row2{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .pill{
    font-size:11px;opacity:.85;border:1px solid rgba(255,255,255,.16);
    padding:6px 8px;border-radius:999px;display:inline-flex;gap:8px;align-items:center;
    background:rgba(0,0,0,.35)
  }
  .pill b{font-weight:800;opacity:.95}
  .muted{opacity:.7}

  #list{
    margin-top:6px;border:1px solid rgba(255,255,255,.12);
    border-radius:12px;overflow:hidden;max-height:44vh;overflow-y:auto;
  }
  .item{
    padding:10px 10px;border-bottom:1px solid rgba(255,255,255,.08);
    display:flex;gap:10px;align-items:flex-start;cursor:pointer;
  }
  .item:last-child{border-bottom:none}
  .item:hover{background:rgba(255,255,255,.06)}
  .item.sel{background:rgba(255,255,255,.12)}
  .item .left{min-width:38px;text-align:right;opacity:.65;font-size:11px;padding-top:1px}
  .item .main{flex:1}
  .item .name{font-weight:800;font-size:12px;line-height:1.15}
  .item .meta{margin-top:3px;font-size:11px;opacity:.8;display:flex;flex-wrap:wrap;gap:8px}
  .tag{padding:2px 6px;border:1px solid rgba(255,255,255,.16);border-radius:999px;opacity:.9}
  #status{font-size:11px;opacity:.85;margin-top:8px;line-height:1.25}

  /* LEGACY TOOLTIP - Replaced by new hover tip mode
  #tip{
    position:fixed;z-index:20;pointer-events:none;transform:translate(10px,10px);
    padding:8px 10px;background:rgba(0,0,0,.75);
    border:1px solid rgba(255,255,255,.18);border-radius:10px;
    color:#fff;font-size:12px;max-width:340px;display:none;backdrop-filter: blur(6px);
  }
  #tip .t1{font-weight:800;margin-bottom:2px}
  #tip .t2{font-size:11px;opacity:.85}
  */

  /* --- Mouse magnifier reticle (overlay DOM) --- */
  #reticleWrap{
    position:fixed;z-index:10000;pointer-events:none;
    width:160px;height:160px;display:none;
    transform:translate(-80px,-80px);
  }
  #reticle{
    position:absolute;inset:0;
    border:2px solid rgba(255,255,255,.85);
    border-radius:10px;
    box-shadow:0 0 0 1px rgba(0,0,0,.55), 0 0 14px rgba(0,0,0,.45);
    overflow:hidden;
    background:rgba(0,0,0,.15);
    backdrop-filter: blur(0px);
  }
  #reticle::before{
    content:"";
    position:absolute;left:50%;top:0;bottom:0;width:1px;
    background:rgba(255,255,255,.55);
    transform:translateX(-0.5px);
  }
  #reticle::after{
    content:"";
    position:absolute;top:50%;left:0;right:0;height:1px;
    background:rgba(255,255,255,.55);
    transform:translateY(-0.5px);
  }
  #reticleInner{
    position:absolute;left:50%;top:50%;
    width:28px;height:28px;
    transform:translate(-50%,-50%);
    border:2px solid rgba(255,255,255,.95);
    border-radius:6px;
    box-shadow:0 0 0 1px rgba(0,0,0,.55);
  }
  #reticleMeta{
    position:absolute;left:6px;right:6px;bottom:6px;
    font-size:10px;opacity:.92;line-height:1.2;
    text-shadow:0 1px 2px rgba(0,0,0,.65);
    display:flex;justify-content:space-between;gap:8px;
  }
  #reticleMeta span{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  #reticleHint{
    position:absolute;left:6px;right:6px;top:6px;
    font-size:10px;opacity:.85;line-height:1.2;
    text-shadow:0 1px 2px rgba(0,0,0,.65);
  }

  #warn{
    position:fixed;inset:0;z-index:999;
    display:none;align-items:center;justify-content:center;
    background:rgba(0,0,0,.92);color:#fff;padding:20px;
  }
  #warnBox{
    width:min(720px,94vw);
    border:1px solid rgba(255,255,255,.18);
    border-radius:14px;padding:18px;background:rgba(255,255,255,.05);
  }
  #warnBox code{
    display:block;margin-top:8px;padding:10px 12px;border-radius:10px;
    background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.12);
    white-space:pre-wrap;
  }

  /* --- Tiny colored swatch for list items --- */
  .swatch{
    width:10px;height:10px;border-radius:999px;
    margin-top:3px;flex:0 0 auto;
    border:1px solid rgba(255,255,255,.25);
    box-shadow:0 0 0 1px rgba(0,0,0,.45);
  }

/* verifier collapse */
#ui.collapsed #uiBody, #ui.collapsed #uiFooter{ display:none !important; }
#ui.collapsed{ width:320px; }


/* ===== Dual dock layout (Verifier left, Overlay right) ===== */
.dock{ position:fixed; top:10px; bottom:10px;
  width:620px;
  background:rgba(0,0,0,.55);
  border:1px solid rgba(255,255,255,.14);
  border-radius:14px;
  color:#fff;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  z-index:20;
  backdrop-filter: blur(6px);
}
#leftDock{ left:10px; }
#rightDock{ right:10px; }

.dockHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:10px 10px 8px 10px;
  border-bottom:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.35);
}
.dockTabs{ display:flex; gap:8px; }
.dockTabs .tab{
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(0,0,0,.35);
  color:#fff;
  font-size:12px;
}
.dockTabs .tab.active{ background:rgba(255,255,255,.10); }
.dockActions{ display:flex; gap:8px; align-items:center; }
.dockBtn{
  width:30px;height:26px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(0,0,0,.35);
  color:#fff;
  cursor:pointer;
}

.dockBody{
  flex:1;
  overflow:auto;
  padding:10px;
}

/* collapse */
.dock.collapsed{display:none !important;}
.dock.collapsed *{ display:none !important; }
#leftDock.collapsed{ left:0 !important; }
#rightDock.collapsed{ right:0 !important; }
.dock.collapsed .dockBody{ display:none !important; }
.dock.collapsed .dockTabs{ display:none !important; }
.dock.collapsed .dockBody{ display:none; }
.dock.collapsed .dockTabs{ display:none; }

/* Make overlay ranges responsive in dock */
#uiOverlay input[type=range]{ width:100% !important; }

/* ---- Fix: wide verifier, proper overlay mounting ---- */
#leftDock{ width:680px !important; }
#rightDock{ width:560px !important; }
.dockBody{ overflow-x:hidden !important; }

/* force panels to live inside docks (no fixed positioning) */
#ui, #uiOverlay{
  position:relative !important;
  inset:auto !important;
  top:auto !important; left:auto !important; right:auto !important; bottom:auto !important;
  width:100% !important;
  max-width:none !important;
  margin:0 !important;
}

/* --- Overlay color swatches --- */
.ovRow{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:6px 0;}
.ovRow > span{min-width:140px;opacity:.92;}
.ovRow input[type="color"]{
  width:48px;height:24px;padding:0;border:none;border-radius:6px;
  background:transparent;cursor:pointer;box-shadow: inset 0 0 0 1px rgba(255,255,255,.22);
}
.ovRow input[type="color"]::-webkit-color-swatch-wrapper{padding:0;border-radius:6px;}
.ovRow input[type="color"]::-webkit-color-swatch{border:none;border-radius:6px;}

/* Edge reopen buttons (visible only when dock collapsed) */
.edgeReopenBtn{
  position:fixed;
  top:50%;
  transform:translateY(-50%);
  width:34px;
  height:64px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,.65);
  border:1px solid rgba(255,255,255,.25);
  border-radius:12px;
  color:#fff;
  cursor:pointer;
  z-index:999999;
  backdrop-filter: blur(8px);
  font-weight:900;
  opacity:0;
  pointer-events:none;
  transition: opacity .12s ease;
  padding:0;
  border:none;
  background:rgba(0,0,0,.65);
  border:1px solid rgba(255,255,255,.25);
}
.edgeReopenBtn:hover{ 
  transform: translateY(-50%) scale(1.04); 
}
body.verifier-collapsed #edgeReopenLeft{opacity:1;pointer-events:auto;}
body.overlay-collapsed #edgeReopenRight{opacity:1;pointer-events:auto;}
#edgeReopenLeft{left:8px;}
#edgeReopenRight{right:8px;}

/* Modular Marker System Styles */
.fxSection {
  margin: 10px 0 12px 0;
  padding: 10px;
  border: 1px solid rgba(255,255,255,.12);
  border-radius: 12px;
  background: rgba(255,255,255,.04);
}

.fxSectionHeader {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0;
  cursor: pointer;
  user-select: none;
}

.fxSectionBody {
  margin-top: 10px;
  max-height: 600px;
  overflow-y: auto;
  transition: max-height .3s ease, opacity .3s ease;
}

.fxSectionBody.collapsed {
  max-height: 0;
  opacity: 0;
  overflow: hidden;
  margin-top: 0;
}

.markerInstance {
  margin: 10px 0;
  border: 1px solid rgba(255,255,255,.12);
  border-radius: 8px;
  background: rgba(0,0,0,.25);
}

.markerHeader {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 10px;
  background: rgba(255,255,255,.05);
  border-bottom: 1px solid rgba(255,255,255,.08);
  cursor: pointer;
}

.markerToggle {
  border: none;
  background: transparent;
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  padding: 2px 6px;
}

.markerName {
  flex: 1;
  font-weight: 700;
  font-size: 12px;
}

.markerDelete {
  border: none;
  background: rgba(255,0,0,.3);
  color: #fff;
  width: 24px;
  height: 24px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 18px;
  line-height: 1;
}

.markerDelete:hover {
  background: rgba(255,0,0,.5);
}

.markerBody {
  padding: 12px;
  max-height: 600px;
  overflow-y: auto;
  transition: max-height .3s ease;
}

.markerBody.collapsed {
  max-height: 0;
  padding: 0 12px;
  overflow: hidden;
}

.ctrlRow {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 8px 0;
  gap: 10px;
}

.ctrlRow label {
  min-width: 100px;
  font-size: 12px;
}

.ctrlRow input,
.ctrlRow select {
  flex: 1;
  max-width: 200px;
}

.colorSingle, .colorCategory, .colorVisibility {
  margin-left: 0;
}

.deleteMarkerBtn {
  width: 100%;
  margin-top: 12px;
  padding: 8px;
  background: rgba(255,0,0,.3);
  border: 1px solid rgba(255,0,0,.5);
  border-radius: 6px;
  color: #fff;
  cursor: pointer;
}

.deleteMarkerBtn:hover {
  background: rgba(255,0,0,.5);
}

</style>
</head>
<body>


<div id="leftDock" class="dock">
  <div class="dockHeader">
    <div class="dockTabs">
      <button class="tab active">Verifier</button>
    </div>
    <div class="dockActions">
      <button id="leftCollapseBtn" class="dockBtn" title="Collapse">⟨</button>
    </div>
  </div>
  <div id="leftDockBody" class="dockBody"></div>
</div>

<div id="rightDock" class="dock">
  <div class="dockHeader">
    <div class="dockTabs">
      <button class="tab active">Overlay</button>
    </div>
    <div class="dockActions">
      <button id="rightCollapseBtn" class="dockBtn" title="Collapse">⟩</button>
    </div>
  </div>
  <div id="rightDockBody" class="dockBody"></div>
</div>
<!-- ================= End Docks ================= -->

<div id="app"></div>

<div id="ui">
  <div id="uiHeader">
  <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
    <div style="font-weight:700;">Verifier</div>
    
  </div>

    <div id="uiTitle">Todi Pano • Landmark Alignment Verifier</div>
    <div id="uiSub">
      Uses <b>rel_bear</b> + <b>elev_ang_d</b>. Images load by DJI basename from <b>sourcefile</b>.
      Markers render in an <b>overlay scene</b> so they can’t hide behind the pano.
      <span class="muted">Z offset (m) applies: elev += atan2(z_m, dist_m). Per-point offsets are stored per pano+candidate.</span>
    </div>
  <div class="row" style="margin-top:8px;gap:10px;align-items:center;">
    <span class="muted" style="min-width:54px;">Source</span>
    <select id="sourceSelect" style="flex:1;"></select>
  </div>

    <div id="status">Loading…</div>
  </div>

  <div id="uiBody">
  <div style="margin:10px 0 12px 0; padding:10px; border:1px solid rgba(255,255,255,.12); border-radius:12px; background:rgba(255,255,255,.04)">
    
<!-- Locations List -->
    <div id="list"></div>

<!-- Verifier Controls Section -->
<div class="fxSection">
  <div class="fxSectionHeader" onclick="this.nextElementSibling.classList.toggle('collapsed'); this.querySelector('.fxToggle').textContent = this.nextElementSibling.classList.contains('collapsed') ? '▶' : '▼';">
    <span style="font-weight:700;font-size:13px;">Verifier Controls</span>
    <button class="fxToggle" type="button" style="border:none;background:transparent;color:#fff;font-size:14px;cursor:pointer;padding:2px 6px;">▼</button>
  </div>
  <div class="fxSectionBody">
    
    <div id="row2">
      <span class="pill"><b>Type</b> <span id="srcType">—</span></span>
      <span class="pill"><b>ID</b> <span id="srcId">—</span></span>
      <span class="pill"><b>Yaw</b> <span id="srcYaw">—</span></span>
      <span class="pill"><b>Yaw off</b> <span id="srcOff">—</span></span>
      <span class="pill"><b>Z off</b> <span id="srcZ">—</span></span>
      <span class="pill"><b>Sel</b> <span id="selId">—</span></span>
      <span class="pill"><b>Markers</b> <span id="srcMk">—</span></span>
    </div>
    
    <!-- Placement / QA controls -->
    <div id="row2">
      <span class="pill"><b>Adjust mode</b>
        <select id="adjustMode" style="padding:6px 8px">
          <option value="global" selected>Global (pano)</option>
          <option value="point">Selected point</option>
        </select>
      </span>

      <span class="pill"><b>Place</b>
        <select id="placeMode" style="padding:6px 8px">
          <option value="arrows" selected>Arrows only</option>
          <option value="mouse">Mouse snap</option>
          <option value="both">Mouse + arrows</option>
        </select>
      </span>

      <span class="pill"><b>Auto-next</b>
        <label style="border:none;background:transparent;padding:0">
          <input id="autoNext" type="checkbox" checked style="accent-color:#fff">
          after click
        </label>
      </span>

      <button id="nudgeLeft"  class="btnSmall" title="Yaw -">◀</button>
      <button id="nudgeRight" class="btnSmall" title="Yaw +">▶</button>
      <button id="nudgeUp"    class="btnSmall" title="Pitch +">▲</button>
      <button id="nudgeDown"  class="btnSmall" title="Pitch -">▼</button>

      <span class="pill"><b>Yaw step</b>
        <select id="yawStepPreset" style="padding:6px 8px">
          <option value="5">5</option>
          <option value="2">2</option>
          <option value="1" selected>1</option>
          <option value="0.5">0.5</option>
          <option value="0.01">0.01</option>
        </select>
        <span class="muted">deg</span>
      </span>

      <span class="pill"><b>Pitch step</b>
        <input id="pitchStep" type="number" value="0.25" min="0.01" step="0.01" style="width:80px;padding:6px 8px">
        <span class="muted">deg</span>
      </span>

      <button id="resetAdj" class="btnSmall">Reset (mode)</button>
    </div>

    <!-- Z controls -->
    <div id="row2">
      <button id="zDown" class="btnSmall">⬇ Z -</button>
      <button id="zUp"   class="btnSmall">⬆ Z +</button>

      <span class="pill"><b>Z step</b>
        <select id="zStepPreset" style="padding:6px 8px">
          <option value="5">5</option>
          <option value="2">2</option>
          <option value="1">1</option>
          <option value="0.5">0.5</option>
          <option value="0.01">0.01</option>
        </select>
        <span class="muted">m</span>
      </span>

      <button id="zZero" class="btnSmall">Reset Z (mode)</button>

      <span class="muted" style="font-size:11px">
        Tip: point Z is best for DSM/DTM + pano height mismatch, global Z for systematic sensor height bias.
      </span>
    </div>

    <!-- Export / Import -->
    <div id="row2">
      <button id="exportOffsets" class="btnSmall">Export offsets</button>
      <label class="btnSmall" style="padding:0;border:none;background:transparent">
        <input id="importOffsets" type="file" accept=".json" style="width:260px">
      </label>
      <span class="muted" style="font-size:11px">
        Exports/imports: global yaw+Z per pano + per-point yaw/pitch/Z per pano.
      </span>
    </div>

  </div>
</div>

<!-- Filtering Section -->
<div class="fxSection">
  <div class="fxSectionHeader" onclick="this.nextElementSibling.classList.toggle('collapsed'); this.querySelector('.fxToggle').textContent = this.nextElementSibling.classList.contains('collapsed') ? '▶' : '▼';">
    <span style="font-weight:700;font-size:13px;">Filtering</span>
    <button class="fxToggle" type="button" style="border:none;background:transparent;color:#fff;font-size:14px;cursor:pointer;padding:2px 6px;">▼</button>
  </div>
  <div class="fxSectionBody">
    
    <div id="row2">
      <span class="pill"><b>Visibility</b>
        <select id="visFilter" style="padding:6px 8px">
          <option value="any" selected>All</option>
          <option value="visible">Visible</option>
          <option value="not_visible">Not visible</option>
        </select>
      </span>

      <span class="pill"><b>Category</b>
        <select id="categoryFilter" style="padding:6px 8px">
          <option value="all" selected>All</option>
          <option value="building">Buildings</option>
          <option value="amenity">Amenities</option>
          <option value="leisure">Leisure</option>
          <option value="place">Places</option>
        </select>
      </span>

      <span class="pill"><b>Landmarks</b>
        <select id="landmarkFilter" style="padding:6px 8px">
          <option value="any" selected>All</option>
          <option value="landmarks_all">Only landmarks</option>
          <option value="landmarks_buildings">Landmarks: buildings</option>
          <option value="landmarks_leisure">Landmarks: leisure</option>
          <option value="landmarks_places">Landmarks: places</option>
          <option value="non_landmarks">Non-landmarks</option>
        </select>
      </span>

      <span class="pill"><b>Distance</b>
        <input id="distMax" type="range" min="0" max="2000" step="25" value="2000" style="width:220px;padding:0">
        <span id="distMaxLabel" class="muted">≤ 2000m</span>
      </span>

      <span class="pill"><b>Top</b>
        <input id="topN" type="number" value="25" min="1" max="200" step="1" style="width:80px;padding:6px 8px">
      </span>

      <span class="pill"><b>Min vis%</b>
        <input id="minVis" type="number" value="0" min="0" max="100" step="1" style="width:80px;padding:6px 8px">
      </span>
    </div>

  </div>
</div>

<!-- Visual Options Section -->
<div class="fxSection">
  <div class="fxSectionHeader" onclick="this.nextElementSibling.classList.toggle('collapsed'); this.querySelector('.fxToggle').textContent = this.nextElementSibling.classList.contains('collapsed') ? '▶' : '▼';">
    <span style="font-weight:700;font-size:13px;">Visual Options</span>
    <button class="fxToggle" type="button" style="border:none;background:transparent;color:#fff;font-size:14px;cursor:pointer;padding:2px 6px;">▼</button>
  </div>
  <div class="fxSectionBody">
    
    <div id="row2">
      <span class="pill"><b>Particle Size</b><span class="muted">Marker FX only</span>
        <input id="mWorld" type="number" value="18" min="4" max="80" step="1" style="width:80px;padding:6px 8px" title="Size of particle effects in Marker FX">
      </span>

      <span class="pill"><b>Exposure</b>
        <input id="exposure" type="number" value="1.0" min="0.6" max="1.6" step="0.05" style="width:80px;padding:6px 8px" title="Pano image brightness only">
      </span>

      <span class="pill">
        <label style="border:none;background:transparent;padding:0">
          <input id="debugDot" type="checkbox" checked style="accent-color:#fff">
          Debug dot
        </label>
      </span>
    </div>

  </div>
</div>

<!-- Marker FX Section -->
<div class="fxSection">
  <div class="fxSectionHeader" onclick="this.nextElementSibling.classList.toggle('collapsed'); this.querySelector('.fxToggle').textContent = this.nextElementSibling.classList.contains('collapsed') ? '▶' : '▼';">
    <span style="font-weight:700;font-size:13px;">Marker FX</span>
    <button class="fxToggle" type="button" style="border:none;background:transparent;color:#fff;font-size:14px;cursor:pointer;padding:2px 6px;">▼</button>
  </div>
  <div class="fxSectionBody">
    <!-- Add Marker Button -->
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:10px;">
      <button id="addMarkerBtn" type="button" style="flex:1;padding:10px;background:rgba(0,200,100,.3);border:1px solid rgba(0,255,100,.4);border-radius:8px;color:#fff;cursor:pointer;font-weight:700;">
        <span>+ Add Marker</span>
      </button>
      <select id="markerTypeSelector" style="flex:1;display:none;" aria-label="Select marker type">
        <option value="">Select type...</option>
        <option value="helix">Helix (Starlings)</option>
        <option value="bird">Bird Halo</option>
        <option value="ground">Ground Ring</option>
        <option value="birdshape">Bird Shape</option>
        <option value="loading">Loading Rings</option>
      </select>
    </div>
    
    <!-- Active Markers List (dynamically populated) -->
    <div id="activeMarkersList"></div>
  </div>
</div>

<!-- Label FX Section -->
<div class="fxSection">
  <div class="fxSectionHeader" onclick="this.nextElementSibling.classList.toggle('collapsed'); this.querySelector('.fxToggle').textContent = this.nextElementSibling.classList.contains('collapsed') ? '▶' : '▼';">
    <span style="font-weight:700;font-size:13px;">Label FX</span>
    <button class="fxToggle" type="button" style="border:none;background:transparent;color:#fff;font-size:14px;cursor:pointer;padding:2px 6px;">▼</button>
  </div>
  <div class="fxSectionBody">
    <!-- Add Label Button -->
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:10px;">
      <button id="addLabelBtn" type="button" style="flex:1;padding:10px;background:rgba(0,150,255,.3);border:1px solid rgba(0,200,255,.4);border-radius:8px;color:#fff;cursor:pointer;font-weight:700;">
        <span>+ Add Label Type</span>
      </button>
      <select id="labelTypeSelector" style="flex:1;display:none;" aria-label="Select label type">
        <option value="">Select type...</option>
        <option value="label">Label</option>
        <option value="hover">Hover Tip</option>
      </select>
    </div>
    
    <!-- Active Labels List (dynamically populated) -->
    <div id="activeLabelsList"></div>
  </div>
</div>

  </div>
</div>

</div>

<!-- LEGACY TOOLTIP ELEMENT - Replaced by new hover tip mode
<div id="tip">
  <div class="t1" id="tipTitle">—</div>
  <div class="t2" id="tipMeta">—</div>
</div>
-->

<!-- Reticle overlay -->
<div id="reticleWrap">
  <div id="reticle">
    <div id="reticleHint">Mouse snap: move to target → click to lock</div>
    <div id="reticleInner"></div>
    <div id="reticleMeta">
      <span id="reticleA">yaw —</span>
      <span id="reticleB">pitch —</span>
    </div>
  </div>
</div>

<div id="warn">
  <div id="warnBox">
    <div style="font-weight:900;font-size:16px;letter-spacing:.4px;">You opened this via <code>file://</code></div>
    <div class="muted" style="margin-top:8px;line-height:1.35">
      Browsers block JSON + images under <code>file://</code>. Serve the folder over HTTP.
    </div>
    <div style="margin-top:12px;font-weight:900">Run this in CMD:</div>
    <code>cd /d "E:\Portent Maps\Italy\Todi\Viewer"
npx http-server . -a 127.0.0.1 -p 8000 -c-1</code>
    <div style="margin-top:10px;font-weight:900">Then open:</div>
    <code>http://127.0.0.1:8000/index.html</code>
  </div>
</div>

<script type="module">

// --------------------
// Dual dock bootstrap: mount UIs into left/right docks
// --------------------
(function(){
  const mount = ()=>{
    const ui = document.getElementById("ui");
    const ov = document.getElementById("uiOverlay");
    const leftBody = document.getElementById("leftDockBody");
    const rightBody= document.getElementById("rightDockBody");
    if (ui && leftBody && ui.parentElement !== leftBody) leftBody.appendChild(ui);
    if (ov && rightBody && ov.parentElement !== rightBody) rightBody.appendChild(ov);

    // collapse buttons + edge reopen buttons
    const leftDock  = document.getElementById("leftDock");
    const rightDock = document.getElementById("rightDock");
    const lbtn = document.getElementById("leftCollapseBtn");
    const rbtn = document.getElementById("rightCollapseBtn");

    const ensureEdgeButtons = ()=>{
      if (window.__edgeButtonsInit) return;
      window.__edgeButtonsInit = true;

      const mk = (id, side)=>{
        const b = document.createElement("button");
        b.id = id;
        b.className = "edgeReopenBtn";
        b.type = "button";
        b.title = side === "left" ? "Reopen Verifier" : "Reopen Overlay";
        b.textContent = side === "left" ? "›" : "‹";
        b.addEventListener("click", ()=>{
          if (side === "left" && leftDock){
            leftDock.classList.remove("collapsed");
            if (lbtn) lbtn.textContent = "⟨";
          }
          if (side === "right" && rightDock){
            rightDock.classList.remove("collapsed");
            if (rbtn) rbtn.textContent = "⟩";
          }
          applyBodyFlags();
        });
        document.body.appendChild(b);
      };

      mk("edgeReopenLeft","left");
      mk("edgeReopenRight","right");
    };

    const applyBodyFlags = ()=>{
      const body = document.body;
      const lc = !!(leftDock && leftDock.classList.contains("collapsed"));
      const rc = !!(rightDock && rightDock.classList.contains("collapsed"));
      body.classList.toggle("verifier-collapsed", lc);
      body.classList.toggle("overlay-collapsed",  rc);
    };

    ensureEdgeButtons();
    applyBodyFlags();

    if (lbtn && leftDock){
      lbtn.addEventListener("click", ()=>{
        leftDock.classList.toggle("collapsed");
        lbtn.textContent = leftDock.classList.contains("collapsed") ? "⟩" : "⟨";
        applyBodyFlags();
      });
    }
    if (rbtn && rightDock){
      rbtn.addEventListener("click", ()=>{
        rightDock.classList.toggle("collapsed");
        rbtn.textContent = rightDock.classList.contains("collapsed") ? "⟨" : "⟩";
        applyBodyFlags();
      });
    }
  };
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", mount);
  else mount();

  // Wire overlay Collapse button (from overlay panel) to right dock collapse
  try{
    const ovBtn = document.getElementById("ovCollapseBtn");
    const rightDock = document.getElementById("rightDock");
    if (ovBtn && rightDock){
      ovBtn.addEventListener("click", (e)=>{
        e.preventDefault();
        rightDock.classList.toggle("collapsed");
      });
    }
  }catch(e){}
})();

import * as THREE from 'three';

if (location.protocol === 'file:') {
  document.getElementById('warn').style.display = 'flex';
  throw new Error("Opened via file:// — use http://127.0.0.1:8000/index.html");
}

// --------------------
// Config
// --------------------
const JSON_PATH = './pano_candidates_within2km_ALLTYPES__BAKED_OFFSETS.json';
const SPHERE_RADIUS = 500;
const MARKER_RADIUS = SPHERE_RADIUS - 1.5;
const MAX_PITCH_DEG = 85;

// --------------------
// Helpers
// --------------------
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const norm360 = (d)=>((d%360)+360)%360;
const normType = (t)=>String(t||'').trim().toLowerCase();

function numericKey(id){
  const m = String(id).match(/(\d+)/);
  return m ? parseInt(m[1],10) : 999999;
}
function fmt(n, d=2){
  if (n==null || !Number.isFinite(n)) return '—';
  return n.toFixed(d);
}
function safeStr(x){ return (x==null) ? '' : String(x); }
function upperSafe(s){ return safeStr(s).toUpperCase(); }

// yaw 0 => forward (-Z), yaw 90 => right (+X), pitch up +
function yawPitchToDir(yawDeg, pitchDeg){
  const yaw = THREE.MathUtils.degToRad(yawDeg);
  const pitch = THREE.MathUtils.degToRad(pitchDeg);
  const cp = Math.cos(pitch);
  const x = Math.sin(yaw) * cp;
  const y = Math.sin(pitch);
  const z = -Math.cos(yaw) * cp;
  return new THREE.Vector3(x,y,z).normalize();
}

function dirToYawPitchDeg(dir){
  // Inverse of yawPitchToDir (with our convention):
  // x = sin(yaw)*cos(pitch)
  // y = sin(pitch)
  // z = -cos(yaw)*cos(pitch)
  const d = dir.clone().normalize();
  const pitch = Math.asin(clamp(d.y, -1, 1));
  const yaw = Math.atan2(d.x, -d.z);
  return {
    yawDeg: norm360(THREE.MathUtils.radToDeg(yaw)),
    pitchDeg: THREE.MathUtils.radToDeg(pitch)
  };
}

function sourceToImagePath(source){
  // ignore legacy "0001.JPG"
  if (source.image && typeof source.image === 'string'){
    const img = source.image.trim();
    const base = img.split('/').pop().split('\\').pop();
    const isLegacy = /^\d{4}\.(jpe?g|png)$/i.test(base);
    if (!isLegacy){
      if (img.startsWith('images/')) return './' + img;
      if (img.startsWith('./images/')) return img;
      return './images/' + base;
    }
  }
  const sf = source.sourcefile || source.SourceFile || '';
  if (!sf) return null;
  const fname = sf.split('/').pop().split('\\').pop();
  if (!fname) return null;
  return './images/' + fname;
}

function basenameNoExt(path){
  const p = String(path || '').replace(/\\/g,'/');
  const name = p.split('/').pop() || '';
  return name.replace(/\.[^.]+$/, '');
}

function overlayPathForSource(source, kind){
  const imgRel = sourceToImagePath(source); // existing helper
  if (!imgRel) return null;
  const base = basenameNoExt(imgRel);
  return `./images/Overlays/${base}_${kind}.png`;
}



function candidateName(c){
  // Label priority:
  // 1) dst_lm_name when present (real landmark name)
  // 2) dst_name when present
  // 3) fallback to "Type - Subtype" (pretty formatted), with amenity defaulting to "Amenity - Parking"
  function isNullLike(v){
    if (v == null) return true;
    const s = String(v).trim();
    if (!s) return true;
    const up = s.toUpperCase();
    return up === 'NULL' || up === 'NONE' || up === 'N/A';
  }
  function prettyTitle(s){
    const clean = String(s).trim().replace(/_/g,' ').replace(/\s+/g,' ');
    return clean.split(' ').filter(Boolean).map(w=>{
      const low = w.toLowerCase();
      return low.charAt(0).toUpperCase() + low.slice(1);
    }).join(' ');
  }

  const lmName = c?.dst_lm_name;
  if (!isNullLike(lmName)) return prettyTitle(lmName);

  const dstName = c?.dst_name || c?.name || c?.title || c?.label;
  if (!isNullLike(dstName)) return prettyTitle(dstName);

  const t = prettyTitle(normType(c?.dst_type));
  let st = c?.dst_subtype;
  if (isNullLike(st)){
    if (normType(c?.dst_type) === 'amenity') return 'Amenity - Parking';
    return t;
  }
  st = prettyTitle(st);
  return `${t} - ${st}`;
}


function candidateStableId(c){
  // stable-ish key used for per-point offsets
  const t = normType(c.dst_type || 'dst');
  const id =
    safeStr(c.LMID_ ?? c.dst_id ?? c.osm_id ?? c.LM_ID ?? c.id ?? '');
  const name = safeStr(c.LM_Name ?? c.name ?? '');
  return id ? `${t}:${id}` : `${t}:name:${name}`;
}

function getCandidateDistanceM(c){
  const d = Number(c.dist_m ?? c.dist ?? c.distance_m ?? NaN);
  return Number.isFinite(d) ? d : NaN;
}
function getCandidateVisPct(c){
  const v = Number(c.vis_pct ?? c.visibility ?? NaN);
  return Number.isFinite(v) ? v : 0;
}

function isVisibleCandidate(c){
  // Prefer explicit boolean if present, else infer from vis_pct
  if (c.visible != null) return !!c.visible;
  return getCandidateVisPct(c) > 0;
}

function categoryOf(c){
  // Stronger classification for your ALLTYPES JSON
  const dt = normType(c.dst_type);
  if (dt.includes('amenity')) return 'amenity';
  if (dt.includes('leisure')) return 'leisure';
  if (dt.includes('place')) return 'place';

  // buildings (landmark buildings) often come through as 'building' or 'landmark'
  if (dt === 'building' || dt.includes('building')) return 'building';
  if (dt === 'landmark' || dt.includes('landmark') || dt === 'lm') return 'building';

  // fallbacks: if amenity/leisure/place fields exist
  if (c.amenity) return 'amenity';
  if (c.leisure) return 'leisure';
  if (c.place) return 'place';

  return 'other';
}

function hasLandmarkIdentity(c){
  // For your pipeline: LMID_/LM_Name indicates "this candidate is a landmark entity"
  return !!(c.LMID_ || c.LM_Name);
}

function landmarkGroupOf(c){
  // Which “landmark group” a landmark belongs to
  // buildings vs leisure vs places (amenities typically non-landmark in your spec)
  const cat = categoryOf(c);
  if (!hasLandmarkIdentity(c)) return 'non';
  if (cat === 'leisure') return 'leisure';
  if (cat === 'place') return 'places';
  return 'buildings';
}

// Z meters -> pitch deg
function zMetersToDeg(z_m, dist_m){
  if (!Number.isFinite(z_m) || !Number.isFinite(dist_m) || dist_m <= 0) return 0;
  return Math.atan2(z_m, dist_m) * THREE.MathUtils.RAD2DEG;
}

// --------------------
// Color coding (persistent across filters)
// --------------------
const TYPE_COLORS = {
  building_landmark: 0x00c8ff, // cyan
  leisure_landmark:  0xffb000, // amber
  place_landmark:    0xff4d4d, // red-ish
  amenity:           0x64ff7a, // green
  other:             0xffffff
};

function colorKeyForCandidate(c){
  const cat = categoryOf(c);
  const isLm = hasLandmarkIdentity(c);
  if (cat === 'amenity' && !isLm) return 'amenity';
  if (isLm){
    const g = landmarkGroupOf(c);
    if (g === 'leisure') return 'leisure_landmark';
    if (g === 'places')  return 'place_landmark';
    return 'building_landmark';
  }
  if (cat === 'amenity') return 'amenity';
  return 'other';
}

function colorHexForCandidate(c){
  const k = colorKeyForCandidate(c);
  return TYPE_COLORS[k] ?? TYPE_COLORS.other;
}

// --------------------
// DOM
// --------------------
const app = document.getElementById('app');
const statusEl = document.getElementById('status');
const sourceSelect = document.getElementById('sourceSelect');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const listEl = document.getElementById('list');

const srcTypeEl = document.getElementById('srcType');
const srcIdEl = document.getElementById('srcId');
const srcYawEl = document.getElementById('srcYaw');
const srcOffEl = document.getElementById('srcOff');
const srcZEl   = document.getElementById('srcZ');
const selIdEl  = document.getElementById('selId');
const srcMkEl  = document.getElementById('srcMk');

const adjustModeSel = document.getElementById('adjustMode');
const placeModeSel  = document.getElementById('placeMode');
const autoNextIn    = document.getElementById('autoNext');

const nudgeLeft  = document.getElementById('nudgeLeft');
const nudgeRight = document.getElementById('nudgeRight');
const nudgeUp    = document.getElementById('nudgeUp');
const nudgeDown  = document.getElementById('nudgeDown');
const yawStepPresetSel = document.getElementById('yawStepPreset');
const pitchStepIn= document.getElementById('pitchStep');
const resetAdjBtn= document.getElementById('resetAdj');

const zDown = document.getElementById('zDown');
const zUp   = document.getElementById('zUp');
const zZero = document.getElementById('zZero');
const zStepPresetSel = document.getElementById('zStepPreset');

const mWorld = document.getElementById('mWorld');
const topN = document.getElementById('topN');
const minVis = document.getElementById('minVis');
const exposureIn = document.getElementById('exposure');

const visFilterSel = document.getElementById('visFilter');
const categoryFilterSel = document.getElementById('categoryFilter');
const landmarkFilterSel = document.getElementById('landmarkFilter');
const distMaxIn = document.getElementById('distMax');
const distMaxLabel = document.getElementById('distMaxLabel');

const debugDotIn   = document.getElementById('debugDot');

const FONT_STACKS = {
  helvetica: '"Helvetica Neue", Helvetica, Arial, sans-serif',
  times: '"Times New Roman", Times, Georgia, serif',
  caslon: '"Libre Caslon Text", "Caslon", "Big Caslon", Georgia, serif',
  inter: '"Inter", "Helvetica Neue", Helvetica, Arial, sans-serif',
  manrope: '"Manrope", "Helvetica Neue", Helvetica, Arial, sans-serif',
  ibmplex: '"IBM Plex Sans", "Helvetica Neue", Helvetica, Arial, sans-serif',
  spacegrotesk: '"Space Grotesk", "Helvetica Neue", Helvetica, Arial, sans-serif',
  system: 'system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif'
};
let currentLabelFontStack = FONT_STACKS.helvetica;

const exportOffsetsBtn = document.getElementById('exportOffsets');
const importOffsetsIn  = document.getElementById('importOffsets');

// Legacy callout control elements - removed, now using Label FX system
// const calloutsIn = document.getElementById('calloutsIn');
// const loopCalloutIn = document.getElementById('loopCalloutIn');
// const allCalloutsIn = document.getElementById('allCalloutsIn');
// const animSecondsIn = document.getElementById('animSecondsIn');

const tip = document.getElementById('tip');
const tipTitle = document.getElementById('tipTitle');
const tipMeta = document.getElementById('tipMeta');

const reticleWrap = document.getElementById('reticleWrap');
const reticleA = document.getElementById('reticleA');
const reticleB = document.getElementById('reticleB');

function setStatus(msg){ statusEl.textContent = msg; }

const ovOn = document.getElementById('ovOn');
const ovType = document.getElementById('ovType');
const ovOpacity = document.getElementById('ovOpacity');

// LEGACY TOOLTIP FUNCTIONS - Replaced by new hover mode
/*
function showTooltip(x,y,title,meta){
  tip.style.display='block';
  tip.style.left = x+'px';
  tip.style.top  = y+'px';
  tipTitle.textContent = title || '';
  tipMeta.textContent  = meta || '';
}
function hideTooltip(){ tip.style.display='none'; }
*/

// --------------------
// Three: 2 scenes (pano + overlay markers)
// --------------------
const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.autoClear = false;
renderer.toneMapping = THREE.NoToneMapping;
renderer.toneMappingExposure = 1.0;
app.appendChild(renderer.domElement);

const scenePano = new THREE.Scene();
const sceneOverlay = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0,0,0);

const sphereGeo = new THREE.SphereGeometry(SPHERE_RADIUS, 64, 40);
sphereGeo.scale(-1,1,1);
const sphereMesh = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial({ color: 0x111111 }));
scenePano.add(sphereMesh);

// ---- Overlay sphere (PNG bitmap) ----
const overlayGeo = new THREE.SphereGeometry(SPHERE_RADIUS - 0.5, 64, 40);
overlayGeo.scale(-1, 1, 1);

let overlayTexture = null;
const overlayMesh = new THREE.Mesh(
  overlayGeo,
  new THREE.MeshBasicMaterial({
    transparent: true,
    opacity: 0.65,
    depthWrite: false,
    depthTest: true
  })
);
overlayMesh.visible = true;
scenePano.add(overlayMesh);


const markerGroup = new THREE.Group();
sceneOverlay.add(markerGroup);

const labelGroup = new THREE.Group();
sceneOverlay.add(labelGroup);

// --------------------
// Data
// --------------------
let DATA=null;
let SOURCES=[];
let currentIndex=0;

// --------------------
// Storage: global + per-point offsets
// --------------------
function offsetKey(srcId){ return `todi_pano_offset_deg__${srcId}`; }
function getOffsetDeg(srcId){
  const v = localStorage.getItem(offsetKey(srcId));
  const n = v==null ? 0 : parseFloat(v);
  return Number.isFinite(n) ? n : 0;
}
function setOffsetDeg(srcId, deg){
  localStorage.setItem(offsetKey(srcId), String(deg));
}

function zOffsetKey(srcId){ return `todi_pano_zoff_m__${srcId}`; }
function getZOffsetM(srcId){
  const v = localStorage.getItem(zOffsetKey(srcId));
  const n = v==null ? 0 : parseFloat(v);
  return Number.isFinite(n) ? n : 0;
}
function setZOffsetM(srcId, m){
  localStorage.setItem(zOffsetKey(srcId), String(m));
}

function pointKey(srcId, candKey){ return `todi_point_adj__${srcId}__${candKey}`; }
function getPointAdj(srcId, candKey){
  const raw = localStorage.getItem(pointKey(srcId, candKey));
  if (!raw) return { yaw:0, pitch:0, z:0 };
  try {
    const j = JSON.parse(raw);
    return {
      yaw:   Number.isFinite(+j.yaw)   ? +j.yaw   : 0,
      pitch: Number.isFinite(+j.pitch) ? +j.pitch : 0,
      z:     Number.isFinite(+j.z)     ? +j.z     : 0
    };
  } catch {
    return { yaw:0, pitch:0, z:0 };
  }
}
function setPointAdj(srcId, candKey, adj){
  const clean = {
    yaw:   Number.isFinite(+adj.yaw)   ? +adj.yaw   : 0,
    pitch: Number.isFinite(+adj.pitch) ? +adj.pitch : 0,
    z:     Number.isFinite(+adj.z)     ? +adj.z     : 0
  };
  localStorage.setItem(pointKey(srcId, candKey), JSON.stringify(clean));
}
function resetPointAdj(srcId, candKey){
  localStorage.removeItem(pointKey(srcId, candKey));
}

// --------------------
// Camera yaw/pitch + smooth turn
// --------------------
let yaw = 0;
let pitch = 0;
let dragging=false, lastX=0, lastY=0;
const MAX_PITCH = THREE.MathUtils.degToRad(85);

let animating=false;
let yawFrom=0, pitchFrom=0, yawTo=0, pitchTo=0;
let t0=0, dur=420;

function shortestAngle(a,b){
  let d = (b - a) % (Math.PI*2);
  if (d > Math.PI) d -= Math.PI*2;
  if (d < -Math.PI) d += Math.PI*2;
  return d;
}
function setViewYawPitch(targetYaw, targetPitch, smooth=true){
  const tp = clamp(targetPitch, -MAX_PITCH, MAX_PITCH);
  if (!smooth){
    yaw = targetYaw;
    pitch = tp;
    animating = false;
    return;
  }
  animating = true;
  t0 = performance.now();
  yawFrom = yaw;
  pitchFrom = pitch;
  yawTo = targetYaw;
  pitchTo = tp;
}
function updateCamera(){
  if (animating){
    const t = (performance.now() - t0) / dur;
    if (t >= 1){
      animating=false;
      yaw=yawTo; pitch=pitchTo;
    } else {
      const k = t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
      yaw = yawFrom + shortestAngle(yawFrom, yawTo)*k;
      pitch = pitchFrom + (pitchTo - pitchFrom)*k;
    }
  }
  pitch = clamp(pitch, -MAX_PITCH, MAX_PITCH);

  const yawDeg = THREE.MathUtils.radToDeg(yaw);
  const pitchDeg = THREE.MathUtils.radToDeg(pitch);
  const dir = yawPitchToDir(yawDeg, pitchDeg);
  camera.lookAt(dir);
}

// --------------------
// Marker sprites + labels
// --------------------
function makeCrosshairMarkerSprite(worldSize=18, colorHex=0xffffff){
  const c = document.createElement('canvas');
  c.width=128; c.height=128;
  const g=c.getContext('2d');
  g.clearRect(0,0,128,128);

  const color = `#${(colorHex>>>0).toString(16).padStart(6,'0')}`;

  // ring
  g.beginPath();
  g.arc(64,64,34,0,Math.PI*2);
  g.strokeStyle = color;
  g.lineWidth = 6;
  g.lineJoin = 'round';
  g.lineCap = 'round';
  g.stroke();

  // inner ring faint
  g.beginPath();
  g.arc(64,64,22,0,Math.PI*2);
  g.strokeStyle = 'rgba(255,255,255,0.28)';
  g.lineWidth = 3;
  g.stroke();

  // crosshair
  g.strokeStyle = color;
  g.lineWidth = 4;
  g.beginPath();
  g.moveTo(64,22); g.lineTo(64,106);
  g.moveTo(22,64); g.lineTo(106,64);
  g.stroke();

  // tiny center dot
  g.fillStyle = '#ffffff';
  g.beginPath(); g.arc(64,64,3.5,0,Math.PI*2); g.fill();

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;

  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
  mat.depthTest = false;
  mat.depthWrite = false;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 9999;
  spr.scale.set(worldSize, worldSize, 1);
  return spr;
}

// Create simple X-shaped marker sprite
function makeXMarkerSprite(worldSize=18, colorHex=0xffffff){
  const c = document.createElement('canvas');
  c.width=128; c.height=128;
  const g=c.getContext('2d');
  g.clearRect(0,0,128,128);

  const color = `#${(colorHex>>>0).toString(16).padStart(6,'0')}`;

  // Draw X - two diagonal lines crossing at center
  g.strokeStyle = color;
  g.lineWidth = 8;
  g.lineJoin = 'round';
  g.lineCap = 'round';
  
  // Diagonal from top-left to bottom-right
  g.beginPath();
  g.moveTo(32, 32);
  g.lineTo(96, 96);
  g.stroke();
  
  // Diagonal from top-right to bottom-left
  g.beginPath();
  g.moveTo(96, 32);
  g.lineTo(32, 96);
  g.stroke();

  // Small center dot for precision
  g.fillStyle = color;
  g.beginPath();
  g.arc(64, 64, 4, 0, Math.PI*2);
  g.fill();

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;

  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
  mat.depthTest = false;
  mat.depthWrite = false;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 9999;
  spr.scale.set(worldSize, worldSize, 1);
  return spr;
}

function makeLoadingCircleMarker(worldSize=18, colorHex=0x00c8ff){
  // Smooth pulsing/rotating ring that always faces the camera (Sprite)
  const c = document.createElement('canvas');
  const SZ = 256;
  c.width = SZ; c.height = SZ;
  const g = c.getContext('2d', { alpha:true });

  g.clearRect(0,0,SZ,SZ);
  const cx = SZ/2, cy = SZ/2;
  const r1 = SZ*0.34;
  const r2 = SZ*0.42;

  // faint outer glow
  g.beginPath();
  g.arc(cx, cy, r2, 0, Math.PI*2);
  g.strokeStyle = 'rgba(255,255,255,0.18)';
  g.lineWidth = SZ*0.02;
  g.lineCap = 'round';
  g.stroke();

  // main ring (solid, clean)
  const col = `#${(colorHex>>>0).toString(16).padStart(6,'0')}`;
  g.beginPath();
  g.arc(cx, cy, r1, 0, Math.PI*2);
  g.strokeStyle = col;
  g.lineWidth = SZ*0.045;
  g.lineJoin = 'round';
  g.lineCap = 'round';
  g.stroke();

  // small "loading" notch (we'll rotate the sprite)
  g.beginPath();
  g.arc(cx, cy, r1, -0.35, 0.35);
  g.strokeStyle = 'rgba(0,0,0,0.18)';
  g.lineWidth = SZ*0.06;
  g.lineCap = 'round';
  g.stroke();

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.premultiplyAlpha = true;
  tex.needsUpdate = true;

  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
  mat.depthTest = false;
  mat.depthWrite = false;
  mat.premultipliedAlpha = true;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 10002;
  spr.scale.set(worldSize, worldSize, 1);
  spr.userData.isLoadingCircle = true;
  spr.userData.baseScale = spr.scale.clone();
  spr.userData.spin = 1.4;     // rotations/sec (editable via code if needed)
  spr.userData.pulse = 0.18;   // pulse amplitude (scale)
  return spr;
}

function makeSquareSprite(worldSize=6){
  const c = document.createElement('canvas');
  c.width=32; c.height=32;
  const g=c.getContext('2d');
  g.clearRect(0,0,32,32);
  g.fillStyle='rgba(0,0,0,0.95)';
  g.fillRect(6,6,20,20);

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
  mat.depthTest=false; mat.depthWrite=false;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 10005;
  spr.scale.set(worldSize, worldSize, 1);
  spr.userData.baseScale = spr.scale.clone();
  return spr;
}

// Enhanced shape sprite maker supporting multiple shape types
function makeDisplayShapeSprite(worldSize=6, config=null){
  const shapeType = config?.displayShapeType || 'square';
  const fillColor = config?.displayShapeFillColor || 'rgba(0,0,0,0.95)';
  const strokeColor = config?.displayShapeStrokeColor || 'rgba(255,255,255,0.8)';
  const strokeWidth = config?.displayShapeStrokeWidth || 0;
  const opacity = config?.displayShapeOpacity !== undefined ? config.displayShapeOpacity : 1.0;
  
  const c = document.createElement('canvas');
  c.width=64; c.height=64;
  const g=c.getContext('2d');
  g.clearRect(0,0,64,64);
  
  const cx = 32, cy = 32, size = 20;
  
  g.fillStyle = fillColor;
  if (strokeWidth > 0) {
    g.strokeStyle = strokeColor;
    g.lineWidth = strokeWidth;
  }
  
  switch(shapeType) {
    case 'circle':
      g.beginPath();
      g.arc(cx, cy, size/2, 0, Math.PI * 2);
      g.fill();
      if (strokeWidth > 0) g.stroke();
      break;
      
    case 'diamond':
      g.beginPath();
      g.moveTo(cx, cy - size/2);
      g.lineTo(cx + size/2, cy);
      g.lineTo(cx, cy + size/2);
      g.lineTo(cx - size/2, cy);
      g.closePath();
      g.fill();
      if (strokeWidth > 0) g.stroke();
      break;
      
    case 'triangle':
      g.beginPath();
      g.moveTo(cx, cy - size/2);
      g.lineTo(cx + size/2, cy + size/2);
      g.lineTo(cx - size/2, cy + size/2);
      g.closePath();
      g.fill();
      if (strokeWidth > 0) g.stroke();
      break;
      
    case 'asterisk':
      g.strokeStyle = fillColor; // Use fill color for lines
      g.lineWidth = Math.max(2, strokeWidth || 3);
      g.lineCap = 'round';
      g.beginPath();
      // Vertical line
      g.moveTo(cx, cy - size/2);
      g.lineTo(cx, cy + size/2);
      // Horizontal line
      g.moveTo(cx - size/2, cy);
      g.lineTo(cx + size/2, cy);
      // Diagonal \
      g.moveTo(cx - size/2*0.7, cy - size/2*0.7);
      g.lineTo(cx + size/2*0.7, cy + size/2*0.7);
      // Diagonal /
      g.moveTo(cx + size/2*0.7, cy - size/2*0.7);
      g.lineTo(cx - size/2*0.7, cy + size/2*0.7);
      g.stroke();
      break;
      
    case 'square':
    default:
      g.fillRect(cx - size/2, cy - size/2, size, size);
      if (strokeWidth > 0) {
        g.strokeRect(cx - size/2, cy - size/2, size, size);
      }
      break;
  }

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, opacity: opacity });
  mat.depthTest=false; mat.depthWrite=false;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 10005;
  spr.scale.set(worldSize, worldSize, 1);
  spr.userData.baseScale = spr.scale.clone();
  return spr;
}

function makeXSprite(worldSize=6){
  const c = document.createElement('canvas');
  c.width=64; c.height=64;
  const g=c.getContext('2d');
  g.clearRect(0,0,64,64);

  g.strokeStyle='rgba(0,0,0,0.95)';
  g.lineWidth=10;
  g.lineCap='round';
  g.beginPath();
  g.moveTo(16,16); g.lineTo(48,48);
  g.moveTo(48,16); g.lineTo(16,48);
  g.stroke();

  // subtle white halo for contrast
  g.strokeStyle='rgba(255,255,255,0.35)';
  g.lineWidth=14;
  g.beginPath();
  g.moveTo(16,16); g.lineTo(48,48);
  g.moveTo(48,16); g.lineTo(16,48);
  g.stroke();

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
  mat.depthTest=false; mat.depthWrite=false;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 10006;
  spr.scale.set(worldSize, worldSize, 1);
  return spr;
}

function makeLabelSpriteHelveticaBoldBlack(text, worldSize=18){
  const txt = upperSafe(text);

  const fontPx = 28;
  const padX = 6;
  const padY = 6;

  const c = document.createElement('canvas');
  const g = c.getContext('2d', { alpha:true });

  g.font = `900 ${fontPx}px ${currentLabelFontStack}`;
  const tw = Math.ceil(g.measureText(txt).width);
  const w = tw + padX*2;
  const h = fontPx + padY*2;

  c.width = w;
  c.height = h;

  // hard reset state
  g.setTransform(1,0,0,1,0,0);
  g.globalAlpha = 1;
  g.globalCompositeOperation = 'source-over';
  g.imageSmoothingEnabled = true;

  g.clearRect(0,0,w,h);

  // absolutely no shadow / stroke
  g.shadowColor = 'transparent';
  g.shadowBlur = 0;
  g.shadowOffsetX = 0;
  g.shadowOffsetY = 0;

  g.font = `900 ${fontPx}px ${currentLabelFontStack}`;
  g.textBaseline = 'middle';
  g.textAlign = 'left';

  // BLACK ONLY
  g.fillStyle = '#000000';
  g.fillText(txt, padX, h/2);

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;

  // critical: premultiply alpha to avoid light fringe
  tex.premultiplyAlpha = true;
  tex.needsUpdate = true;

  const mat = new THREE.SpriteMaterial({
    map: tex,
    transparent: true,
    depthTest: false,
    depthWrite: false
  });

  // critical: match premultiply mode
  mat.premultipliedAlpha = true;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 10006;

  const aspect = w / h;
  spr.scale.set(worldSize * aspect, worldSize * 0.75, 1);
  return spr;
}

function disposeSprite(obj){
  if (!obj) return;
  if (obj.material?.map) obj.material.map.dispose();
  if (obj.material) obj.material.dispose();
}

function clearMarkers(){
  markerGroup.traverse(o=>{
    if (o.isSprite) disposeSprite(o);
    if (o.isLine){
      if (o.geometry) o.geometry.dispose();
      if (o.material) o.material.dispose();
    }
  });
  markerGroup.clear();
}
function disposeLabels(){
  labelGroup.children.forEach(l=>disposeSprite(l));
  labelGroup.clear();
}

// --------------------
// Hover/select syncing
// --------------------
let currentMarkers=[]; // marker roots (Group)
let hovered=null;
let selected=null;

function rebuildLabels(){
  disposeLabels();
  return; // hard-disable old point labels
}

function updateCalloutsVisibility(){
  // Now driven by Label FX configs with 2 modes: label and hover
  const labelConfig = activeLabels.find(l => l.type === 'label');
  const hoverConfig = activeLabels.find(l => l.type === 'hover');
  
  currentMarkers.forEach(m=>{
    const c = m?.userData?.callout;
    if (!c) return;
    const ud = c.userData;
    
    // Label mode: show on selected marker only
    if (selected === m && labelConfig) {
      ud.target = 1;
      ud.config = labelConfig; // Store config for animation
      return;
    }
    
    // Hover mode: show on hovered marker only (can coexist with label on different marker)
    if (hovered === m && hoverConfig) {
      ud.target = 1;
      ud.config = hoverConfig; // Store config for animation
      return;
    }
    
    // Hide all others
    ud.target = 0;
  });
}

function setSelected(m){
  // restore previous marker visual
  if (selected && selected.userData?.markerVisual){
    selected.userData.markerVisual.visible = true;
  }

  selected = m;
  focusCallout(m);

  // hide ring on selected marker (label becomes the focus)
  if (selected && selected.userData?.markerVisual){
    selected.userData.markerVisual.visible = false;
  }

  [...listEl.querySelectorAll('.item')].forEach(el=>el.classList.remove('sel'));
  if (m){
    const row = listEl.querySelector(`.item[data-idx="${m.userData.idx}"]`);
    if (row){
      row.classList.add('sel');
      row.scrollIntoView({ block:'nearest' });
    }
  }
  selIdEl.textContent = m ? (m.userData.candKey || '—') : '—';
  rebuildLabels();
  updateCalloutsVisibility();
}

function setHovered(m, x, y){
  hovered = m;
  if (!m){
    // No longer using legacy tooltip
    rebuildLabels();
    updateCalloutsVisibility();
    return;
  }
  // No longer using legacy tooltip - hover tip will be shown via 3D label system
  rebuildLabels();
  updateCalloutsVisibility();
}

// --------------------
// Raycast for markers
// --------------------
const raycaster = new THREE.Raycaster();
raycaster.params.Sprite = { threshold: 0.7 };
const mouse = new THREE.Vector2();

function markerRootFromObject(obj){
  let o = obj;
  while (o){
    if (o.userData && o.userData.isMarkerRoot) return o;
    o = o.parent;
  }
  return null;
}

function doHover(clientX, clientY){
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(markerGroup.children, true);
  if (!hits.length){
    if (hovered) setHovered(null, clientX, clientY);
    return;
  }
  const root = markerRootFromObject(hits[0].object);
  if (!root){
    if (hovered) setHovered(null, clientX, clientY);
    return;
  }
  if (root !== hovered){
    setHovered(root, clientX, clientY);
  } else {
    // Tooltip position update removed - using new 3D hover tip system instead
  }
}

// --------------------
// Candidate filtering
// --------------------
function passesFilters(c){

  // hard exclude "NULL" placeholder candidates
  const ck = safeStr(c?.cand_key);
  const t  = safeStr(c?.dst_type).toLowerCase();
  const id = safeStr(c?.dst_id);
  if ((ck === 'landmark:NULL') || (ck === 'landmark:null')) return false;
  if ((ck === 'leisure:NULL')  || (ck === 'leisure:null'))  return false;
  if ((t === 'landmark' || t === 'leisure') && (id === 'NULL' || id === 'null' || id === '')) return false;

  const visMode = visFilterSel.value; // any|visible|not_visible
  const catMode = categoryFilterSel.value; // all|building|amenity|leisure|place
  const lmMode  = landmarkFilterSel.value; // any|landmarks_all|landmarks_buildings|...|non_landmarks

  const distLimit = Number(distMaxIn.value || 2000);
  const d = getCandidateDistanceM(c);
  if (Number.isFinite(d) && d > distLimit) return false;

  const minV = Number(minVis.value || 0);
  if (getCandidateVisPct(c) < minV) return false;

  if (visMode === 'visible' && !isVisibleCandidate(c)) return false;
  if (visMode === 'not_visible' && isVisibleCandidate(c)) return false;

  if (catMode !== 'all'){
    const cat = categoryOf(c);
    if (cat !== catMode) return false;
  }

  const isLm = hasLandmarkIdentity(c);
  if (lmMode === 'landmarks_all' && !isLm) return false;
  if (lmMode === 'non_landmarks' && isLm) return false;

  if (lmMode === 'landmarks_buildings'){
    if (!isLm || landmarkGroupOf(c) !== 'buildings') return false;
  }
  if (lmMode === 'landmarks_leisure'){
    if (!isLm || landmarkGroupOf(c) !== 'leisure') return false;
  }
  if (lmMode === 'landmarks_places'){
    if (!isLm || landmarkGroupOf(c) !== 'places') return false;
  }

  return true;
}

function currentSource(){ return SOURCES[currentIndex] || null; }

function getFilteredCandidates(source){
  const nTop = parseInt(topN.value, 10);

  let arr = Array.isArray(source.candidates) ? source.candidates.slice() : [];
  arr = arr.filter(passesFilters);

  // sort: visible first (by vis%), then closer
  arr.sort((a,b)=>{
    const av=getCandidateVisPct(a);
    const bv=getCandidateVisPct(b);
    if (bv!==av) return bv-av;
    const ad=getCandidateDistanceM(a); const bd=getCandidateDistanceM(b);
    const A = Number.isFinite(ad) ? ad : 1e18;
    const B = Number.isFinite(bd) ? bd : 1e18;
    return A-B;
  });

  if (Number.isFinite(nTop) && nTop > 0) arr = arr.slice(0, nTop);
  return arr;
}

function buildSourceDropdown(){
  const sel = document.getElementById('sourceSelect');
  if (!sel){
    console.warn('[buildSourceDropdown] #sourceSelect not found; skipping dropdown build.');
    return;
  }
  sel.innerHTML = '';
  const optgrpP = document.createElement('optgroup'); optgrpP.label='Panoramas';
  const optgrpV = document.createElement('optgroup'); optgrpV.label='Vistas';

  SOURCES.forEach((s, idx)=>{
    const o = document.createElement('option');
    o.value = String(idx);
    o.textContent = s.id;
    (s.type==='vista' ? optgrpV : optgrpP).appendChild(o);
  });

  if (optgrpP.children.length) sel.appendChild(optgrpP);
  if (optgrpV.children.length) sel.appendChild(optgrpV);

  // wire change (idempotent)
  if (!sel.__wired){
    sel.addEventListener('change', ()=>{
      const i = Number(sel.value);
      if (Number.isFinite(i)) setSourceByIndex(i);
    });
    sel.__wired = true;
  }
}

function updateHeader(){
  const s=currentSource();
  if (!s) return;
  srcTypeEl.textContent = s.type || '—';
  srcIdEl.textContent = s.id || '—';
  srcYawEl.textContent = (s.yaw_deg==null) ? '—' : `${fmt(Number(s.yaw_deg),1)}°`;
  srcOffEl.textContent = `${fmt(getOffsetDeg(s.id),2)}°`;
  srcZEl.textContent   = `${fmt(getZOffsetM(s.id),2)} m`;
  srcMkEl.textContent  = String(markerGroup.children.length);
}

// --------------------
// Callouts (animated focus + reverse)
// --------------------
function lerp(a,b,t){ return a + (b-a)*t; }
function easeOutCubic(t){ return 1 - Math.pow(1-t,3); }
function easeInOutCubic(t){ return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }

function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w*0.5, h*0.5);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y,   x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x,   y+h, rr);
  ctx.arcTo(x,   y+h, x,   y,   rr);
  ctx.arcTo(x,   y,   x+w, y,   rr);
  ctx.closePath();
}

// Black translucent fill + stroke that animates from black -> type color
function makePillLabelSprite(text, worldSize=18, strokeHex=0x000000, config=null){
  const txt = safeStr(text);

  // ---- styling knobs ----
  // Scale fontSize (world size units) to fontPx (canvas pixel units)
  // 2.33 ratio maintains visual consistency with original 12pt = 28px default
  const fontPx = config?.fontSize ? config.fontSize * 2.33 : 28;
  const padX = config?.paddingX ?? 18;
  const padY = config?.paddingY ?? 12;

  // Render at higher pixel density so the outline doesn't look blocky after texture filtering.
  // (The sprite is then scaled in world units.)
  const dpr = Math.max(2, Math.round((window.devicePixelRatio || 1) * 2) / 2); // 2, 2.5, 3...
  const c = document.createElement('canvas');
  const g = c.getContext('2d', { alpha:true });

  // measure text at 1x
  const fontStack = config?.font ? (FONT_STACKS[config.font] || FONT_STACKS.helvetica) : currentLabelFontStack;
  g.font = `900 ${fontPx}px ${fontStack}`;
  const tw = Math.ceil(g.measureText(txt).width);
  const w1 = tw + padX*2;
  const h1 = fontPx + padY*2;

  // allocate hi-res
  c.width  = Math.ceil(w1 * dpr);
  c.height = Math.ceil(h1 * dpr);

  // draw in 1x logical coords
  g.setTransform(dpr, 0, 0, dpr, 0, 0);
  g.clearRect(0,0,w1,h1);

  // Determine radius based on pill shape
  let radius;
  const pillShape = config?.pillShape || 'rounded';
  if (pillShape === 'rounded') {
    radius = h1/2; // true pill (fully rounded ends)
  } else if (pillShape === 'soft-rounded') {
    radius = 10;
  } else { // square
    radius = 0;
  }
  
  const inset  = 3;             // keep stroke away from texture edge to prevent clipping
  const x = inset;
  const y = inset;
  const w = w1 - inset*2;
  const h = h1 - inset*2;

  // Fill: use config background color or default
  const bgColor = config?.pillBackgroundColor || 'rgba(0,0,0,0.55)';
  g.fillStyle = bgColor;
  g.beginPath();
  roundRect(g, x, y, w, h, radius);
  g.fill();

  // Stroke: smooth round joins/caps
  const r = (strokeHex >> 16) & 255;
  const gg = (strokeHex >> 8) & 255;
  const b = (strokeHex) & 255;
  const borderColor = config?.pillBorderColor || `rgba(${r},${gg},${b},0.98)`;
  g.strokeStyle = borderColor;
  g.lineWidth = 2.5;
  g.lineJoin = 'round';
  g.lineCap  = 'round';
  g.beginPath();
  roundRect(g, x, y, w, h, radius);
  g.stroke();

  // Text: use config text color or default
  const textColor = config?.pillTextColor || '#ffffff';
  g.font = `900 ${fontPx}px ${fontStack}`;
  g.textBaseline = 'middle';
  g.textAlign = 'left';
  g.fillStyle = textColor;
  g.fillText(txt, padX, h1/2);

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.premultiplyAlpha = true;
  tex.generateMipmaps = false; // avoids outline stepping as mip levels switch
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.needsUpdate = true;

  const mat = new THREE.SpriteMaterial({
    map: tex,
    transparent: true,
    depthTest: false,
    depthWrite: false
  });
  mat.premultipliedAlpha = true;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 10006;

  const aspect = w1 / h1;
  spr.scale.set(worldSize * aspect, worldSize * 0.85, 1);
  spr.userData.baseScale = spr.scale.clone();
  spr.userData._pillText = txt;
  spr.userData._pillWorldSize = worldSize;
  return spr;
}

function updatePillSprite(sprite, text, worldSize, strokeHex, config=null){
  // dispose old
  if (sprite.material?.map) sprite.material.map.dispose();
  if (sprite.material) sprite.material.dispose();

  // CRITICAL: Pass config to maintain styling through updates
  const fresh = makePillLabelSprite(text, worldSize, strokeHex, config);
  sprite.material = fresh.material;
  sprite.scale.copy(fresh.scale);
  sprite.userData.baseScale = fresh.userData.baseScale.clone();
  sprite.userData._pillText = fresh.userData._pillText;
  sprite.userData._pillWorldSize = fresh.userData._pillWorldSize;
  // Store config for future updates
  if (config) sprite.userData._pillConfig = config;
}

function updatePillFont(sprite){
  if (!sprite?.userData) return;
  const txt = sprite.userData._pillText;
  const ws  = sprite.userData._pillWorldSize;
  const st  = sprite.userData._pillStroke;
  const cfg = sprite.userData._pillConfig; // Use stored config
  if (!txt || !ws) return;
  updatePillSprite(sprite, txt, ws, st || 0x000000, cfg);
}

function updateAllPillFonts(){
  currentMarkers.forEach(m=>{
    const call = m.userData?.callout;
    if (call?.userData?.label) updatePillFont(call.userData.label);
  });
}

// ========== MULTI-LINE PILL SPRITE SYSTEM (Issues 7 & 8) ==========

function makeMultiLinePillSprite(lines, worldSize=18, strokeHex=0x000000, config=null){
  // lines is an array of line objects: [{ text, fontSize, fontFamily, bold, italic, underline, strikethrough, alignment }]
  if (!Array.isArray(lines) || lines.length === 0) {
    // Fallback to single-line sprite
    return makePillLabelSprite('', worldSize, strokeHex, config);
  }

  // ---- styling knobs ----
  const padX = config?.paddingX ?? 18;
  const padY = config?.paddingY ?? 12;
  const lineSpacing = config?.lineSpacing ?? 4; // Gap between lines

  // Render at higher pixel density
  const dpr = Math.max(2, Math.round((window.devicePixelRatio || 1) * 2) / 2);
  const c = document.createElement('canvas');
  const g = c.getContext('2d', { alpha:true });

  // Measure all lines to determine canvas size
  let maxWidth = 0;
  let totalHeight = 0;
  const lineMetrics = [];

  lines.forEach((line, idx) => {
    const lineText = safeStr(line.text || '');
    const fontPx = (line.fontSize || 12) * 2.33;
    const fontStack = FONT_STACKS[line.fontFamily || 'helvetica'] || FONT_STACKS.helvetica;
    const fontWeight = line.bold ? '900' : '400';
    const fontStyle = line.italic ? 'italic' : 'normal';
    
    g.font = `${fontStyle} ${fontWeight} ${fontPx}px ${fontStack}`;
    const tw = Math.ceil(g.measureText(lineText).width);
    
    lineMetrics.push({
      text: lineText,
      fontSize: fontPx,
      fontFamily: fontStack,
      bold: line.bold,
      italic: line.italic,
      underline: line.underline,
      strikethrough: line.strikethrough,
      alignment: line.alignment || 'left',
      width: tw,
      height: fontPx
    });
    
    maxWidth = Math.max(maxWidth, tw);
    totalHeight += fontPx + (idx < lines.length - 1 ? lineSpacing : 0);
  });

  const w1 = maxWidth + padX * 2;
  const h1 = totalHeight + padY * 2;

  // allocate hi-res
  c.width  = Math.ceil(w1 * dpr);
  c.height = Math.ceil(h1 * dpr);

  // draw in 1x logical coords
  g.setTransform(dpr, 0, 0, dpr, 0, 0);
  g.clearRect(0,0,w1,h1);

  // Determine radius based on pill shape
  let radius;
  const pillShape = config?.pillShape || 'rounded';
  if (pillShape === 'rounded') {
    radius = h1/2;
  } else if (pillShape === 'soft-rounded') {
    radius = 10;
  } else {
    radius = 0;
  }
  
  const inset  = 3;
  const x = inset;
  const y = inset;
  const w = w1 - inset*2;
  const h = h1 - inset*2;

  // Fill background
  const bgColor = config?.pillBackgroundColor || 'rgba(0,0,0,0.55)';
  g.fillStyle = bgColor;
  g.beginPath();
  roundRect(g, x, y, w, h, radius);
  g.fill();

  // Stroke border
  const r = (strokeHex >> 16) & 255;
  const gg = (strokeHex >> 8) & 255;
  const b = (strokeHex) & 255;
  const borderColor = config?.pillBorderColor || `rgba(${r},${gg},${b},0.98)`;
  g.strokeStyle = borderColor;
  g.lineWidth = 2.5;
  g.lineJoin = 'round';
  g.lineCap  = 'round';
  g.beginPath();
  roundRect(g, x, y, w, h, radius);
  g.stroke();

  // Draw each line
  const textColor = config?.pillTextColor || '#ffffff';
  let currentY = padY;

  lineMetrics.forEach((metric, idx) => {
    const fontWeight = metric.bold ? '900' : '400';
    const fontStyle = metric.italic ? 'italic' : 'normal';
    g.font = `${fontStyle} ${fontWeight} ${metric.fontSize}px ${metric.fontFamily}`;
    g.fillStyle = textColor;
    g.textBaseline = 'top';
    
    // Calculate X position based on alignment
    let textX;
    if (metric.alignment === 'center') {
      textX = w1 / 2;
      g.textAlign = 'center';
    } else if (metric.alignment === 'right') {
      textX = w1 - padX;
      g.textAlign = 'right';
    } else {
      textX = padX;
      g.textAlign = 'left';
    }
    
    const textY = currentY + metric.fontSize / 2;
    g.textBaseline = 'middle';
    
    // Draw text
    g.fillText(metric.text, textX, textY);
    
    // Draw decorations
    if (metric.underline || metric.strikethrough) {
      g.save();
      g.strokeStyle = textColor;
      g.lineWidth = Math.max(1, metric.fontSize / 16);
      
      // Calculate text bounds for decoration
      g.textAlign = 'left';
      const textWidth = g.measureText(metric.text).width;
      let decorationX;
      if (metric.alignment === 'center') {
        decorationX = (w1 - textWidth) / 2;
      } else if (metric.alignment === 'right') {
        decorationX = w1 - padX - textWidth;
      } else {
        decorationX = padX;
      }
      
      if (metric.underline) {
        const underlineY = textY + metric.fontSize * 0.3;
        g.beginPath();
        g.moveTo(decorationX, underlineY);
        g.lineTo(decorationX + textWidth, underlineY);
        g.stroke();
      }
      
      if (metric.strikethrough) {
        const strikeY = textY;
        g.beginPath();
        g.moveTo(decorationX, strikeY);
        g.lineTo(decorationX + textWidth, strikeY);
        g.stroke();
      }
      
      g.restore();
    }
    
    currentY += metric.height + (idx < lineMetrics.length - 1 ? lineSpacing : 0);
  });

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.premultiplyAlpha = true;
  tex.generateMipmaps = false;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.needsUpdate = true;

  const mat = new THREE.SpriteMaterial({
    map: tex,
    transparent: true,
    depthTest: false,
    depthWrite: false
  });
  mat.premultipliedAlpha = true;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 10006;

  const aspect = w1 / h1;
  spr.scale.set(worldSize * aspect, worldSize * 0.85, 1);
  spr.userData.baseScale = spr.scale.clone();
  spr.userData._pillLines = lines;
  spr.userData._pillWorldSize = worldSize;
  spr.userData._multiLine = true;
  return spr;
}

// ========== END MULTI-LINE SYSTEM ==========

// Helper function to build lines array from config for multi-line pills
function buildLinesFromConfig(config, defaultText, cand) {
  const lines = [];
  
  // Helper to get content text for a line
  function getLineText(lineConfig) {
    if (!lineConfig || !lineConfig.content) return '';
    
    const content = lineConfig.content;
    switch(content) {
      case 'name':
        return safeStr(cand?.name || cand?.dst_name || defaultText || '');
      case 'type':
      case 'category':
        return safeStr(cand?.dst_type || '');
      case 'subtype':
        return safeStr(cand?.amenity || cand?.leisure || cand?.place || '');
      case 'landmark':
        // Check if it's a landmark and format appropriately
        const isLandmark = cand?.landmark === true || cand?.landmark === 'true';
        if (isLandmark) {
          const subtype = safeStr(cand?.amenity || cand?.leisure || cand?.place || '');
          return subtype ? `Landmark – ${subtype}` : 'Landmark';
        } else {
          const dstType = safeStr(cand?.dst_type || '');
          const subtype = safeStr(cand?.amenity || cand?.leisure || cand?.place || '');
          if (dstType && subtype) {
            return `${dstType} – ${subtype}`;
          } else if (dstType) {
            return dstType;
          } else if (subtype) {
            return subtype;
          }
          return '';
        }
      case 'distance':
        const dist = getCandidateDistanceM(cand);
        return dist !== undefined ? `${fmt(dist, 1)}m` : '';
      case 'bearing':
        const bearing = cand?.base_rel_yaw;
        return bearing !== undefined ? `${fmt(bearing, 1)}°` : '';
      case 'visibility':
        const vis = getCandidateVisPct(cand);
        return vis !== undefined ? `${fmt(vis, 0)}%` : '';
      case 'elevation':
        const elev = cand?.base_elev;
        return elev !== undefined ? `${fmt(elev, 2)}°` : '';
      case 'custom':
        return lineConfig.customText || '';
      default:
        return '';
    }
  }
  
  // Build line 1
  if (config.line1) {
    const text = getLineText(config.line1);
    if (text) {
      lines.push({
        text: text,
        fontSize: config.line1.fontSize || 14,
        fontFamily: config.line1.fontFamily || 'helvetica',
        bold: config.line1.bold !== false, // Default true for line 1
        italic: config.line1.italic || false,
        underline: config.line1.underline || false,
        strikethrough: config.line1.strikethrough || false,
        alignment: config.line1.alignment || 'left'
      });
    }
  }
  
  // Build line 2
  if (config.line2) {
    const text = getLineText(config.line2);
    if (text) {
      lines.push({
        text: text,
        fontSize: config.line2.fontSize || 11,
        fontFamily: config.line2.fontFamily || 'helvetica',
        bold: config.line2.bold || false,
        italic: config.line2.italic || false,
        underline: config.line2.underline || false,
        strikethrough: config.line2.strikethrough || false,
        alignment: config.line2.alignment || 'left'
      });
    }
  }
  
  // Build line 3
  if (config.line3) {
    const text = getLineText(config.line3);
    if (text) {
      lines.push({
        text: text,
        fontSize: config.line3.fontSize || 9,
        fontFamily: config.line3.fontFamily || 'helvetica',
        bold: config.line3.bold || false,
        italic: config.line3.italic || false,
        underline: config.line3.underline || false,
        strikethrough: config.line3.strikethrough || false,
        alignment: config.line3.alignment || 'left'
      });
    }
  }
  
  // Fallback to single line if no lines were added
  if (lines.length === 0) {
    lines.push({
      text: defaultText || '',
      fontSize: config.fontSize || 12,
      fontFamily: config.font || 'helvetica',
      bold: false,
      italic: false,
      underline: false,
      strikethrough: false,
      alignment: 'left'
    });
  }
  
  return lines;
}

function makeCalloutAnimated(root, name, isVisible=true, typeHex=0x00c8ff, lineColorHex=null, config=null){
  // Use config if provided, otherwise use defaults
  const rise = config?.lineHeight || 40;
  const sqW  = config?.displayShapeSize || 6;
  const lblW = 18; // Label world size (can be config-driven in future)
  const showLine = config?.showLine !== false; // default true
  const showDisplayShape = config?.showDisplayShape !== false; // default true

  // gaps: square -> line start, line end -> square, square -> label
  const gap1 = Math.max(1.5, sqW * 0.35);
  const gap2 = Math.max(1.5, sqW * 0.35);
  const gap3 = Math.max(2.0, sqW * 0.45);

  const call = new THREE.Group();
  call.renderOrder = 10000;
  call.userData.isCallout = true;

  // Bottom square serves as anchor point for positioning calculations (always hidden)
  const sq1 = makeSquareSprite(sqW);
  sq1.position.set(0,0,0);
  sq1.visible = false; // Always hidden, just anchor
  call.add(sq1);

  // line (animate end Y). Start at gap1 so there's an air gap above square.
  let line = null;
  if (showLine) {
    const pts = [new THREE.Vector3(0, gap1, 0), new THREE.Vector3(0, gap1, 0)];
    const geo = new THREE.BufferGeometry().setFromPoints(pts);

    const actualLineColor = lineColorHex !== null ? lineColorHex : typeHex;
    if (isVisible){
      const mat = new THREE.LineBasicMaterial({ color: actualLineColor, transparent:true, opacity:0.0 });
      mat.depthTest = false;
      line = new THREE.Line(geo, mat);
    } else {
      const mat = new THREE.LineDashedMaterial({
        color: actualLineColor,
        transparent:true,
        opacity:0.0,
        dashSize: Math.max(3, rise * 0.18),
        gapSize:  Math.max(2, rise * 0.12)
      });
      mat.depthTest = false;
      line = new THREE.Line(geo, mat);
      line.computeLineDistances();
    }
    line.renderOrder = 10001;
    call.add(line);
  }

  // X marker at halfway for NOT visible (fades with the line)
  let xSpr = null;
  if (!isVisible && showLine){
    xSpr = makeXSprite(Math.max(5, sqW*0.95));
    xSpr.position.set(0, rise*0.5, 0);
    xSpr.material.opacity = 0.0;
    call.add(xSpr);
  }

  // top display shape - CRITICAL: Position based on FINAL line height (rise)
  let sq2 = null;
  if (showDisplayShape) {
    sq2 = makeDisplayShapeSprite(sqW, config);
    // Compute final position: rise (total height) - gap2 (gap from line end to shape)
    // Add displayShapeOffset: 0 = line top, positive = higher, negative = lower
    const displayShapeOffset = config?.displayShapeOffset || 0;
    const finalShapeY = rise - gap2 + displayShapeOffset;
    sq2.position.set(0, finalShapeY, 0);
    call.add(sq2);
  }

  // pill label - CRITICAL: Position based on FINAL positions (computed before animation)
  // Check if multi-line mode is enabled
  let label;
  if (config?.useMultiLine) {
    // Build lines array from config
    const lines = buildLinesFromConfig(config, name, root?.userData?.cand);
    label = makeMultiLinePillSprite(lines, lblW, 0x000000, config);
  } else {
    label = makePillLabelSprite(name, lblW, 0x000000, config);
  }
  
  const labelHalfH = (label.userData?.baseScale ? (label.userData.baseScale.y*0.5) : (label.scale.y*0.5));
  const labelHalfW = (label.userData?.baseScale ? (label.userData.baseScale.x*0.5) : (label.scale.x*0.5));
  
  // Get positioning config
  const pillPosition = config?.pillPosition || "top-center";
  const pillTopGap = config?.pillTopGap !== undefined ? config.pillTopGap : gap3;
  const pillSideGap = config?.pillSideGap !== undefined ? config.pillSideGap : 2.0;
  const pillSideAlignment = config?.pillSideAlignment || "shape";
  const pillOffset = config?.pillOffset || 0; // Additional vertical offset
  
  // Compute label position based on mode
  const displayShapeOffset = config?.displayShapeOffset || 0;
  const finalShapeY = rise - gap2 + displayShapeOffset;
  const lineTopY = rise - gap2; // Where line ends (or would end)
  
  let finalLabelX = 0;
  let finalLabelY = 0;
  
  switch(pillPosition) {
    case "top-center":
      finalLabelX = 0;
      finalLabelY = finalShapeY + (sqW*0.5) + pillTopGap + labelHalfH + pillOffset;
      break;
      
    case "top-left":
      // Pill right edge meets the line
      finalLabelX = -labelHalfW;
      finalLabelY = finalShapeY + (sqW*0.5) + pillTopGap + labelHalfH + pillOffset;
      break;
      
    case "top-right":
      // Pill left edge meets the line
      finalLabelX = labelHalfW;
      finalLabelY = finalShapeY + (sqW*0.5) + pillTopGap + labelHalfH + pillOffset;
      break;
      
    case "side-left":
      finalLabelX = -pillSideGap - labelHalfW;
      if (pillSideAlignment === "shape") {
        finalLabelY = finalShapeY + pillOffset; // Align center with shape
      } else {
        finalLabelY = lineTopY + pillOffset; // Align center with line top
      }
      break;
      
    case "side-right":
      finalLabelX = pillSideGap + labelHalfW;
      if (pillSideAlignment === "shape") {
        finalLabelY = finalShapeY + pillOffset; // Align center with shape
      } else {
        finalLabelY = lineTopY + pillOffset; // Align center with line top
      }
      break;
      
    default: // fallback to top-center
      finalLabelX = 0;
      finalLabelY = finalShapeY + (sqW*0.5) + pillTopGap + labelHalfH + pillOffset;
      break;
  }
  
  label.position.set(finalLabelX, finalLabelY, 0);
  label.material.opacity = 0.0;
  call.add(label);

  // init hidden
  const bs1 = sq1.userData?.baseScale;
  if (bs1) sq1.scale.copy(bs1).multiplyScalar(0.0001); else sq1.scale.setScalar(0.0001);
  
  if (sq2) {
    const bs2 = sq2.userData?.baseScale;
    if (bs2) sq2.scale.copy(bs2).multiplyScalar(0.0001); else sq2.scale.setScalar(0.0001);
  }

  // always on top
  call.traverse(o=>{
    if (o.isSprite && o.material){
      o.material.depthTest = false;
      o.material.depthWrite = false;
    }
    if (o.isLine && o.material){
      o.material.depthTest = false;
    }
  });

  call.userData = {
    isCallout: true,
    name,
    rise, sqW, lblW,
    gap1, gap2, gap3,
    typeHex: (typeHex ?? 0x00c8ff),
    lineColorHex: (lineColorHex !== null ? lineColorHex : (typeHex ?? 0x00c8ff)),
    sq1, sq2, line, label, xSpr,
    t: 0,
    target: 0,
    speed: config?.animSeconds ? (1 / config.animSeconds) : (1 / 1.8),
    lastStrokeHex: 0x000000,
    config: config // Store config for updates
  };

  root.userData.callout = call;
  root.add(call);
  return call;
}

let focusedMarker = null;

function focusCallout(marker){
  // reverse old
  if (focusedMarker && focusedMarker.userData?.callout){
    focusedMarker.userData.callout.userData.target = 0;
  }
  focusedMarker = marker || null;
  if (focusedMarker && focusedMarker.userData?.callout){
    focusedMarker.userData.callout.userData.target = 1;
  }
}

let lastCalloutFrameT = performance.now();
let lastSpinT = performance.now();
let spinSpeed = 2.4; // turns/sec-ish

function updateCalloutAnims(){
  const now = performance.now();
  const dt = Math.min(0.05, (now - lastCalloutFrameT) / 1000);
  lastCalloutFrameT = now;

  // Note: ud.target is set by updateCalloutsVisibility() based on Label FX configs
  // We just animate from current t to target

  currentMarkers.forEach(m=>{
    const call = m?.userData?.callout;
    if (!call) return;
    const ud = call.userData;

    // Use config-specific animation speed if available
    const config = ud.config;
    const animSeconds = config?.animSeconds || 1.8;
    ud.speed = (1 / Math.max(0.05, animSeconds));

    // advance t toward target
    if (ud.t !== ud.target){
      const dir = (ud.target > ud.t) ? 1 : -1;
      ud.t = clamp(ud.t + dir * ud.speed * dt, 0, 1);
    }

    // show/hide
    call.visible = (ud.t > 0.001);

    // staged timing (FIXED: proper line→shape→pill sequencing):
    // 0-0.16: bottom square pop (anchor, always hidden)
    // 0.16-0.62: line grows (completes before shape starts)
    // 0.62-0.82: display shape pop (starts after line completes)
    // 0.82-1.00: pill label (starts after shape completes)
    const t = ud.t;

    const t1 = clamp((t - 0.00)/0.16, 0, 1);
    const t2 = clamp((t - 0.16)/0.46, 0, 1);
    const t3 = clamp((t - 0.62)/0.20, 0, 1); // Fixed: now starts at 0.62, after line
    const t4 = clamp((t - 0.82)/0.18, 0, 1); // Fixed: now starts at 0.82, after shape

    const k1 = easeOutCubic(t1);
    const k2 = easeInOutCubic(t2);
    const k3 = easeOutCubic(t3);
    const k4 = easeOutCubic(t4);

    // bottom square (hidden anchor)
    {
      const bs = ud.sq1?.userData?.baseScale;
      const s = Math.max(0.0001, k1);
      if (ud.sq1) {
        if (bs) ud.sq1.scale.copy(bs).multiplyScalar(s);
        else ud.sq1.scale.setScalar(s);
      }
    }

    // Stroke phase calculation (needed for both line and label color transitions)
    const strokePhase = clamp((t - 0.82)/0.18, 0, 1);
    const sp = easeOutCubic(strokePhase);

    // line end Y, leaving gaps (only if line exists)
    if (ud.line) {
      const usable = Math.max(0, ud.rise - ud.gap1 - ud.gap2);
      const endY = ud.gap1 + usable * k2;

      const pos = ud.line.geometry.attributes.position;
      pos.setXYZ(0, 0, ud.gap1, 0);
      pos.setXYZ(1, 0, endY, 0);
      pos.needsUpdate = true;

      ud.line.material.opacity = 0.95 * k2;
      if (ud.line.isLine && ud.line.material.isLineDashedMaterial){
        ud.line.computeLineDistances();
      }
      
      // optional X marker
      if (ud.xSpr && ud.xSpr.material){
        ud.xSpr.material.opacity = 0.95 * k2;
      }
      
      // Line color transition
      const ltr = (ud.lineColorHex >> 16) & 255;
      const ltg = (ud.lineColorHex >> 8) & 255;
      const ltb = ud.lineColorHex & 255;
      const lrr = Math.round(lerp(0, ltr, sp));
      const lrg = Math.round(lerp(0, ltg, sp));
      const lrb = Math.round(lerp(0, ltb, sp));
      const lineStrokeHex = (lrr<<16) | (lrg<<8) | lrb;
      ud.line.material.color.setHex(lineStrokeHex);
    }
    
    // CRITICAL: Line height (rise) is PRIMARY VERTICAL AUTHORITY
    // All positioning uses rise, even when line is hidden
    const usable = Math.max(0, ud.rise - ud.gap1 - ud.gap2);
    const endY = ud.line ? (ud.gap1 + usable * k2) : (ud.rise - ud.gap2); // Animated or full height
    
    // Display shape: Position is FIXED at creation time, only animate scale
    if (ud.sq2) {
      // Do NOT reposition - position was computed before animation
      const bs = ud.sq2.userData?.baseScale;
      const s = Math.max(0.0001, k3);
      if (bs) ud.sq2.scale.copy(bs).multiplyScalar(s);
      else ud.sq2.scale.setScalar(s);
    }
    
    // Label: Position is FIXED at creation time, only animate opacity and scale
    // Do NOT reposition - position was computed before animation
    ud.label.material.opacity = k4;

    // slight scale-in while keeping aspect
    const baseScale = 0.90 + 0.10 * k4;
    const bs = ud.label.userData?.baseScale;
    if (bs){
      ud.label.scale.set(bs.x * baseScale, bs.y * baseScale, 1);
    }

    // Label stroke color transition: black -> typeHex (using sp calculated above)
    const tr = (ud.typeHex >> 16) & 255;
    const tg = (ud.typeHex >> 8) & 255;
    const tb = ud.typeHex & 255;
    const rr = Math.round(lerp(0, tr, sp));
    const rg = Math.round(lerp(0, tg, sp));
    const rb = Math.round(lerp(0, tb, sp));
    const strokeHex = (rr<<16) | (rg<<8) | rb;

    if (strokeHex !== ud.lastStrokeHex){
      // Pass config to maintain styling
      updatePillSprite(ud.label, ud.name, ud.lblW, strokeHex, ud.config);
      ud.lastStrokeHex = strokeHex;
    }
  });
}
// --------------------
// Marker building
// --------------------
function addMarker(source, cand, idx){
  const baseRel  = Number(cand.rel_bear ?? 0);
  const baseElev = Number(cand.elev_ang_d ?? 0);
  const dist     = getCandidateDistanceM(cand);

  const candKey = candidateStableId(cand);
  const pAdj = getPointAdj(source.id, candKey);

  const offYaw = getOffsetDeg(source.id);
  const offZ_m = getZOffsetM(source.id);

  // Total yaw = rel - globalYaw - pointYaw
  const yawDeg = norm360(baseRel - offYaw - (pAdj.yaw || 0));

  // Total pitch = baseElev + globalZ(dist) + pointZ(dist) + pointPitchDeg
  let pitchDeg = baseElev;
  pitchDeg += zMetersToDeg(offZ_m, dist);
  pitchDeg += zMetersToDeg((pAdj.z || 0), dist);
  pitchDeg += (pAdj.pitch || 0);
  pitchDeg = clamp(pitchDeg, -MAX_PITCH_DEG, MAX_PITCH_DEG);

  const dir = yawPitchToDir(yawDeg, pitchDeg);
  const pos = dir.clone().multiplyScalar(MARKER_RADIUS);

  const size = parseFloat(mWorld.value) || 18;

  const colorHex = colorHexForCandidate(cand);

  const root = new THREE.Group();
  root.position.copy(pos);
  root.userData = {
    isMarkerRoot: true,
    cand,
    idx,
    candKey,
    name: candidateName(cand),
    baseRel,
    baseElev,
    yawDeg,
    pitchDeg,
    colorHex
  };

  // hit target (invisible) so selection still works when visual is hidden
  const hit = new THREE.Mesh(new THREE.SphereGeometry(Math.max(1.5, size*0.25), 8, 8), new THREE.MeshBasicMaterial({transparent:true, opacity:0.0, depthTest:false, depthWrite:false,
    depthTest:false}));
  hit.renderOrder = 10001;
  root.add(hit);

  // Visual markers and labels are now added by modular FX systems
  
  markerGroup.add(root);
  return root;
}

function addDebugMarker(){
  if (!debugDotIn.checked) return null;
  const size = Math.max(22, (parseFloat(mWorld.value)||18) + 8);

  const dir = yawPitchToDir(0, 0);
  const pos = dir.clone().multiplyScalar(MARKER_RADIUS);

  const root = new THREE.Group();
  root.position.copy(pos);
  root.userData = {
    isMarkerRoot: true,
    cand: { dst_type:'debug' },
    idx: -1,
    candKey: 'debug:forward',
    name: 'DEBUG: forward (yaw 0 / pitch 0)',
    baseRel: 0,
    baseElev: 0,
    yawDeg: 0,
    pitchDeg: 0,
    colorHex: 0x00c8ff
  };

    const hit = new THREE.Mesh(new THREE.SphereGeometry(Math.max(1.5, size*0.25), 8, 8), new THREE.MeshBasicMaterial({transparent:true, opacity:0.0, depthTest:false, depthWrite:false,
    depthTest:false}));
  hit.renderOrder = 10001;
  root.add(hit);

  const ring = makeLoadingCircleMarker(size, 0x00c8ff);
  ring.userData.markerVisual = true;
  root.userData.markerVisual = ring;
  root.add(ring);
  
  // Create callout with default config
  const labelConfig = activeLabels.find(l => l.type === 'label');
  const hoverConfig = activeLabels.find(l => l.type === 'hover');
  const useConfig = labelConfig || hoverConfig;
  makeCalloutAnimated(root, root.userData.name, true, root.userData.colorHex, null, useConfig);
  
  markerGroup.add(root);
  return root;
}

// --------------------
// Rebuild markers + list (with colors retained)
// --------------------
function rebuildMarkersAndList(){
  clearMarkers();
  disposeLabels();
  currentMarkers = [];
  hovered = null;
  selected = null;
  // hideTooltip(); // Removed - legacy tooltip system has been replaced
  selIdEl.textContent='—';

  const source = currentSource();
  if (!source) return;

  const cands = getFilteredCandidates(source);

  listEl.innerHTML='';
  if (!cands.length){
    const empty=document.createElement('div');
    empty.style.padding='12px 10px';
    empty.style.opacity='.8';
    empty.textContent='No candidates for current filters.';
    listEl.appendChild(empty);

    addDebugMarker();
    updateHeader();
    setStatus(`Loaded: ${source.id} • markers: ${markerGroup.children.length} (debug may be shown)`);
    rebuildLabels();
    updateCalloutsVisibility();
    return;
  }

  cands.forEach((c,i)=>{
    const m = addMarker(source, c, i);
    currentMarkers.push(m);

    const item=document.createElement('div');
    item.className='item';
    item.dataset.idx=String(i);

    const left=document.createElement('div');
    left.className='left';
    left.textContent=String(i+1);

    const main=document.createElement('div');
    main.className='main';

    const name=document.createElement('div');
    name.className='name';
    name.textContent=candidateName(c);

    const meta=document.createElement('div');
    meta.className='meta';

    // swatch (persistent type coloring)
    const sw = document.createElement('div');
    sw.className = 'swatch';
    const ch = colorHexForCandidate(c);
    sw.style.background = `#${(ch>>>0).toString(16).padStart(6,'0')}`;

    const ck = candidateStableId(c);
    const adj = getPointAdj(source.id, ck);

    const lm = (c.LMID_ ? `LMID: ${c.LMID_}` : (c.dst_id ? `ID: ${c.dst_id}` : (c.osm_id ? `OSM: ${c.osm_id}` : '')));
    const vis = `vis ${fmt(getCandidateVisPct(c),0)}%`;
    const rb  = `rel ${fmt(Number(c.rel_bear ?? 0),1)}°`;
    const el  = `elev ${fmt(Number(c.elev_ang_d ?? 0),2)}°`;
    const d   = `dist ${fmt(getCandidateDistanceM(c),1)}m`;
    const pa  = `pt yaw ${fmt(adj.yaw,2)}° • pt pitch ${fmt(adj.pitch,2)}° • pt z ${fmt(adj.z,2)}m`;

    meta.innerHTML =
      `<span class="tag">${safeStr(c.dst_type||categoryOf(c)||'dst')}</span>` +
      (lm ? `<span class="tag">${lm}</span>` : '') +
      `<span class="tag">${vis}</span>` +
      `<span class="tag">${rb}</span>` +
      `<span class="tag">${el}</span>` +
      `<span class="tag">${d}</span>` +
      `<span class="tag">${pa}</span>`;

    const nameRow = document.createElement('div');
    nameRow.style.display = 'flex';
    nameRow.style.gap = '8px';
    nameRow.style.alignItems = 'flex-start';
    nameRow.appendChild(sw);
    nameRow.appendChild(name);

    main.appendChild(nameRow);
    main.appendChild(meta);

    item.appendChild(left);
    item.appendChild(main);

    item.addEventListener('mousemove', (e)=> setHovered(m, e.clientX, e.clientY));
    item.addEventListener('mouseleave', ()=> setHovered(null, 0, 0));

    item.addEventListener('click', ()=>{
      setSelected(m);
      setViewYawPitch(
        THREE.MathUtils.degToRad(m.userData.yawDeg),
        THREE.MathUtils.degToRad(m.userData.pitchDeg),
        true
      );
    });

    listEl.appendChild(item);
  });

  // Apply modular marker FX to all markers
  applyAllMarkerFX();

  addDebugMarker();
  updateHeader();
  setStatus(`Loaded: ${source.id} • markers: ${markerGroup.children.length} (includes debug if on)`);

  // Apply labels
  applyAllLabelFX();
  updateCalloutsVisibility();

  // if we had a previously selected candKey and it still exists, restore selection
}

// --------------------
// Pano load
// --------------------
let currentTexture=null;
function loadPanoImage(source){
  return new Promise((resolve)=>{
    const imgRel = sourceToImagePath(source);
    if (!imgRel){
      sphereMesh.material = new THREE.MeshBasicMaterial({ color: 0x111111 });
      setStatus(`No image path for ${source.id}`);
      resolve(false);
      return;
    }

    setStatus(`Loading image: ${imgRel}`);
    const loader = new THREE.TextureLoader();
    loader.load(
      imgRel,
      (tex)=>{
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.needsUpdate = true;
        if (currentTexture) currentTexture.dispose();
        currentTexture = tex;
        sphereMesh.material = new THREE.MeshBasicMaterial({ map: tex });
        sphereMesh.material.needsUpdate = true;
        // ensure pano fade works
        sphereMesh.material.transparent = true;
        sphereMesh.material.opacity = (typeof overlayState !== 'undefined' && overlayState && overlayState.panoFade != null) ? overlayState.panoFade : 1.0;
        sphereMesh.material.needsUpdate = true;
        resolve(true);
      },
      undefined,
      (err)=>{
        console.error('Texture load failed', imgRel, err);
        sphereMesh.material = new THREE.MeshBasicMaterial({ color: 0x111111 });
        setStatus(`❌ Image failed: ${imgRel}`);
        resolve(false);
      }
    );
  });
}


function syncOverlayUI(){
  if (!overlayMesh) return;
  const op = ovOpacity ? parseFloat(ovOpacity.value) : 0.65;
  overlayMesh.material.opacity = Number.isFinite(op) ? op : 0.65;
}


/* ===========================
   Overlay (Rules + Presets)
   Ported from your overlay viewer
=========================== */

function ovSetStatus(msg){
  const el = document.getElementById('ovStatus');
  if (el) el.textContent = String(msg ?? '');
}

function safeUUID(){
  try{ return (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('r_'+Math.random().toString(16).slice(2)); }
  catch{ return 'r_'+Math.random().toString(16).slice(2); }
}

function defaultRule(){
  return {
    id: safeUUID(),
    name: "vegetation",
    hueMin: 70,
    hueMax: 170,
    action: "recolor",
    color: "#00ff5a",
    opacity: 1.0
  };
}

let overlayState = {
  mode: 0,
  showOverlay: true,
  overlayOpacity: 0.65,
  lineWidth: 0,
  maskThresh: 0.12,
  panoFade: 1.0,
  bgColor: "#0b0b0b",
  bgOpacity: 1.0,
  singleColor: "#00ffd0",
  minSat: 0.16,
  minVal: 0.10,
  rules: []
};

const PRESET_KEY = "todi_overlay_presets_v1";
const BUILTIN_PRESETS = [
  {
    name: "Original Tones with Lavender Background",
    settings: {
      "mode": 0,
      "showOverlay": true,
      "overlayOpacity": 0.53,
      "lineWidth": 0,
      "maskThresh": 0.37,
      "panoFade": 0.58,
      "bgColor": "#cca0e3",
      "singleColor": "#f7edf6",
      "minSat": 0.16,
      "minVal": 0.1,
      "rules": [],
      "meta": {
        "title": 'Todi',
        "lat": 42.780,
        "lon": 12.410,
        "epsg3857": { "x": 0, "y": 0 },
        "headingDeg": 0,
        "headingLabel": "N"
      }
    }
  },
  {
    name: "Monochrome green trees",
    settings: {
      "mode": 2,
      "showOverlay": true,
      "overlayOpacity": 0.95,
      "lineWidth": 0,
      "maskThresh": 0.12,
      "panoFade": 0.1,
      "bgColor": "#0b0b0b",
      "singleColor": "#00ffd0",
      "minSat": 0.16,
      "minVal": 0.1,
      "rules": [
        { "id": "a8b898bc-580b-4db0-8954-54b380451028", "name":"vegetation", "hueMin":54, "hueMax":120, "action":"recolor", "color":"#80a38c", "opacity":1 },
        { "id": "ed5afa3c-7724-4e0c-96f1-eb2bd1990440", "name":"sky", "hueMin":185, "hueMax":245, "action":"original", "color":"#33b7ff", "opacity":1 },
        { "id": "d19477d3-0e0e-43f0-bf01-38a525078a9d", "name":"stone", "hueMin":0, "hueMax":35, "action":"recolor", "color":"#b3846b", "opacity":0.43 }
      ]
    }
  },
  {
    name: "Light blue lines — pale tones",
    settings: {
      "mode": 1,
      "showOverlay": true,
      "overlayOpacity": 1,
      "lineWidth": 0,
      "maskThresh": 0.79,
      "panoFade": 0.38,
      "bgColor": "#e8d1a1",
      "singleColor": "#d5e6ec",
      "minSat": 0.16,
      "minVal": 0.1,
      "rules": []
    }
  },
  {
    name: "Mustard and light blue",
    settings: {
      "mode": 1,
      "showOverlay": true,
      "overlayOpacity": 0.65,
      "lineWidth": 0,
      "maskThresh": 0.84,
      "panoFade": 0.38,
      "bgColor": "#e5a315",
      "singleColor": "#d5e6ec",
      "minSat": 0.16,
      "minVal": 0.1,
      "rules": []
    }
  }
];

function loadPresetStore(){
  try{
    const raw = localStorage.getItem(PRESET_KEY);
    const list = raw ? JSON.parse(raw) : [];
    return Array.isArray(list) ? list : [];
  }catch{
    return [];
  }
}
function savePresetStore(list){ localStorage.setItem(PRESET_KEY, JSON.stringify(list)); }
function getAllPresets(){ return [...BUILTIN_PRESETS, ...loadPresetStore()]; }

function getOverlaySettings(){ return JSON.parse(JSON.stringify(overlayState)); }
function syncSettingsBox(){
  const box = document.getElementById('settingsBox');
  if (box) box.value = JSON.stringify(getOverlaySettings(), null, 2);
}

function encodeShareLink(){
  const json = JSON.stringify(getOverlaySettings());
  const b64 = btoa(unescape(encodeURIComponent(json)))
    .replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
  location.hash = "ov=" + b64;
  return location.href;
}
function decodeOverlayFromHash(){
  const h = location.hash || "";
  const m = h.match(/ov=([A-Za-z0-9\-_]+)/);
  if(!m) return null;
  const b64 = m[1].replace(/-/g,"+").replace(/_/g,"/");
  const pad = b64.length % 4 ? "=".repeat(4 - (b64.length % 4)) : "";
  try{
    const json = decodeURIComponent(escape(atob(b64 + pad)));
    return JSON.parse(json);
  }catch{ return null; }
}

function applyOverlaySettings(obj){
  overlayState = {
    ...overlayState,
    ...obj,
    rules: Array.isArray(obj?.rules) ? obj.rules : overlayState.rules
  };
  const modeSel = document.getElementById('modeSel');
  const toggleOverlay = document.getElementById('toggleOverlay');
  const overlayOpacity = document.getElementById('overlayOpacity');
  const overlayOpacityNum = document.getElementById('overlayOpacityNum');
  const lineWidth = document.getElementById('lineWidth');
  const lineWidthNum = document.getElementById('lineWidthNum');
  const maskThresh = document.getElementById('maskThresh');
  const maskThreshNum = document.getElementById('maskThreshNum');
  const panoFade = document.getElementById('panoFade');
  const panoFadeNum = document.getElementById('panoFadeNum');
  const bgColor = document.getElementById('bgColor');
  const bgOpacity = document.getElementById('bgOpacity');
  const bgOpacityNum = document.getElementById('bgOpacityNum');
  const singleColor = document.getElementById('singleColor');
  const minSat = document.getElementById('minSat');
  const minSatNum = document.getElementById('minSatNum');
  const minVal = document.getElementById('minVal');
  const minValNum = document.getElementById('minValNum');

  if (modeSel) modeSel.value = String(overlayState.mode);
  if (toggleOverlay) toggleOverlay.checked = !!overlayState.showOverlay;
  if (overlayOpacity) overlayOpacity.value = String(overlayState.overlayOpacity);
  if (lineWidth) lineWidth.value = String(overlayState.lineWidth);
  if (maskThresh) maskThresh.value = String(overlayState.maskThresh);
  if (panoFade) panoFade.value = String(overlayState.panoFade);
  if (bgColor) bgColor.value = overlayState.bgColor || "#0b0b0b";
  if (bgOpacity) bgOpacity.value = String(overlayState.bgOpacity ?? 1.0);
  if (bgOpacityNum) bgOpacityNum.value = String(overlayState.bgOpacity ?? 1.0);
  if (singleColor) singleColor.value = overlayState.singleColor || "#00ffd0";
  if (minSat) minSat.value = String(overlayState.minSat);
  if (minVal) minVal.value = String(overlayState.minVal);

  // apply to pano sphere
  try{
    if (sphereMesh && sphereMesh.material){
      sphereMesh.material.transparent = true;
      sphereMesh.material.opacity = overlayState.panoFade;
    }
  }catch{}

  // background
  try{
    document.body.style.background = overlayState.bgColor || "#000";
    if (renderer && renderer.setClearColor) renderer.setClearColor(new THREE.Color(overlayState.bgColor || "#000"), (overlayState.bgOpacity ?? 1.0));
  }catch{}

  refreshModeUI_Overlay();
  renderRulesUI();
  syncRulesToShader();
  syncSettingsBox();
}

let overlayShaderMaterial = null;

function buildOverlayMaterial(edgeTex, maskTex){
  if(edgeTex.colorSpace !== undefined) edgeTex.colorSpace = THREE.SRGBColorSpace;
  edgeTex.generateMipmaps = false;
  edgeTex.minFilter = THREE.LinearFilter;
  edgeTex.magFilter = THREE.LinearFilter;
  edgeTex.anisotropy = renderer.capabilities.getMaxAnisotropy();


  if(maskTex){
    if(maskTex.colorSpace !== undefined) maskTex.colorSpace = THREE.SRGBColorSpace;
    maskTex.generateMipmaps = false;
    maskTex.minFilter = THREE.LinearFilter;
    maskTex.magFilter = THREE.LinearFilter;
    maskTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
  }
  overlayShaderMaterial = new THREE.ShaderMaterial({
    transparent:true,
    depthWrite:false,
    depthTest:false,
    uniforms:{
      uTex:{value:edgeTex},
      uMask:{value:maskTex || edgeTex},
      uMode:{value:overlayState.mode},
      uOpacity:{value:overlayState.overlayOpacity},
      uWidth:{value:overlayState.lineWidth},
      uThresh:{value:overlayState.maskThresh},
      uSingle:{value:new THREE.Color(overlayState.singleColor)},
      uMinSat:{value:overlayState.minSat},
      uMinVal:{value:overlayState.minVal},
      uRuleCount:{value:0},
      uHueMin:{value:new Array(12).fill(0)},
      uHueMax:{value:new Array(12).fill(0)},
      uAction:{value:new Array(12).fill(0)},
      uColor:{value:new Array(12).fill(0).map(()=>new THREE.Color("#ffffff"))},
      uOpacityRule:{value:new Array(12).fill(1)},
    },
    vertexShader:`
      varying vec2 vUv;
      void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.); }
    `,
    fragmentShader:`
      varying vec2 vUv;
      uniform sampler2D uTex;
      uniform sampler2D uMask;

      uniform int uMode;
      uniform float uOpacity;
      uniform float uWidth;
      uniform float uThresh;

      uniform vec3 uSingle;

      uniform float uMinSat;
      uniform float uMinVal;

      uniform int uRuleCount;
      uniform float uHueMin[12];
      uniform float uHueMax[12];
      uniform int uAction[12];
      uniform vec3 uColor[12];
      uniform float uOpacityRule[12];

      vec3 rgb2hsv(vec3 c){
        vec4 K=vec4(0.,-1./3.,2./3.,-1.);
        vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));
        vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));
        float d=q.x-min(q.w,q.y);
        return vec3(abs(q.z+(q.w-q.y)/(6.*d+.0001)), d/(q.x+.0001), q.x);
      }
      bool hueIn(float h, float mn, float mx){
        if(mn<=mx) return (h>=mn && h<=mx);
        return (h>=mn || h<=mx);
      }

      float rawMask(vec4 t){
        float a = (t.a > 0.01) ? t.a : dot(t.rgb, vec3(0.2126,0.7152,0.0722));
        return clamp(a, 0.0, 1.0);
      }
      float maskCrisp(float a){
        return smoothstep(uThresh, uThresh + 0.03, a);
      }

      float growOnce(vec2 uv){
        vec2 texel = 1.0 / vec2(textureSize(uMask,0));
        float m = maskCrisp(rawMask(texture2D(uMask, uv)));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2( texel.x, 0.0)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2(-texel.x, 0.0)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2(0.0,  texel.y)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2(0.0, -texel.y)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2( texel.x,  texel.y)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2(-texel.x,  texel.y)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2( texel.x, -texel.y)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2(-texel.x, -texel.y)))));
        return m;
      }

      void main(){
        vec4 t = texture2D(uTex, vUv);

        float a = maskCrisp(rawMask(t));

        
        int N = int(clamp(uWidth, 0.0, 6.0) + 0.5);
        float m = a;

        // Better "thicken lines" sampling: expand radius in texels up to N
        vec2 texel = 1.0 / vec2(textureSize(uMask,0));
        for(int r=1; r<=6; r++){
          if(r > N) break;
          float rr = float(r);
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2( rr*texel.x, 0.0)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2(-rr*texel.x, 0.0)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2(0.0,  rr*texel.y)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2(0.0, -rr*texel.y)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2( rr*texel.x,  rr*texel.y)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2(-rr*texel.x,  rr*texel.y)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2( rr*texel.x, -rr*texel.y)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2(-rr*texel.x, -rr*texel.y)))));
        }

        a = m * uOpacity;

        if(a < 0.002) discard;

        vec3 col = t.rgb;

        if(uMode == 1){
          col = uSingle;
        } else if(uMode == 2){
          vec3 hsv = rgb2hsv(t.rgb);
          float h = hsv.x;
          float s = hsv.y;
          float v = hsv.z;

          bool ok = (s >= uMinSat) && (v >= uMinVal);
          if(ok){
            for(int i=0;i<12;i++){
              if(i >= uRuleCount) break;
              if(hueIn(h, uHueMin[i], uHueMax[i])){
                if(uAction[i] == 1){
                  float k = clamp(uOpacityRule[i], 0.0, 1.0);
                  col = mix(t.rgb, uColor[i], k);
                }
                break;
              }
            }
          }
        }

        gl_FragColor = vec4(col, a);
      }
    `
  });

  syncRulesToShader();
  return overlayShaderMaterial;
}

function syncRulesToShader(){
  if(!overlayShaderMaterial) return;
  const maxRules = 12;
  const rules = (overlayState.rules || []).slice(0, maxRules);

  overlayShaderMaterial.uniforms.uRuleCount.value = rules.length;
  overlayShaderMaterial.uniforms.uMinSat.value = overlayState.minSat;
  overlayShaderMaterial.uniforms.uMinVal.value = overlayState.minVal;

  for(let i=0;i<maxRules;i++){
    if(i < rules.length){
      overlayShaderMaterial.uniforms.uHueMin.value[i] = ((rules[i].hueMin % 360) / 360);
      overlayShaderMaterial.uniforms.uHueMax.value[i] = ((rules[i].hueMax % 360) / 360);
      overlayShaderMaterial.uniforms.uAction.value[i] = (rules[i].action === "recolor") ? 1 : 0;
      overlayShaderMaterial.uniforms.uColor.value[i].set(rules[i].color || "#ffffff");
      overlayShaderMaterial.uniforms.uOpacityRule.value[i] = (rules[i].opacity ?? 1.0);
    }else{
      overlayShaderMaterial.uniforms.uHueMin.value[i] = 0;
      overlayShaderMaterial.uniforms.uHueMax.value[i] = 0;
      overlayShaderMaterial.uniforms.uAction.value[i] = 0;
      overlayShaderMaterial.uniforms.uColor.value[i].set("#ffffff");
      overlayShaderMaterial.uniforms.uOpacityRule.value[i] = 1.0;
    }
  }

  overlayShaderMaterial.uniforms.uMode.value = overlayState.mode;
  overlayShaderMaterial.uniforms.uOpacity.value = overlayState.overlayOpacity;
  overlayShaderMaterial.uniforms.uWidth.value = overlayState.lineWidth;
  overlayShaderMaterial.uniforms.uThresh.value = overlayState.maskThresh;
  overlayShaderMaterial.uniforms.uSingle.value.set(overlayState.singleColor);

  overlayShaderMaterial.needsUpdate = true;
}

function refreshModeUI_Overlay(){
  const modeSel = document.getElementById('modeSel');
  const singleGroup = document.getElementById('singleGroup');
  const rulesGroup = document.getElementById('rulesGroup');
  const m = parseInt(modeSel?.value ?? "0", 10);
  if (singleGroup) singleGroup.style.display = (m === 1) ? "" : "none";
  if (rulesGroup) rulesGroup.style.display  = (m === 2) ? "" : "none";
  overlayState.mode = m;
  if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uMode.value = overlayState.mode;
}

function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;" }[c])); }
function escapeAttr(s){ return escapeHtml(s).replace(/'/g,"&#39;"); }

function hueToHex(h){
  const c = new THREE.Color().setHSL((((h%360)+360)%360)/360, 1, 0.5);
  return "#" + c.getHexString();
}
function clampHue(x){
  const n = Number(x);
  if(!Number.isFinite(n)) return 0;
  return Math.max(0, Math.min(360, Math.round(n)));
}
function pctFromHue(h){ return clampHue(h) / 360; }
function hueFromPct(p){ return clampHue(Math.round(p * 360)); }

function renderRulesUI(){
  const panel = document.getElementById("rulesPanel");
  if (!panel) return;
  panel.innerHTML = "";

  (overlayState.rules || []).forEach((r, idx)=>{
    if(!r.action) r.action = "recolor";
    if(r.opacity == null) r.opacity = 1.0;
    if(r.color == null) r.color = "#ffffff";
    r.hueMin = clampHue(r.hueMin);
    r.hueMax = clampHue(r.hueMax);

    const card = document.createElement("div");
    card.className = "rule";

    card.innerHTML = `
      <div class="ruleHead">
        <b>${escapeHtml(r.name || ("Rule " + (idx+1)))}</b>
        <div class="ruleBtns">
          <span class="mini">#${idx+1}</span>
          <button data-act="up" ${idx===0?"disabled":""}>↑</button>
          <button data-act="down" ${idx===overlayState.rules.length-1?"disabled":""}>↓</button>
          <button data-act="del">Delete</button>
        </div>
      </div>

      <div class="ruleGrid">
        <div class="lbl">Name</div>
        <input data-k="name" type="text" value="${escapeAttr(r.name || "")}" />
        <div class="right"></div>

        <div class="lbl">Hue</div>
        <div>
          <div class="huePicker" data-role="picker" title="Click to jump, drag to adjust">
            <div class="hueTrack"></div>
            <div class="hueHandle" data-role="minHandle" title="Min"></div>
            <div class="hueHandle" data-role="maxHandle" title="Max"></div>
          </div>

          <div class="hueSwatches">
            <div class="hueSwatch" data-role="minSwatch"></div>
            <span class="hueSwatchLabel">min</span>
            <div class="hueSwatch" data-role="maxSwatch"></div>
            <span class="hueSwatchLabel">max</span>
          </div>
          <div class="mini">${r.hueMin > r.hueMax ? "wraps around red" : ""}</div>
        </div>
        <div class="right"></div>

        <div class="lbl">Action</div>
        <div style="display:flex;gap:8px;align-items:center">
          <select data-k="action">
            <option value="recolor" ${r.action==="recolor"?"selected":""}>Recolour</option>
            <option value="original" ${r.action==="original"?"selected":""}>Keep original</option>
          </select>
          <input data-k="color" type="color" value="${escapeAttr(r.color)}" title="Target colour"/>
        </div>
        <div class="right"></div>

        <div class="lbl">Opacity</div>
        <input data-k="opacity" type="range" min="0" max="1" step="0.01" value="${Number(r.opacity ?? 1.0)}" />
        <div class="right"></div>
      </div>
    `;

    card.querySelectorAll("button[data-act]").forEach(btn=>{
      btn.onclick = ()=>{
        const act = btn.getAttribute("data-act");
        if(act==="del"){
          overlayState.rules.splice(idx, 1);
        } else if(act==="up" && idx>0){
          const t=overlayState.rules[idx-1]; overlayState.rules[idx-1]=overlayState.rules[idx]; overlayState.rules[idx]=t;
        } else if(act==="down" && idx<overlayState.rules.length-1){
          const t=overlayState.rules[idx+1]; overlayState.rules[idx+1]=overlayState.rules[idx]; overlayState.rules[idx]=t;
        }
        renderRulesUI();
        syncRulesToShader();
        syncSettingsBox();
      };
    });

    const picker = card.querySelector('[data-role="picker"]');
    const minHandle = card.querySelector('[data-role="minHandle"]');
    const maxHandle = card.querySelector('[data-role="maxHandle"]');
    const minSw = card.querySelector('[data-role="minSwatch"]');
    const maxSw = card.querySelector('[data-role="maxSwatch"]');

    function setActive(which){
      minHandle.classList.toggle("active", which==="min");
      maxHandle.classList.toggle("active", which==="max");
    }
    function updateHueUI(){
      minHandle.style.left = (pctFromHue(r.hueMin)*100) + "%";
      maxHandle.style.left = (pctFromHue(r.hueMax)*100) + "%";
      minSw.style.background = hueToHex(r.hueMin);
      maxSw.style.background = hueToHex(r.hueMax);
    }
    updateHueUI();

    let active = null;
    function pointerPct(e){
      const rect = picker.getBoundingClientRect();
      return Math.min(1, Math.max(0, (e.clientX - rect.left) / rect.width));
    }

    picker.onpointerdown = (e)=>{
      const p = pointerPct(e);
      const dMin = Math.abs(p - pctFromHue(r.hueMin));
      const dMax = Math.abs(p - pctFromHue(r.hueMax));
      active = (dMin <= dMax) ? "min" : "max";

      const h = hueFromPct(p);
      if(active === "min") r.hueMin = h;
      else r.hueMax = h;

      setActive(active);
      updateHueUI();
      syncRulesToShader();
      syncSettingsBox();

      picker.setPointerCapture(e.pointerId);
    };

    picker.onpointermove = (e)=>{
      if(!active) return;
      const h = hueFromPct(pointerPct(e));
      if(active === "min") r.hueMin = h;
      else r.hueMax = h;

      updateHueUI();
      syncRulesToShader();
      syncSettingsBox();
    };

    picker.onpointerup = ()=>{ active=null; setActive(null); };
    picker.onpointerleave = ()=>{ active=null; setActive(null); };

    const colorInp  = card.querySelector('[data-k="color"]');
    const opacityInp= card.querySelector('[data-k="opacity"]');

    function refreshRecolorVisibility(){
      const on = (r.action === "recolor");
      colorInp.style.display = on ? "" : "none";
      opacityInp.disabled = !on;
      opacityInp.style.opacity = on ? "1" : "0.55";
    }
    refreshRecolorVisibility();

    card.querySelectorAll("[data-k]").forEach(inp=>{
      inp.oninput = ()=>{
        const k = inp.getAttribute("data-k");
        if(k === "action"){
          r.action = inp.value;
          refreshRecolorVisibility();
          syncRulesToShader();
          syncSettingsBox();
          return;
        }
        if(k === "color"){
          r.color = inp.value;
        } else if(k === "opacity"){
          r.opacity = Math.max(0, Math.min(1, parseFloat(inp.value)));
        } else {
          r[k] = inp.value;
        }
        syncRulesToShader();
        syncSettingsBox();
      };
    });

    panel.appendChild(card);
  });
}

function refreshPresetList(){
  const presetSel = document.getElementById('presetSel');
  if (!presetSel) return;
  const all = getAllPresets();
  presetSel.innerHTML = "";
  all.forEach((p,i)=>{
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = p.name;
    presetSel.appendChild(opt);
  });
}

async function copyOverlaySettings(){
  const txt = JSON.stringify(getOverlaySettings(), null, 2);
  const box = document.getElementById('settingsBox');
  if (box) box.value = txt;
  try{
    await navigator.clipboard.writeText(txt);
    ovSetStatus("Settings copied ✔");
  }catch{
    ovSetStatus("Copied to box (clipboard blocked) ✔");
  }
}

function exportPNG(){
  // render both scenes in the same order as your app
  try{
    renderer.clear();
    renderer.render(scenePano, camera);
    renderer.clearDepth();
    renderer.render(sceneOverlay, camera);
  }catch(e){
    console.warn("export render fail", e);
  }

  const stamp = new Date().toISOString().replace(/[:.]/g,"-");
  const filename = "todi_overlay_" + stamp + ".png";

  renderer.domElement.toBlob((blob)=>{
    if(!blob){
      const url = renderer.domElement.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
      ovSetStatus("Exported PNG (fallback) ✔\n" + filename);
      return;
    }
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
    ovSetStatus("Exported PNG ✔\n" + filename);
  }, "image/png");
}

function hookOverlayUI(){
  const shared = decodeOverlayFromHash();
  if(shared) applyOverlaySettings(shared);

  const modeSel = document.getElementById('modeSel');
  const toggleOverlay = document.getElementById('toggleOverlay');
  const overlayOpacity = document.getElementById('overlayOpacity');
  const overlayOpacityNum = document.getElementById('overlayOpacityNum');
  const lineWidth = document.getElementById('lineWidth');
  const lineWidthNum = document.getElementById('lineWidthNum');
  const maskThresh = document.getElementById('maskThresh');
  const maskThreshNum = document.getElementById('maskThreshNum');
  const panoFade = document.getElementById('panoFade');
  const panoFadeNum = document.getElementById('panoFadeNum');
  const bgColor = document.getElementById('bgColor');
  const bgOpacity = document.getElementById('bgOpacity');
  const bgOpacityNum = document.getElementById('bgOpacityNum');
  const singleColor = document.getElementById('singleColor');
  const minSat = document.getElementById('minSat');
  const minSatNum = document.getElementById('minSatNum');
  const minVal = document.getElementById('minVal');
  const minValNum = document.getElementById('minValNum');
  const addRuleBtn = document.getElementById('addRuleBtn');

  const exportPngBtn = document.getElementById('exportPngBtn');
  const copySettingsBtn = document.getElementById('copySettingsBtn');
  const shareLinkBtn = document.getElementById('shareLinkBtn');
  const applySettingsBtn = document.getElementById('applySettingsBtn');

  const presetName = document.getElementById('presetName');
  const savePresetBtn = document.getElementById('savePresetBtn');
  const presetSel = document.getElementById('presetSel');
  const loadPresetBtn = document.getElementById('loadPresetBtn');
  const deletePresetBtn = document.getElementById('deletePresetBtn');
  const settingsBox = document.getElementById('settingsBox');

  // collapse
  const collapseBtn = document.getElementById('ovCollapseBtn');
  const panel = document.getElementById('uiOverlay');
  if (collapseBtn && panel){
    collapseBtn.onclick = ()=>{
      panel.classList.toggle('collapsed');
      collapseBtn.textContent = panel.classList.contains('collapsed') ? "Expand" : "Collapse";
    };
  }

  refreshPresetList();
  renderRulesUI();
  refreshModeUI_Overlay();
  syncSettingsBox();

  if (exportPngBtn) exportPngBtn.onclick = exportPNG;
  if (copySettingsBtn) copySettingsBtn.onclick = copyOverlaySettings;
  if (shareLinkBtn) shareLinkBtn.onclick = async ()=>{
    const url = encodeShareLink();
    try{ await navigator.clipboard.writeText(url); ovSetStatus("Share link copied ✔"); }
    catch{ ovSetStatus("Share link set in URL bar (copy it) ✔"); }
  };
  if (applySettingsBtn) applySettingsBtn.onclick = ()=>{
    try{
      const obj = JSON.parse(settingsBox.value);
      applyOverlaySettings(obj);
      ovSetStatus("Settings applied ✔");
    }catch(err){
      ovSetStatus("Invalid JSON:\n" + (err?.message || err));
    }
  };

  if (toggleOverlay) toggleOverlay.onchange = e=>{
    overlayState.showOverlay = e.target.checked;
    if (overlayMesh) overlayMesh.visible = overlayState.showOverlay;
    syncSettingsBox();
  };

  if (modeSel) modeSel.onchange = ()=>{
    refreshModeUI_Overlay();
    syncRulesToShader();
    syncSettingsBox();
  };

  if (singleColor) singleColor.oninput = e=>{
    overlayState.singleColor = e.target.value;
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uSingle.value.set(overlayState.singleColor);
    syncSettingsBox();
  };

  if (overlayOpacity) overlayOpacity.oninput = e=>{
    overlayState.overlayOpacity = parseFloat(e.target.value);
    if (overlayOpacityNum) overlayOpacityNum.value = String(overlayState.overlayOpacity);
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uOpacity.value = overlayState.overlayOpacity;
    syncSettingsBox();
  };

  if (overlayOpacityNum) overlayOpacityNum.oninput = e=>{
    overlayState.overlayOpacity = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    overlayOpacity.value = String(overlayState.overlayOpacity);
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uOpacity.value = overlayState.overlayOpacity;
    syncSettingsBox();
  };

  if (lineWidth) lineWidth.oninput = e=>{
    overlayState.lineWidth = parseFloat(e.target.value);
    if (lineWidthNum) lineWidthNum.value = String(overlayState.lineWidth);
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uWidth.value = overlayState.lineWidth;
    syncSettingsBox();
  };

  if (lineWidthNum) lineWidthNum.oninput = e=>{
    overlayState.lineWidth = Math.max(0, Math.min(6, parseFloat(e.target.value)));
    lineWidth.value = String(overlayState.lineWidth);
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uWidth.value = overlayState.lineWidth;
    syncSettingsBox();
  };

  if (maskThresh) maskThresh.oninput = e=>{
    overlayState.maskThresh = parseFloat(e.target.value);
    if (maskThreshNum) maskThreshNum.value = String(overlayState.maskThresh);
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uThresh.value = overlayState.maskThresh;
    syncSettingsBox();
  };

  if (maskThreshNum) maskThreshNum.oninput = e=>{
    overlayState.maskThresh = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    maskThresh.value = String(overlayState.maskThresh);
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uThresh.value = overlayState.maskThresh;
    syncSettingsBox();
  };

  if (panoFade) panoFade.oninput = e=>{
    overlayState.panoFade = parseFloat(e.target.value);
    if (panoFadeNum) panoFadeNum.value = String(overlayState.panoFade);
    try{
      if (sphereMesh && sphereMesh.material) sphereMesh.material.opacity = overlayState.panoFade;
    }catch{}
    syncSettingsBox();
  };

  if (panoFadeNum) panoFadeNum.oninput = e=>{
    overlayState.panoFade = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    panoFade.value = String(overlayState.panoFade);
    try{ if (sphereMesh && sphereMesh.material) sphereMesh.material.opacity = overlayState.panoFade; }catch{}
    syncSettingsBox();
  };

  if (bgColor) bgColor.oninput = e=>{
    overlayState.bgColor = e.target.value;
    try{
      document.body.style.background = overlayState.bgColor;
      if (renderer && renderer.setClearColor) renderer.setClearColor(new THREE.Color(overlayState.bgColor), (overlayState.bgOpacity ?? 1.0));
    }catch{}
    syncSettingsBox();
  };

  if (bgOpacity) bgOpacity.oninput = e=>{
    overlayState.bgOpacity = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    if (bgOpacityNum) bgOpacityNum.value = String(overlayState.bgOpacity);
    try{ if (renderer && renderer.setClearColor) renderer.setClearColor(new THREE.Color(overlayState.bgColor || '#000'), overlayState.bgOpacity); }catch{}
    syncSettingsBox();
  };
  if (bgOpacityNum) bgOpacityNum.oninput = e=>{
    overlayState.bgOpacity = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    if (bgOpacity) bgOpacity.value = String(overlayState.bgOpacity);
    try{ if (renderer && renderer.setClearColor) renderer.setClearColor(new THREE.Color(overlayState.bgColor || '#000'), overlayState.bgOpacity); }catch{}
    syncSettingsBox();
  };

  if (minSat) minSat.oninput = e=>{
    overlayState.minSat = parseFloat(e.target.value);
    if (minSatNum) minSatNum.value = String(overlayState.minSat);
    syncRulesToShader(); syncSettingsBox();
  };

  if (minSatNum) minSatNum.oninput = e=>{
    overlayState.minSat = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    minSat.value = String(overlayState.minSat);
    syncRulesToShader(); syncSettingsBox();
  };
  if (minVal) minVal.oninput = e=>{
    overlayState.minVal = parseFloat(e.target.value);
    if (minValNum) minValNum.value = String(overlayState.minVal);
    syncRulesToShader(); syncSettingsBox();
  };

  if (minValNum) minValNum.oninput = e=>{
    overlayState.minVal = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    minVal.value = String(overlayState.minVal);
    syncRulesToShader(); syncSettingsBox();
  };

  if (addRuleBtn) addRuleBtn.onclick = ()=>{
    const suggested = ["vegetation","sky","stone"];
    const used = new Set((overlayState.rules||[]).map(x => (x.name||"").toLowerCase()));
    const pick = suggested.find(n => !used.has(n)) || "vegetation";
    const nr = defaultRule();
    nr.name = pick;
    overlayState.rules.push(nr);
    renderRulesUI(); syncRulesToShader(); syncSettingsBox();
    const rp = document.getElementById('rulesPanel');
    if (rp) rp.scrollTop = rp.scrollHeight;
  };

  if (savePresetBtn) savePresetBtn.onclick = ()=>{
    const name = (presetName?.value || "").trim();
    if(!name){ ovSetStatus("Preset needs a name."); return; }
    const list = loadPresetStore();
    list.push({ name, settings: getOverlaySettings() });
    savePresetStore(list);
    refreshPresetList();
    ovSetStatus("Preset saved ✔");
  };

  if (loadPresetBtn) loadPresetBtn.onclick = ()=>{
    const i = parseInt(presetSel?.value ?? "-1",10);
    const list = getAllPresets();
    if(!list[i]){ ovSetStatus("No preset selected."); return; }
    applyOverlaySettings(list[i].settings);
    ovSetStatus("Preset loaded ✔");
  };

  if (deletePresetBtn) deletePresetBtn.onclick = ()=>{
    const i = parseInt(presetSel?.value ?? "-1",10);
    const builtins = BUILTIN_PRESETS.length;
    if(i < builtins){ ovSetStatus("Built-in preset cannot be deleted."); return; }
    const userIndex = i - builtins;
    const user = loadPresetStore();
    if(!user[userIndex]){ ovSetStatus("No user preset selected."); return; }
    user.splice(userIndex, 1);
    savePresetStore(user);
    refreshPresetList();
    ovSetStatus("User preset deleted ✔");
  };
}


function loadOverlayForSource(source){
  return new Promise((resolve)=>{
    try{
      const kind = (document.getElementById('ovType')?.value) || 'edges';
      const p = overlayPathForSource(source, kind);
      if (!p){
        overlayMesh.visible = false;
        resolve(false);
        return;
      }

      // Always load mask alongside colour/edges so threshold + width operate on a stable mask.
      const maskKind = (document.getElementById('maskKindSel')?.value) || 'edges_mask';
      const pMask = overlayPathForSource(source, maskKind);

      const loaderA = new THREE.TextureLoader();
      const loaderB = new THREE.TextureLoader();

      let texA = null, texM = null;
      let done = 0;
      function finish(){
        done++;
        if(done < 2) return;

        if(!texA){
          overlayMesh.visible = false;
          ovSetStatus("Overlay load failed:\n" + p);
          resolve(false);
          return;
        }

        overlayMesh.material = buildOverlayMaterial(texA, texM || texA);
        overlayMesh.material.needsUpdate = true;
        overlayMesh.visible = !!overlayState.showOverlay;

        syncRulesToShader();
        ovSetStatus("Overlay loaded ✔\n" + p + (texM ? "\n(mask ✔)" : "\n(mask missing)"));

        resolve(true);
      }

      loaderA.load(
        p,
        (tex)=>{
          tex.colorSpace = THREE.SRGBColorSpace;
          tex.needsUpdate = true;
          if (overlayTexture) overlayTexture.dispose();
          overlayTexture = tex;
          texA = tex;
          finish();
        },
        undefined,
        (err)=>{
          console.warn('Overlay load failed:', p, err);
          texA = null;
          finish();
        }
      );

      loaderB.load(
        pMask,
        (tex)=>{
          tex.colorSpace = THREE.SRGBColorSpace;
          tex.needsUpdate = true;
          texM = tex;
          finish();
        },
        undefined,
        (err)=>{
          console.warn('Mask load failed (continuing):', pMask, err);
          texM = null;
          finish();
        }
      );

    }catch(e){
      console.warn('Overlay load error', e);
      overlayMesh.visible = false;
      ovSetStatus("Overlay load error.");
      resolve(false);
    }
  });
}




// --------------------
// Navigation
// --------------------
async function setSourceByIndex(idx){
  idx = clamp(idx, 0, SOURCES.length-1);
  currentIndex = idx;
  { const sel=document.getElementById('sourceSelect'); if (sel) sel.value=String(currentIndex); }
const s=currentSource();
  if (!s) return;

  await loadPanoImage(s);

  await loadOverlayForSource(s);

  
  loadSkyMaskForSource(s);
yaw = 0; pitch = 0; animating = false;

  rebuildMarkersAndList();
}

function nextSource(){ setSourceByIndex(currentIndex+1); }
function prevSource(){ setSourceByIndex(currentIndex-1); }

// --------------------
// Mouse reticle + mouse snap placement
// --------------------
function showReticle(show){
  reticleWrap.style.display = show ? 'block' : 'none';
}
function reticleEnabled(){
  const v = placeModeSel.value;
  return v === 'mouse' || v === 'both';
}
function arrowsEnabled(){
  const v = placeModeSel.value;
  return v === 'arrows' || v === 'both';
}

function setReticleAt(clientX, clientY){
  reticleWrap.style.left = clientX + 'px';
  reticleWrap.style.top  = clientY + 'px';
}

function updateReticleReadout(){
  // show camera yaw/pitch under cursor (same as camera forward direction; actual snap uses cursor ray)
  // We'll update dynamically from cursor ray when moving.
}

function snapCandidateToMouse(){
  // Applies a per-point yaw/pitch adjustment so the selected candidate lands under the cursor ray.
  const s=currentSource();
  if (!s) return false;

  if (!selected || selected.userData?.idx < 0){
    setStatus('⚠ Select a point first, then use mouse snap.');
    return false;
  }
  if (adjustModeSel.value !== 'point'){
    setStatus('ℹ Mouse snap writes to Selected point offsets. Switch Adjust mode → Selected point.');
    return false;
  }

  // Get current cursor ray -> direction in world
  raycaster.setFromCamera(mouse, camera);
  const rayDir = raycaster.ray.direction.clone().normalize();
  const target = dirToYawPitchDeg(rayDir);

  const ck = selected.userData.candKey;
  const c  = selected.userData.cand;

  const baseRel  = Number(c.rel_bear ?? 0);
  const baseElev = Number(c.elev_ang_d ?? 0);
  const dist     = getCandidateDistanceM(c);

  const offYaw = getOffsetDeg(s.id);
  const offZ_m = getZOffsetM(s.id);

  // Desired final yaw/pitch (what the user clicked on)
  const desiredYawDeg = target.yawDeg;
  const desiredPitchDeg = clamp(target.pitchDeg, -MAX_PITCH_DEG, MAX_PITCH_DEG);

  // We solve for point yaw so that:
  // yawFinal = norm360(baseRel - offYaw - pointYaw)  =>  pointYaw = baseRel - offYaw - yawFinal
  const newPointYaw = (baseRel - offYaw - desiredYawDeg);

  // For pitch: pitchFinal = baseElev + zDeg(globalZ) + zDeg(pointZ) + pointPitch
  // We'll keep pointZ as-is, and solve pointPitch to match desiredPitch
  const existing = getPointAdj(s.id, ck);
  const zGlobalDeg = zMetersToDeg(offZ_m, dist);
  const zPointDeg  = zMetersToDeg((existing.z||0), dist);
  const newPointPitch = desiredPitchDeg - (baseElev + zGlobalDeg + zPointDeg);

  setPointAdj(s.id, ck, {
    yaw: newPointYaw,
    pitch: newPointPitch,
    z: existing.z || 0
  });

  // rebuild and restore selection
  const keepKey = ck;
  rebuildMarkersAndList();
  const match = currentMarkers.find(m=>m.userData?.candKey === keepKey);
  if (match){
    setSelected(match);
  }

  setStatus(`✅ Mouse snapped: ${keepKey}`);

  // Auto-advance if enabled
  if (autoNextIn.checked){
    advanceToNextCandidate();
  }

  return true;
}

function advanceToNextCandidate(){
  if (!selected || selected.userData?.idx == null) return;
  const idx = selected.userData.idx;
  const nextIdx = idx + 1;

  if (nextIdx >= currentMarkers.length){
    setStatus('ℹ Reached end of candidate list.');
    return;
  }
  const m = currentMarkers[nextIdx];
  if (!m) return;

  setSelected(m);
  setViewYawPitch(
    THREE.MathUtils.degToRad(m.userData.yawDeg),
    THREE.MathUtils.degToRad(m.userData.pitchDeg),
    true
  );
}

// --------------------
// Pointer events
// --------------------
renderer.domElement.addEventListener('pointerdown', (e)=>{
  dragging=true; lastX=e.clientX; lastY=e.clientY;
  renderer.domElement.setPointerCapture(e.pointerId);
});

renderer.domElement.addEventListener('pointerup', (e)=>{
  dragging=false;
  try { renderer.domElement.releasePointerCapture(e.pointerId); } catch {}
});

renderer.domElement.addEventListener('pointermove', (e)=>{
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);

  doHover(e.clientX, e.clientY);

  // Reticle follows cursor when enabled and a valid point is selected
  const show = reticleEnabled() && !!selected && selected.userData?.idx >= 0;
  showReticle(show);
  if (show){
    setReticleAt(e.clientX, e.clientY);

    // update live cursor yaw/pitch (ray direction)
    raycaster.setFromCamera(mouse, camera);
    const d = raycaster.ray.direction.clone().normalize();
    const yp = dirToYawPitchDeg(d);
    reticleA.textContent = `yaw ${fmt(yp.yawDeg,1)}°`;
    reticleB.textContent = `pitch ${fmt(yp.pitchDeg,1)}°`;
  }

  // drag to rotate camera (always)
  if (!dragging) return;
  const dx=e.clientX-lastX;
  const dy=e.clientY-lastY;
  lastX=e.clientX; lastY=e.clientY;

  const s=0.0032;
  yaw   -= dx*s;
  pitch -= dy*s;
  animating=false;
});

// Click behaviour:
// - if mouse snap enabled and point selected: left click snaps
// - else click selects marker (existing behaviour)
renderer.domElement.addEventListener('click', (e)=>{
  // if in mouse snap mode, snap selected to cursor regardless of marker hit
  if (reticleEnabled() && selected && selected.userData?.idx >= 0 && adjustModeSel.value === 'point'){
    // only trigger if user isn't clicking UI
    const uiRect = document.getElementById('ui').getBoundingClientRect();
    const inUI = (e.clientX >= uiRect.left && e.clientX <= uiRect.right && e.clientY >= uiRect.top && e.clientY <= uiRect.bottom);
    if (!inUI){
      snapCandidateToMouse();
      return;
    }
  }

  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(markerGroup.children, true);
  if (!hits.length) return;

  const root = markerRootFromObject(hits[0].object);
  if (!root) return;

  if (root.userData.idx === -1) {
    setViewYawPitch(0,0,true);
    return;
  }

  setSelected(root);
  setViewYawPitch(
    THREE.MathUtils.degToRad(root.userData.yawDeg),
    THREE.MathUtils.degToRad(root.userData.pitchDeg),
    true
  );
});

renderer.domElement.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const f=clamp(camera.fov + (e.deltaY*0.02), 35, 95);
  camera.fov=f;
  camera.updateProjectionMatrix();
}, { passive:false });

// --------------------
// UI events
// --------------------
prevBtn && prevBtn.addEventListener('click', prevSource);
nextBtn && nextBtn.addEventListener('click', nextSource);

sourceSelect && sourceSelect.addEventListener('change', ()=>{
  const idx=parseInt((document.getElementById('sourceSelect')?.value),10);
  if (Number.isFinite(idx)) setSourceByIndex(idx);
});

// filters rebuild
function rebuildFromFilters(){
  rebuildMarkersAndList();
}
visFilterSel.addEventListener('change', rebuildFromFilters);
categoryFilterSel.addEventListener('change', rebuildFromFilters);
landmarkFilterSel.addEventListener('change', rebuildFromFilters);
minVis.addEventListener('change', rebuildFromFilters);
topN.addEventListener('change', rebuildFromFilters);
mWorld.addEventListener('change', rebuildFromFilters);
debugDotIn.addEventListener('change', rebuildFromFilters);

distMaxIn.addEventListener('input', ()=>{
  distMaxLabel.textContent = `≤ ${distMaxIn.value}m`;
  rebuildFromFilters();
});
distMaxLabel.textContent = `≤ ${distMaxIn.value}m`;

function applyExposure(){
  const v=parseFloat(exposureIn.value);
  renderer.toneMappingExposure = Number.isFinite(v) ? clamp(v,0.6,1.6) : 1.0;
}
exposureIn.addEventListener('input', applyExposure);
applyExposure();

// If mouse snap is selected, force adjustMode to point (because snap writes per-point)
placeModeSel.addEventListener('change', ()=>{
  const needsPoint = reticleEnabled();
  if (needsPoint && adjustModeSel.value !== 'point'){
    adjustModeSel.value = 'point';
    setStatus('ℹ Mouse snap enabled → Adjust mode set to Selected point.');
  }
  showReticle(reticleEnabled() && !!selected && selected.userData?.idx >= 0);
});

// --------------------
// Nudge + reset controls
// --------------------
function getYawStepDeg(){
  const v = parseFloat(yawStepPresetSel.value);
  return Number.isFinite(v) ? v : 1;
}
function getZStepM(){
  const v = parseFloat(zStepPresetSel.value);
  return Number.isFinite(v) ? v : 0.5;
}

function getSelectedOrWarn(){
  if (!selected || !selected.userData || selected.userData.idx < 0) {
    setStatus('⚠ Select a point first to adjust per-point offsets.');
    return null;
  }
  return selected;
}

function restoreSelectionByKey(sk){
  if (!sk) return;
  const match = currentMarkers.find(m=>m.userData?.candKey === sk);
  if (match){
    setSelected(match);
    setViewYawPitch(
      THREE.MathUtils.degToRad(match.userData.yawDeg),
      THREE.MathUtils.degToRad(match.userData.pitchDeg),
      true
    );
  }
}

function updateSelectedAfterAdjust(){
  const sk = selected?.userData?.candKey;
  rebuildMarkersAndList();
  restoreSelectionByKey(sk);
}

function nudgeYaw(deltaDeg){
  const s=currentSource();
  if (!s) return;

  const mode = adjustModeSel.value;
  if (mode === 'global'){
    const cur=getOffsetDeg(s.id);
    setOffsetDeg(s.id, cur + deltaDeg);
    updateSelectedAfterAdjust();
    return;
  }

  const sel = getSelectedOrWarn();
  if (!sel) return;

  const ck = sel.userData.candKey;
  const adj = getPointAdj(s.id, ck);
  adj.yaw = (adj.yaw || 0) + deltaDeg;
  setPointAdj(s.id, ck, adj);
  updateSelectedAfterAdjust();
}

function nudgePitch(deltaDeg){
  const s=currentSource();
  if (!s) return;

  const mode = adjustModeSel.value;
  if (mode === 'global'){
    setStatus('ℹ Global pitch not enabled. Use Z (global) or Selected point pitch.');
    return;
  }

  const sel = getSelectedOrWarn();
  if (!sel) return;

  const ck = sel.userData.candKey;
  const adj = getPointAdj(s.id, ck);
  adj.pitch = (adj.pitch || 0) + deltaDeg;
  setPointAdj(s.id, ck, adj);
  updateSelectedAfterAdjust();
}

function nudgeZ(deltaM){
  const s=currentSource();
  if (!s) return;

  const mode = adjustModeSel.value;
  if (mode === 'global'){
    const cur=getZOffsetM(s.id);
    setZOffsetM(s.id, cur + deltaM);
    updateSelectedAfterAdjust();
    return;
  }

  const sel = getSelectedOrWarn();
  if (!sel) return;

  const ck = sel.userData.candKey;
  const adj = getPointAdj(s.id, ck);
  adj.z = (adj.z || 0) + deltaM;
  setPointAdj(s.id, ck, adj);
  updateSelectedAfterAdjust();
}

// Arrows remain usable depending on place mode
nudgeLeft.addEventListener('click', ()=>{
  if (!arrowsEnabled()) return;
  const step = getYawStepDeg();
  nudgeYaw(+step);
});
nudgeRight.addEventListener('click', ()=>{
  if (!arrowsEnabled()) return;
  const step = getYawStepDeg();
  nudgeYaw(-step);
});
nudgeUp.addEventListener('click', ()=>{
  if (!arrowsEnabled()) return;
  const step = parseFloat(pitchStepIn.value) || 0.25;
  nudgePitch(+step);
});
nudgeDown.addEventListener('click', ()=>{
  if (!arrowsEnabled()) return;
  const step = parseFloat(pitchStepIn.value) || 0.25;
  nudgePitch(-step);
});

zUp.addEventListener('click', ()=>{
  if (!arrowsEnabled()) return;
  const step = getZStepM();
  nudgeZ(+step);
});
zDown.addEventListener('click', ()=>{
  if (!arrowsEnabled()) return;
  const step = getZStepM();
  nudgeZ(-step);
});

resetAdjBtn.addEventListener('click', ()=>{
  const s=currentSource();
  if (!s) return;

  const mode = adjustModeSel.value;
  if (mode === 'global'){
    setOffsetDeg(s.id, 0);
    updateSelectedAfterAdjust();
    setStatus(`✅ Reset GLOBAL yaw offset for ${s.id}`);
    return;
  }

  const sel = getSelectedOrWarn();
  if (!sel) return;
  resetPointAdj(s.id, sel.userData.candKey);
  updateSelectedAfterAdjust();
  setStatus(`✅ Reset POINT yaw/pitch/z for ${sel.userData.candKey}`);
});

zZero.addEventListener('click', ()=>{
  const s=currentSource();
  if (!s) return;

  const mode = adjustModeSel.value;
  if (mode === 'global'){
    setZOffsetM(s.id, 0);
    updateSelectedAfterAdjust();
    setStatus(`✅ Reset GLOBAL Z offset for ${s.id}`);
    return;
  }

  const sel = getSelectedOrWarn();
  if (!sel) return;
  const adj = getPointAdj(s.id, sel.userData.candKey);
  adj.z = 0;
  setPointAdj(s.id, sel.userData.candKey, adj);
  updateSelectedAfterAdjust();
  setStatus(`✅ Reset POINT Z for ${sel.userData.candKey}`);
});

// --------------------
// Export / Import offsets
// --------------------
function buildExportObject(){
  const out = {
    meta: {
      created_local: new Date().toISOString(),
      origin: location.origin,
      notes: "Global yaw offset degrees + global Z offset meters per pano; per-point yaw/pitch deg + z meters per pano+candidate. Exported from localStorage."
    },
    global: {},
    points: {},
    counts: { global_panos: 0, point_entries: 0 }
  };

  // --- globals from current SOURCES (ensures all panos included even if unset)
  for (const s of SOURCES){
    out.global[s.id] = {
      yaw_offset_deg: getOffsetDeg(s.id),
      z_offset_m: getZOffsetM(s.id)
    };
  }
  out.counts.global_panos = Object.keys(out.global).length;

  // --- points: FIXED parsing for key format:
  // todi_point_adj__SRCID__CANDKEY   (3 parts when split on "__")
  let parsed = 0;

  for (let i=0; i<localStorage.length; i++){
    const k = localStorage.key(i);
    if (!k || !k.startsWith("todi_point_adj__")) continue;

    const parts = k.split("__");  // ["todi_point_adj", "TPANO_52", "landmark:LMID_028"]
    if (parts.length < 3) continue;

    const srcId = parts[1];
    const candKey = parts.slice(2).join("__");

    const raw = localStorage.getItem(k);
    if (!raw) continue;

    try{
      const j = JSON.parse(raw);
      if (!j || typeof j !== "object") continue;

      out.points[srcId] ??= {};
      out.points[srcId][candKey] = {
        yaw:   Number(j.yaw ?? 0),
        pitch: Number(j.pitch ?? 0),
        z:     Number(j.z ?? 0)
      };
      parsed++;
    } catch {
      // ignore invalid point record
    }
  }

  out.counts.point_entries = parsed;
  return out;
}


exportOffsetsBtn.addEventListener('click', ()=> {
  const out = buildExportObject();

  const blob = new Blob([JSON.stringify(out, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = 'todi_offsets_export_withpoints.json';
  document.body.appendChild(a);
  a.click();
  a.remove();

  URL.revokeObjectURL(url);

  const globalPanos  = out.counts?.global_panos ?? Object.keys(out.global).length;
  const pointPanos   = Object.keys(out.points).length;
  const pointEntries = out.counts?.point_entries ?? 0;

  console.log(
    "✅ Exported offsets",
    "| global panos:", globalPanos,
    "| point panos:", pointPanos,
    "| point entries:", pointEntries
  );

  setStatus(
    `✅ Exported offsets: todi_offsets_export_withpoints.json | global: ${globalPanos} | point panos: ${pointPanos} | point entries: ${pointEntries}`
  );
});

importOffsetsIn.addEventListener('change', async ()=> {
  const file = importOffsetsIn.files?.[0];
  if (!file) return;

  try {
    const txt = await file.text();
    const j = JSON.parse(txt);

    // globals
    if (j.global && typeof j.global === 'object'){
      for (const [srcId, v] of Object.entries(j.global)){
        if (!v || typeof v !== 'object') continue;
        if (v.yaw_offset_deg != null) setOffsetDeg(srcId, Number(v.yaw_offset_deg) || 0);
        if (v.z_offset_m != null)     setZOffsetM(srcId, Number(v.z_offset_m) || 0);
      }
    }

    // points
    let importedPointEntries = 0;
    let importedPointPanos = 0;

    if (j.points && typeof j.points === 'object'){
      for (const [srcId, mp] of Object.entries(j.points)){
        if (!mp || typeof mp !== 'object') continue;
        importedPointPanos++;

        for (const [candKey, v] of Object.entries(mp)){
          if (!v || typeof v !== 'object') continue;

          setPointAdj(srcId, candKey, {
            yaw:   Number(v.yaw)   || 0,
            pitch: Number(v.pitch) || 0,
            z:     Number(v.z)     || 0
          });

          importedPointEntries++;
        }
      }
    }

    rebuildMarkersAndList();

    const importedGlobals = (j.global && typeof j.global === 'object') ? Object.keys(j.global).length : 0;
    console.log(
      "✅ Imported offsets",
      "| globals:", importedGlobals,
      "| point panos:", importedPointPanos,
      "| point entries:", importedPointEntries
    );

    setStatus(
      `✅ Imported offsets: ${file.name} | globals: ${importedGlobals} | point panos: ${importedPointPanos} | point entries: ${importedPointEntries}`
    );
  } catch (e){
    console.error(e);
    setStatus(`❌ Import failed: ${e.message}`);
  } finally {
    importOffsetsIn.value = '';
  }
});


// --------------------
// Resize
// --------------------
window.addEventListener('resize', ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});

// --------------------
// Init
// --------------------
function computeMaxDistanceFromData(){
  // set distance slider to max present for current source (default max)
  const s = currentSource();
  if (!s) return 2000;
  let maxD = 0;
  for (const c of (s.candidates||[])){
    const d = getCandidateDistanceM(c);
    if (Number.isFinite(d)) maxD = Math.max(maxD, d);
  }
  return Math.min(2000, Math.ceil(maxD));
}




// ================= Marker FX (wired to currentMarkers from verifier) =================
let markerFxMode = "loading";
let markerFxCfg = {
  helixColor: "#7efcff",
  ringColor:  "#b6ff6a",
  birdColor:  "#ffffff",
  speed: 1.0,
  dir: "cw",
  topY: 55,
  botY: -55,
  radius: 18,
  turns: 5.0,
  jitter: 2.2,
  flock: 0.35
};

function _fxColor(hex){ try{ return new THREE.Color(hex); }catch{ return new THREE.Color("#fff"); } }

function _mkPointsMaterial(hex, size, opacity=0.92){
  return new THREE.PointsMaterial({
    color: _fxColor(hex),
    size,
    transparent:true,
    opacity,
    depthWrite:false,
    depthTest:false
  });
}

function _fxDispose(group){
  try{
    group.traverse(o=>{
      o.geometry?.dispose?.();
      o.material?.dispose?.();
    });
  }catch{}
}

function _getVerifierMarkers(){
  try{
    if(typeof currentMarkers !== "undefined" && Array.isArray(currentMarkers)) return currentMarkers;
  }catch{}
  return [];
}

// --- noise helpers (cheap "murmuration" feel) ---
function _hash1(i){
  const x = Math.sin(i*127.1 + 311.7)*43758.5453;
  return x - Math.floor(x);
}
function _noise3(x,y,z){
  // cheap smooth-ish noise via sines
  return Math.sin(x*1.7 + Math.sin(y*1.3) + z*0.9);
}
function _flowVec(x,y,z,t){
  // pseudo curl-ish field (not true curl, but looks like swirly starlings)
  const nx = _noise3(x*0.12 + t*0.35, y*0.10, z*0.11);
  const ny = _noise3(x*0.10, y*0.12 + t*0.33, z*0.09);
  const nz = _noise3(x*0.11, y*0.09, z*0.12 + t*0.31);
  return new THREE.Vector3(nx, ny, nz);
}

// --- FX builders ---
function buildHelixFX(){
  const g = new THREE.Group();

  const N = 820; // denser for murmuration feel
  const pos = new Float32Array(N*3);
  const base = new Float32Array(N*3);
  const phase = new Float32Array(N);

  const topY = markerFxCfg.topY;
  const botY = markerFxCfg.botY;
  const height = (topY - botY);
  const radius0 = markerFxCfg.radius;
  const turns = markerFxCfg.turns;

  for(let i=0;i<N;i++){
    const t = i/(N-1);
    const ang = t * Math.PI * 2.0 * turns;
    const r = radius0 * (1.0 - 0.35*t);

    const x = Math.cos(ang)*r;
    const y = botY + t*height;
    const z = Math.sin(ang)*r;

    pos[i*3+0]=x; pos[i*3+1]=y; pos[i*3+2]=z;
    base[i*3+0]=x; base[i*3+1]=y; base[i*3+2]=z;
    phase[i]=_hash1(i)*Math.PI*2.0;
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.BufferAttribute(pos,3));
  geo.setAttribute("base", new THREE.BufferAttribute(base,3));
  geo.setAttribute("phase", new THREE.BufferAttribute(phase,1));

  const helix = new THREE.Points(geo, _mkPointsMaterial(markerFxCfg.helixColor, 1.15, 0.9));
  helix.userData.kind="helix";
  g.add(helix);

  // ground ring (3/4 circle)
  const M = 320;
  const pos2 = new Float32Array(M*3);
  const base2 = new Float32Array(M*3);
  const phase2= new Float32Array(M);
  for(let i=0;i<M;i++){
    const a = (i/(M-1)) * (Math.PI*1.5);
    const R = radius0 * 1.15;
    const x = Math.cos(a)*R;
    const y = botY;
    const z = Math.sin(a)*R;
    pos2[i*3+0]=x; pos2[i*3+1]=y; pos2[i*3+2]=z;
    base2[i*3+0]=x; base2[i*3+1]=y; base2[i*3+2]=z;
    phase2[i]=_hash1(1000+i)*Math.PI*2.0;
  }
  const geo2 = new THREE.BufferGeometry();
  geo2.setAttribute("position", new THREE.BufferAttribute(pos2,3));
  geo2.setAttribute("base", new THREE.BufferAttribute(base2,3));
  geo2.setAttribute("phase", new THREE.BufferAttribute(phase2,1));
  const ring = new THREE.Points(geo2, _mkPointsMaterial(markerFxCfg.ringColor, 1.6, 0.85));
  ring.userData.kind="ring";
  g.add(ring);

  // halo near top (kept as separate option)
  const B = 360;
  const pos3 = new Float32Array(B*3);
  const base3= new Float32Array(B*3);
  const phase3=new Float32Array(B);
  for(let i=0;i<B;i++){
    const a = _hash1(2000+i)*Math.PI*2;
    const r = (radius0*0.55) + _hash1(3000+i)*(radius0*0.25);
    const x = Math.cos(a)*r;
    const y = topY + (_hash1(4000+i)-0.5)*10;
    const z = Math.sin(a)*r;
    pos3[i*3+0]=x; pos3[i*3+1]=y; pos3[i*3+2]=z;
    base3[i*3+0]=x; base3[i*3+1]=y; base3[i*3+2]=z;
    phase3[i]=_hash1(5000+i)*Math.PI*2.0;
  }
  const geo3 = new THREE.BufferGeometry();
  geo3.setAttribute("position", new THREE.BufferAttribute(pos3,3));
  geo3.setAttribute("base", new THREE.BufferAttribute(base3,3));
  geo3.setAttribute("phase", new THREE.BufferAttribute(phase3,1));
  const halo = new THREE.Points(geo3, _mkPointsMaterial(markerFxCfg.birdColor, 1.35, 0.9));
  halo.userData.kind="halo";
  g.add(halo);

  // bird-shape point cloud (simple stylised 3D silhouette)
  const S = 520;
  const pos4 = new Float32Array(S*3);
  const base4= new Float32Array(S*3);
  const phase4=new Float32Array(S);
  for(let i=0;i<S;i++){
    // sample a stylised bird with two wings + body; z adds thickness
    const u = _hash1(6000+i)*2 - 1;     // -1..1 across wings
    const v = _hash1(7000+i)*2 - 1;     // -1..1 along body
    const wing = 1.0 - Math.abs(v);     // taper
    const wingCurve = 0.35*Math.sin(v*Math.PI); // camber
    let x = u * (radius0*0.65) * (0.25 + 0.75*wing);
    let y = wingCurve * (radius0*0.22) + (topY + 12) + v*(radius0*0.18);
    let z = ( _hash1(8000+i)-0.5 ) * (radius0*0.20);

    // body bias near center
    const bodyMask = Math.exp(-Math.abs(u)*3.2);
    y += bodyMask * (radius0*0.10);
    x *= (0.55 + 0.45*(1-bodyMask));

    pos4[i*3+0]=x; pos4[i*3+1]=y; pos4[i*3+2]=z;
    base4[i*3+0]=x; base4[i*3+1]=y; base4[i*3+2]=z;
    phase4[i]=_hash1(9000+i)*Math.PI*2.0;
  }
  const geo4 = new THREE.BufferGeometry();
  geo4.setAttribute("position", new THREE.BufferAttribute(pos4,3));
  geo4.setAttribute("base", new THREE.BufferAttribute(base4,3));
  geo4.setAttribute("phase", new THREE.BufferAttribute(phase4,1));
  const birdshape = new THREE.Points(geo4, _mkPointsMaterial(markerFxCfg.birdColor, 1.2, 0.95));
  birdshape.userData.kind="birdshape";
  g.add(birdshape);

  g.userData.t = 0;
  return g;
}

function _setVisibleByMode(fx){
  if(!fx) return;
  fx.traverse(o=>{
    if(!o.isPoints) return;
    const k = o.userData.kind;
    if(markerFxMode === "helix")      o.visible = (k==="helix");
    else if(markerFxMode === "ring")  o.visible = (k==="ring");
    else if(markerFxMode === "halo")  o.visible = (k==="halo");
    else if(markerFxMode === "birdshape") o.visible = (k==="birdshape");
    else if(markerFxMode === "combo") o.visible = (k==="helix"||k==="ring"||k==="halo");
    else o.visible = false;
  });
}

function applyMarkerFxToMarker(m){
  if(!m) return;
  m.userData ||= {};

  // clear existing
  if(m.userData.fxGroup){
    m.remove(m.userData.fxGroup);
    _fxDispose(m.userData.fxGroup);
    m.userData.fxGroup = null;
  }

  if(markerFxMode === "hover" || markerFxMode === "loading"){
    return; // nothing additive
  }

  const fx = buildHelixFX();
  _setVisibleByMode(fx);
  m.add(fx);
  m.userData.fxGroup = fx;
    try{ fx.traverse(o=>{ if(o.isPoints) forceTopLayer(o,2000); }); }catch(e){}
}

function updateMarkerFx(dt){
  const list = _getVerifierMarkers();
  if(!list.length) return;

  for(const m of list){
    // Iterate through fxGroups array (modular system stores multiple FX per marker)
    const fxGroups = m?.userData?.fxGroups;
    if(!fxGroups || !Array.isArray(fxGroups)) continue;
    
    fxGroups.forEach(fx => {
      if(!fx) return;
      
      // Use per-marker config if available, otherwise fall back to global
      const cfg = fx.userData.markerConfig || {
        speed: markerFxCfg.speed || 1.0,
        direction: markerFxCfg.dir,
        jitter: markerFxCfg.jitter,
        flockiness: markerFxCfg.flock,
        color: markerFxCfg.helixColor
      };
      
      const dir = (cfg.direction === "ccw") ? -1 : 1;
      const sp  = cfg.speed || 1.0;
      
      fx.userData.t = (fx.userData.t || 0) + dt * sp;
      const t = fx.userData.t;

      // rotate whole group gently
      fx.rotation.y = dir * t * 0.85;

      fx.traverse(o=>{
        if(!o.isPoints) return;

        // update colors live - use per-marker color
        const color = cfg.color || markerFxCfg.helixColor;
        if(o.userData.kind==="helix") o.material.color.set(_fxColor(color));
        if(o.userData.kind==="ring")  o.material.color.set(_fxColor(color));
        if(o.userData.kind==="halo" || o.userData.kind==="birdshape") o.material.color.set(_fxColor(color));

        // murmuration-like jitter
        const geo = o.geometry;
        const pos = geo.getAttribute("position");
        const base= geo.getAttribute("base");
        const ph  = geo.getAttribute("phase");
        if(!pos || !base || !ph) return;

        const jit = cfg.jitter;
        const flock = cfg.flockiness;

        for(let i=0;i<pos.count;i++){
          const bx = base.getX(i), by = base.getY(i), bz = base.getZ(i);
          const p = ph.getX(i);

          // flow field
          const fv = _flowVec(bx, by, bz, t + p);
          const w = (0.65 + 0.35*Math.sin(t*1.3 + p));

          // "flockiness" nudges toward a few moving centroids
          const cx = Math.sin(t*0.6)*8;
          const cy = Math.cos(t*0.7)*6;
          const cz = Math.sin(t*0.5)*7;

          const nx = bx + fv.x*jit*w + (cx - bx)*flock*0.02;
          const ny = by + fv.y*jit*w + (cy - by)*flock*0.02;
          const nz = bz + fv.z*jit*w + (cz - bz)*flock*0.02;

          pos.setXYZ(i, nx, ny, nz);
        }
        pos.needsUpdate = true;
      });
    });
  }
}

// ================= MODULAR MARKER SYSTEM =================

// Active marker configurations
let activeMarkers = [];

// Marker type definitions with default properties
const markerTypeDefaults = {
  helix: {
    name: "Helix (Starlings)",
    topY: 50,
    bottomY: 0,
    speed: 1.0,
    direction: "cw",
    colorMode: "single",
    color: "#7efcff",
    categoryColors: {
      Landmark: "#ff6b6b",
      Leisure: "#4ecdc4",
      Place: "#f38181",
      Amenity: "#aa96da"
    },
    visibilityColors: { high: "#00ff00", medium: "#ffff00", low: "#ff0000" },
    radius: 18,
    jitter: 2.2,
    flockiness: 0.35,
    turns: 5.0
  },
  bird: {
    name: "Bird Halo",
    topY: 55,
    bottomY: -10,
    speed: 1.5,
    direction: "ccw",
    colorMode: "single",
    color: "#ffffff",
    categoryColors: {
      Landmark: "#ff6b6b",
      Leisure: "#4ecdc4",
      Place: "#f38181",
      Amenity: "#aa96da"
    },
    visibilityColors: { high: "#00ff00", medium: "#ffff00", low: "#ff0000" },
    radius: 15,
    jitter: 1.8,
    flockiness: 0.5
  },
  ground: {
    name: "Ground Ring",
    topY: 5,
    bottomY: 0,
    speed: 2.0,
    direction: "cw",
    colorMode: "single",
    color: "#b6ff6a",
    categoryColors: {
      Landmark: "#ff6b6b",
      Leisure: "#4ecdc4",
      Place: "#f38181",
      Amenity: "#aa96da"
    },
    visibilityColors: { high: "#00ff00", medium: "#ffff00", low: "#ff0000" },
    radius: 20,
    thickness: 2
  },
  birdshape: {
    name: "Bird Shape",
    topY: 60,
    bottomY: 0,
    speed: 1.2,
    direction: "cw",
    colorMode: "single",
    color: "#ffffff",
    categoryColors: {
      Landmark: "#ff6b6b",
      Leisure: "#4ecdc4",
      Place: "#f38181",
      Amenity: "#aa96da"
    },
    visibilityColors: { high: "#00ff00", medium: "#ffff00", low: "#ff0000" },
    radius: 12,
    jitter: 2.5,
    flockiness: 0.6
  },
  loading: {
    name: "Loading Rings",
    topY: 40,
    bottomY: -40,
    speed: 1.5,
    direction: "cw",
    colorMode: "single",
    color: "#00c8ff",
    categoryColors: {
      Landmark: "#ff6b6b",
      Leisure: "#4ecdc4",
      Place: "#f38181",
      Amenity: "#aa96da"
    },
    visibilityColors: { high: "#00ff00", medium: "#ffff00", low: "#ff0000" },
    radius: 18
  },
  x: {
    name: "X Marker",
    colorMode: "category",
    color: "#ffffff",
    categoryColors: {
      landmark: "#ff6b6b",
      leisure: "#4ecdc4",
      place: "#f38181",
      amenity: "#aa96da"
    },
    visibilityColors: { high: "#00ff00", medium: "#ffff00", low: "#ff0000" },
    size: 18
  }
};

// Add new marker
let markerIdCounter = 0;
function addMarkerFX(type) {
  const id = `marker_${markerIdCounter++}`;
  const config = {
    id,
    type,
    ...JSON.parse(JSON.stringify(markerTypeDefaults[type]))
  };
  activeMarkers.push(config);
  renderMarkerFXList();
  applyAllMarkerFX();
}

// Remove marker
function removeMarkerFX(id) {
  activeMarkers = activeMarkers.filter(m => m.id !== id);
  renderMarkerFXList();
  applyAllMarkerFX();
}

// Debounce timers for marker controls
const markerInputTimeouts = new WeakMap();

// Render markers list UI
function renderMarkerFXList() {
  const container = document.getElementById('activeMarkersList');
  if (!container) return;
  
  // Preserve scroll position to prevent auto-scroll bug (Issue #13)
  const scrollParent = container.parentElement;
  const scrollTop = scrollParent ? scrollParent.scrollTop : 0;
  
  container.innerHTML = '';
  
  activeMarkers.forEach(marker => {
    const markerDiv = document.createElement('div');
    markerDiv.className = 'markerInstance';
    markerDiv.innerHTML = `
      <div class="markerHeader">
        <button class="markerToggle" data-id="${marker.id}">▼</button>
        <span class="markerName">${marker.name}</span>
        <button class="markerDelete" data-id="${marker.id}" title="Delete">×</button>
      </div>
      <div class="markerBody" id="${marker.id}_body">
        ${renderMarkerFXControls(marker)}
      </div>
    `;
    container.appendChild(markerDiv);
  });
  
  // Restore scroll position after rebuilding UI (use requestAnimationFrame to ensure DOM is updated)
  if (scrollParent) {
    requestAnimationFrame(() => {
      scrollParent.scrollTop = scrollTop;
    });
  }
  
  // Wire up events
  container.querySelectorAll('.markerToggle').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const id = e.target.dataset.id;
      const body = document.getElementById(`${id}_body`);
      body.classList.toggle('collapsed');
      e.target.textContent = body.classList.contains('collapsed') ? '▶' : '▼';
    });
  });
  
  container.querySelectorAll('.markerDelete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      removeMarkerFX(e.target.dataset.id);
    });
  });
  
  // Wire up control changes
  container.querySelectorAll('[data-id][data-prop]').forEach(input => {
    const inputType = input.type;
    // For color and select inputs, only use change event
    // For number inputs, use both but debounce input
    if (inputType === 'color' || input.tagName === 'SELECT') {
      input.addEventListener('change', (e) => {
        updateMarkerFXProperty(e.target.dataset.id, e.target.dataset.prop, e.target.value);
      });
    } else {
      // Debounce input events with per-element timeout tracking
      input.addEventListener('input', (e) => {
        const existingTimeout = markerInputTimeouts.get(input);
        if (existingTimeout) clearTimeout(existingTimeout);
        const timeoutId = setTimeout(() => {
          updateMarkerFXProperty(e.target.dataset.id, e.target.dataset.prop, e.target.value);
        }, 150);
        markerInputTimeouts.set(input, timeoutId);
      });
      input.addEventListener('change', (e) => {
        const existingTimeout = markerInputTimeouts.get(input);
        if (existingTimeout) clearTimeout(existingTimeout);
        updateMarkerFXProperty(e.target.dataset.id, e.target.dataset.prop, e.target.value);
      });
    }
  });
}

// Update marker property
function updateMarkerFXProperty(id, prop, value) {
  const marker = activeMarkers.find(m => m.id === id);
  if (!marker) return;
  
  // Handle nested properties (e.g., "categoryColors.peak")
  if (prop.includes('.')) {
    const parts = prop.split('.');
    let obj = marker;
    for (let i = 0; i < parts.length - 1; i++) {
      if (!obj[parts[i]]) obj[parts[i]] = {};
      obj = obj[parts[i]];
    }
    obj[parts[parts.length - 1]] = value;
  } else {
    // Parse numbers, but keep strings if empty or non-numeric
    if (value !== '' && !isNaN(value) && value !== null) {
      marker[prop] = parseFloat(value);
    } else {
      marker[prop] = value;
    }
  }
  
  // Handle color mode changes
  if (prop === 'colorMode') {
    renderMarkerFXList();
  }
  
  applyAllMarkerFX();
}

// Render individual marker controls
function renderMarkerFXControls(marker) {
  const hasParticles = ['helix', 'bird', 'birdshape'].includes(marker.type);
  const hasHelixProps = marker.type === 'helix';
  const isXMarker = marker.type === 'x';
  const hasAnimatedProps = !isXMarker && marker.type !== 'loading';
  
  return `
    ${!isXMarker ? `
    <!-- Universal Properties (not for X marker) -->
    <div class="ctrlRow">
      <label>Top Y</label>
      <input type="number" data-id="${marker.id}" data-prop="topY" value="${marker.topY}" step="1">
    </div>
    <div class="ctrlRow">
      <label>Bottom Y</label>
      <input type="number" data-id="${marker.id}" data-prop="bottomY" value="${marker.bottomY}" step="1">
    </div>
    ${hasAnimatedProps ? `
    <div class="ctrlRow">
      <label>Speed</label>
      <input type="number" data-id="${marker.id}" data-prop="speed" value="${marker.speed}" step="0.1" min="0">
    </div>
    <div class="ctrlRow">
      <label>Direction</label>
      <select data-id="${marker.id}" data-prop="direction">
        <option value="cw" ${marker.direction === 'cw' ? 'selected' : ''}>Clockwise</option>
        <option value="ccw" ${marker.direction === 'ccw' ? 'selected' : ''}>Counter-CW</option>
      </select>
    </div>
    ` : ''}
    <div class="ctrlRow">
      <label>Radius</label>
      <input type="number" data-id="${marker.id}" data-prop="radius" value="${marker.radius}" step="1" min="1">
    </div>
    ` : `
    <!-- X Marker Size -->
    <div class="ctrlRow">
      <label>Size</label>
      <input type="number" data-id="${marker.id}" data-prop="size" value="${marker.size || 18}" step="1" min="1">
    </div>
    `}
    
    <!-- Color Mode -->
    <div class="ctrlRow">
      <label>Color Mode</label>
      <select data-id="${marker.id}" data-prop="colorMode">
        <option value="single" ${marker.colorMode === 'single' ? 'selected' : ''}>Single Color</option>
        <option value="category" ${marker.colorMode === 'category' ? 'selected' : ''}>By Category</option>
        <option value="visibility" ${marker.colorMode === 'visibility' ? 'selected' : ''}>By Visibility</option>
      </select>
    </div>
    
    <!-- Single Color -->
    <div class="ctrlRow colorSingle" style="${marker.colorMode !== 'single' ? 'display:none' : ''}">
      <label>Color</label>
      <input type="color" data-id="${marker.id}" data-prop="color" value="${marker.color}">
    </div>
    
    <!-- Category Colors -->
    <div class="colorCategory" style="${marker.colorMode !== 'category' ? 'display:none' : ''}">
      <div class="ctrlRow"><label>Landmark</label><input type="color" data-id="${marker.id}" data-prop="categoryColors.landmark" value="${marker.categoryColors.landmark || marker.categoryColors.Landmark || '#ff6b6b'}"></div>
      <div class="ctrlRow"><label>Leisure</label><input type="color" data-id="${marker.id}" data-prop="categoryColors.leisure" value="${marker.categoryColors.leisure || marker.categoryColors.Leisure || '#4ecdc4'}"></div>
      <div class="ctrlRow"><label>Place</label><input type="color" data-id="${marker.id}" data-prop="categoryColors.place" value="${marker.categoryColors.place || marker.categoryColors.Place || '#f38181'}"></div>
      <div class="ctrlRow"><label>Amenity</label><input type="color" data-id="${marker.id}" data-prop="categoryColors.amenity" value="${marker.categoryColors.amenity || marker.categoryColors.Amenity || '#aa96da'}"></div>
    </div>
    
    <!-- Visibility Colors -->
    <div class="colorVisibility" style="${marker.colorMode !== 'visibility' ? 'display:none' : ''}">
      <div class="ctrlRow"><label>High (80-100%)</label><input type="color" data-id="${marker.id}" data-prop="visibilityColors.high" value="${marker.visibilityColors.high}"></div>
      <div class="ctrlRow"><label>Med (40-80%)</label><input type="color" data-id="${marker.id}" data-prop="visibilityColors.medium" value="${marker.visibilityColors.medium}"></div>
      <div class="ctrlRow"><label>Low (0-40%)</label><input type="color" data-id="${marker.id}" data-prop="visibilityColors.low" value="${marker.visibilityColors.low}"></div>
    </div>
    
    ${hasParticles ? `
    <!-- Particle Properties -->
    <div class="ctrlRow">
      <label>Jitter</label>
      <input type="number" data-id="${marker.id}" data-prop="jitter" value="${marker.jitter}" step="0.1" min="0">
    </div>
    <div class="ctrlRow">
      <label>Flockiness</label>
      <input type="number" data-id="${marker.id}" data-prop="flockiness" value="${marker.flockiness}" step="0.05" min="0" max="1">
    </div>
    ` : ''}
    
    ${hasHelixProps ? `
    <!-- Helix-specific -->
    <div class="ctrlRow">
      <label>Turns</label>
      <input type="number" data-id="${marker.id}" data-prop="turns" value="${marker.turns}" step="0.5" min="1">
    </div>
    ` : ''}
  `;
}

// Apply all active markers to scene
function applyAllMarkerFX() {
  const markers = _getVerifierMarkers();
  markers.forEach(m => {
    // Remove all existing FX
    if (m.userData.fxGroups) {
      m.userData.fxGroups.forEach(g => {
        m.remove(g);
        _fxDispose(g);
      });
    }
    m.userData.fxGroups = [];
    
    // Apply each active marker config
    activeMarkers.forEach(config => {
      const fx = buildMarkerFXFromConfig(config, m);
      if (fx) {
        m.add(fx);
        m.userData.fxGroups.push(fx);
      }
    });
  });
}

// Helper function to resolve color for a marker based on its config and candidate data
function resolveMarkerColor(config, targetMarker) {
  const cand = targetMarker?.userData?.cand;
  if (!cand) return config.color || '#ffffff';
  
  // Normalize dst_type to lowercase for matching
  const normalizeDstType = (type) => {
    if (!type) return '';
    return String(type).toLowerCase().trim();
  };
  
  const dstType = normalizeDstType(cand.dst_type);
  
  if (config.colorMode === 'category') {
    // Try to match category color (case-insensitive)
    const categoryColors = config.categoryColors || {};
    for (const key in categoryColors) {
      if (normalizeDstType(key) === dstType) {
        return categoryColors[key];
      }
    }
    // Fallback if no match found
    return config.color || '#ffffff';
  } else if (config.colorMode === 'visibility') {
    // Color based on vis_pct
    const visPct = Number(cand.vis_pct ?? cand.visibility ?? 0);
    const visColors = config.visibilityColors || {};
    if (visPct >= 80) return visColors.high || '#00ff00';
    if (visPct >= 40) return visColors.medium || '#ffff00';
    return visColors.low || '#ff0000';
  } else {
    // Single color mode
    return config.color || '#ffffff';
  }
}

// Helper function to resolve line color for labels based on config and candidate data
function resolveLabelLineColor(config, targetMarker) {
  const cand = targetMarker?.userData?.cand;
  if (!cand) return config.lineColor || '#00ff00';
  
  const colorMode = config.lineColorMode || 'single';
  
  if (colorMode === 'category') {
    // Use the same category color logic as markers
    const normalizeDstType = (type) => {
      if (!type) return '';
      return String(type).toLowerCase().trim();
    };
    
    const dstType = normalizeDstType(cand.dst_type);
    
    // Default category colors matching marker defaults
    const categoryColors = {
      'landmark': '#ff6b6b',
      'leisure': '#4ecdc4',
      'place': '#f38181',
      'amenity': '#aa96da'
    };
    
    for (const key in categoryColors) {
      if (normalizeDstType(key) === dstType) {
        return categoryColors[key];
      }
    }
    return config.lineColor || '#00ff00';
  } else if (colorMode === 'visibility') {
    // Color based on vis_pct
    const visPct = Number(cand.vis_pct ?? cand.visibility ?? 0);
    if (visPct >= 80) return '#00ff00';
    if (visPct >= 40) return '#ffff00';
    return '#ff0000';
  } else {
    // Single color mode
    return config.lineColor || '#00ff00';
  }
}

// Generic function to resolve color for any label element based on config
function resolveColorForElement(config, cand, element) {
  // element: "line" | "displayShape" | "pillBackground" | "pillBorder" | "text"
  
  // Determine which color mode to use based on element
  let colorMode = 'single';
  let baseColor = '#ffffff';
  
  if (element === 'line') {
    colorMode = config.lineColorMode || 'single';
    baseColor = config.lineColor || '#00ff00';
  } else if (element === 'displayShape') {
    colorMode = config.displayShapeColorMode || 'single';
    baseColor = config.displayShapeColor || '#ffffff';
  } else if (element === 'pillBackground') {
    colorMode = config.pillColorMode || 'single';
    baseColor = config.pillBackgroundColor || 'rgba(0,0,0,0.75)';
  } else if (element === 'pillBorder') {
    colorMode = config.pillColorMode || 'single';
    baseColor = config.pillBorderColor || 'rgba(255,255,255,0.18)';
  } else if (element === 'text') {
    colorMode = 'single'; // Text usually doesn't follow color modes
    baseColor = config.pillTextColor || '#ffffff';
  }
  
  // Apply color mode logic
  if (colorMode === 'category') {
    const normalizeDstType = (type) => {
      if (!type) return '';
      return String(type).toLowerCase().trim();
    };
    
    const dstType = normalizeDstType(cand?.dst_type);
    
    // Use categoryColors from config if available, otherwise use defaults
    const categoryColors = config.categoryColors || {
      'landmark': '#ff6b6b',
      'leisure': '#4ecdc4',
      'place': '#f38181',
      'amenity': '#aa96da'
    };
    
    for (const key in categoryColors) {
      if (normalizeDstType(key) === dstType) {
        return categoryColors[key];
      }
    }
    return baseColor;
  } else if (colorMode === 'visibility') {
    const visPct = Number(cand?.vis_pct ?? cand?.visibility ?? 0);
    if (visPct >= 80) return '#00ff00'; // green
    if (visPct >= 40) return '#ffff00'; // yellow
    return '#ff0000'; // red
  }
  
  // Single color mode (default)
  return baseColor;
}

// Build FX based on marker config (adapts existing FX generation)
function buildMarkerFXFromConfig(config, targetMarker) {
  // Handle X marker type specially
  if (config.type === 'x') {
    const colorHex = parseInt(resolveMarkerColor(config, targetMarker).replace('#', ''), 16);
    const size = config.size || 18;
    const sprite = makeXMarkerSprite(size, colorHex);
    return sprite;
  }
  
  // Store current markerFxCfg and markerFxMode to restore later
  const oldCfg = JSON.parse(JSON.stringify(markerFxCfg));
  const oldMode = markerFxMode;
  
  // Resolve color based on config mode
  const resolvedColor = resolveMarkerColor(config, targetMarker);
  
  // Set config from marker instance
  markerFxCfg.topY = config.topY;
  markerFxCfg.botY = config.bottomY;
  markerFxCfg.radius = config.radius;
  markerFxCfg.speed = config.speed;
  markerFxCfg.dir = config.direction;
  markerFxCfg.jitter = config.jitter || 2.2;
  markerFxCfg.flock = config.flockiness || 0.35;
  markerFxCfg.turns = config.turns || 5.0;
  markerFxCfg.helixColor = resolvedColor;
  markerFxCfg.ringColor = resolvedColor;
  markerFxCfg.birdColor = resolvedColor;
  
  // Build FX using existing function
  const fx = buildHelixFX();
  
  // Store per-marker config in fx.userData for use in animation loop
  if (fx) {
    fx.userData.markerConfig = {
      speed: config.speed,
      direction: config.direction,
      jitter: config.jitter || 2.2,
      flockiness: config.flockiness || 0.35,
      color: resolvedColor,
      colorMode: config.colorMode,
      type: config.type
    };
  }
  
  // Apply visibility based on type
  if (fx) {
    fx.traverse(o => {
      if (!o.isPoints) return;
      const k = o.userData.kind;
      if (config.type === "helix") o.visible = (k === "helix");
      else if (config.type === "ground") o.visible = (k === "ring");
      else if (config.type === "bird") o.visible = (k === "halo");
      else if (config.type === "birdshape") o.visible = (k === "birdshape");
      else if (config.type === "loading") o.visible = (k === "loading");
      else o.visible = false;
    });
  }
  
  // Restore old config
  markerFxCfg = oldCfg;
  markerFxMode = oldMode;
  
  return fx;
}

// Initialize modular marker system
function initModularMarkerSystem() {
  const addBtn = document.getElementById('addMarkerBtn');
  const typeSelector = document.getElementById('markerTypeSelector');
  
  if (addBtn && typeSelector) {
    addBtn.addEventListener('click', () => {
      // Toggle dropdown visibility
      if (typeSelector.style.display === 'none') {
        typeSelector.style.display = 'block';
        addBtn.style.display = 'none';
      }
    });
    
    typeSelector.addEventListener('change', (e) => {
      const type = e.target.value;
      if (type && markerTypeDefaults[type]) {
        addMarkerFX(type);
        // Reset dropdown
        e.target.value = '';
        typeSelector.style.display = 'none';
        addBtn.style.display = 'block';
      }
    });
  }
}

// ================= MODULAR LABEL SYSTEM =================

// Active label configurations
let activeLabels = [];
let labelIdCounter = 0;

// Label type definitions with default properties
const labelTypeDefaults = {
  label: {
    name: "Label",
    showLine: true,
    lineHeight: 40,
    lineColor: "#00ff00",
    lineColorMode: "category",
    lineOpacity: 0.8,
    lineWidth: 2,
    
    showDisplayShape: true,
    displayShapeType: "square", // circle | square | diamond | triangle | asterisk
    displayShapeSize: 6,
    displayShapeFillColor: "rgba(0,0,0,0.95)",
    displayShapeStrokeColor: "rgba(255,255,255,0.8)",
    displayShapeStrokeWidth: 0,
    displayShapeOpacity: 1.0,
    displayShapeColorMode: "single", // single | category | visibility
    displayShapeOffset: 0, // Vertical offset from line top (0 = line top, positive = higher, negative = lower)
    
    content: ["name"],
    pillShape: "rounded",
    pillBackgroundColor: "rgba(0,0,0,0.75)",
    pillBorderColor: "rgba(255,255,255,0.18)",
    pillTextColor: "#ffffff",
    pillColorMode: "single",
    
    // Multi-line text configuration (Issues 7 & 8)
    useMultiLine: false, // Enable multi-line pill labels
    lineSpacing: 4, // Spacing between lines in pixels
    line1: {
      content: "name", // name | type | custom
      fontSize: 14,
      fontFamily: "helvetica",
      bold: true,
      italic: false,
      underline: false,
      strikethrough: false,
      alignment: "left" // left | center | right
    },
    line2: {
      content: "category", // category | subtype | landmark | custom
      fontSize: 11,
      fontFamily: "helvetica",
      bold: false,
      italic: false,
      underline: false,
      strikethrough: false,
      alignment: "left"
    },
    line3: {
      content: "distance", // distance | bearing | visibility | elevation | custom
      fontSize: 9,
      fontFamily: "helvetica",
      bold: false,
      italic: false,
      underline: false,
      strikethrough: false,
      alignment: "left"
    },
    
    // Pill positioning
    pillPosition: "top-center", // top-center | top-left | top-right | side-left | side-right
    pillTopGap: 2.0, // Gap from shape/line when in top positions
    pillSideGap: 2.0, // Gap from line when in side positions  
    pillSideAlignment: "shape", // shape | line (for side positions: align top to shape or line)
    pillOffset: 0, // Vertical offset from default position (0 = default, positive = higher, negative = lower)
    
    font: "helvetica",
    fontSize: 12,
    paddingX: 18,
    paddingY: 12,
    
    categoryColors: {
      "landmark": "#ff0000",
      "leisure": "#00ff00",
      "amenity": "#0000ff",
      "place": "#ffff00"
    },
    
    // Animation params
    animSeconds: 1.8,
    loop: false
  },
  hover: {
    name: "Hover Tip",
    showLine: false, // Off by default for hover
    lineHeight: 20,
    lineColor: "#00ff00",
    lineColorMode: "category",
    lineOpacity: 0.8,
    lineWidth: 2,
    
    showDisplayShape: false, // Off by default for hover
    displayShapeType: "square",
    displayShapeSize: 6,
    displayShapeFillColor: "rgba(0,0,0,0.95)",
    displayShapeStrokeColor: "rgba(255,255,255,0.8)",
    displayShapeStrokeWidth: 0,
    displayShapeOpacity: 1.0,
    displayShapeColorMode: "single",
    displayShapeOffset: 0,
    
    content: ["name"],
    pillShape: "rounded",
    pillBackgroundColor: "rgba(0,0,0,0.75)",
    pillBorderColor: "rgba(255,255,255,0.18)",
    pillTextColor: "#ffffff",
    pillColorMode: "single",
    
    // Multi-line text configuration (Issues 7 & 8)
    useMultiLine: false,
    lineSpacing: 4,
    line1: {
      content: "name",
      fontSize: 12,
      fontFamily: "helvetica",
      bold: true,
      italic: false,
      underline: false,
      strikethrough: false,
      alignment: "left"
    },
    line2: {
      content: "category",
      fontSize: 10,
      fontFamily: "helvetica",
      bold: false,
      italic: false,
      underline: false,
      strikethrough: false,
      alignment: "left"
    },
    line3: {
      content: "distance",
      fontSize: 8,
      fontFamily: "helvetica",
      bold: false,
      italic: false,
      underline: false,
      strikethrough: false,
      alignment: "left"
    },
    
    // Pill positioning
    pillPosition: "top-center",
    pillTopGap: 2.0,
    pillSideGap: 2.0,
    pillSideAlignment: "shape",
    pillOffset: 0,
    
    font: "helvetica",
    fontSize: 12,
    paddingX: 10,
    paddingY: 8,
    
    categoryColors: {
      "landmark": "#ff0000",
      "leisure": "#00ff00",
      "amenity": "#0000ff",
      "place": "#ffff00"
    },
    
    showOnHover: true,
    fadeDistance: 100,
    maxDistance: 500,
    
    // Animation params
    animSeconds: 1.8,
    loop: false
  }
};

// Add new label
function addLabelFX(type) {
  const id = `label_${labelIdCounter++}`;
  const config = {
    id,
    type,
    ...JSON.parse(JSON.stringify(labelTypeDefaults[type]))
  };
  activeLabels.push(config);
  renderLabelFXList();
  applyAllLabelFX();
}

// Remove label
function removeLabelFX(id) {
  activeLabels = activeLabels.filter(l => l.id !== id);
  renderLabelFXList();
  applyAllLabelFX();
}

// Debounce timers for label controls
const labelInputTimeouts = new WeakMap();

// Render labels list UI
function renderLabelFXList() {
  const container = document.getElementById('activeLabelsList');
  if (!container) return;
  
  // Preserve scroll position to prevent auto-scroll bug (Issue #13)
  const scrollParent = container.parentElement;
  const scrollTop = scrollParent ? scrollParent.scrollTop : 0;
  
  container.innerHTML = '';
  
  activeLabels.forEach(label => {
    const labelDiv = document.createElement('div');
    labelDiv.className = 'markerInstance'; // Reuse marker styles
    labelDiv.innerHTML = `
      <div class="markerHeader">
        <button class="markerToggle" data-id="${label.id}">▼</button>
        <span class="markerName">${label.name}</span>
        <button class="markerDelete" data-id="${label.id}" title="Delete">×</button>
      </div>
      <div class="markerBody" id="${label.id}_body">
        ${renderLabelFXControls(label)}
      </div>
    `;
    container.appendChild(labelDiv);
  });
  
  // Restore scroll position after rebuilding UI (use requestAnimationFrame to ensure DOM is updated)
  if (scrollParent) {
    requestAnimationFrame(() => {
      scrollParent.scrollTop = scrollTop;
    });
  }
  
  // Wire up events
  container.querySelectorAll('.markerToggle').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const id = e.target.dataset.id;
      const body = document.getElementById(`${id}_body`);
      body.classList.toggle('collapsed');
      e.target.textContent = body.classList.contains('collapsed') ? '▶' : '▼';
    });
  });
  
  container.querySelectorAll('.markerDelete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      removeLabelFX(e.target.dataset.id);
    });
  });
  
  // Wire up "Copy from Label" button for hover tips
  container.querySelectorAll('.copyFromLabelBtn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const hoverId = e.target.dataset.id;
      const hoverLabel = activeLabels.find(l => l.id === hoverId);
      const labelConfig = activeLabels.find(l => l.type === 'label');
      
      if (hoverLabel && labelConfig && hoverLabel.type === 'hover') {
        // Copy all relevant properties from label to hover (except type-specific ones)
        const propertiesToCopy = [
          'showLine', 'lineHeight', 'lineColor', 'lineColorMode', 'lineOpacity', 'lineWidth',
          'showDisplayShape', 'displayShapeType', 'displayShapeSize', 'displayShapeFillColor',
          'displayShapeStrokeColor', 'displayShapeStrokeWidth', 'displayShapeOpacity', 
          'displayShapeColorMode', 'displayShapeOffset',
          'content', 'pillShape', 'pillBackgroundColor', 'pillBorderColor', 'pillTextColor',
          'pillColorMode', 'pillPosition', 'pillTopGap', 'pillSideGap', 'pillSideAlignment', 'pillOffset',
          'font', 'fontSize', 'paddingX', 'paddingY', 'categoryColors'
        ];
        
        propertiesToCopy.forEach(prop => {
          if (labelConfig[prop] !== undefined) {
            if (typeof labelConfig[prop] === 'object' && !Array.isArray(labelConfig[prop])) {
              hoverLabel[prop] = JSON.parse(JSON.stringify(labelConfig[prop]));
            } else if (Array.isArray(labelConfig[prop])) {
              hoverLabel[prop] = [...labelConfig[prop]];
            } else {
              hoverLabel[prop] = labelConfig[prop];
            }
          }
        });
        
        renderLabelFXList();
        applyAllLabelFX();
      }
    });
  });
  
  // Wire up control changes
  container.querySelectorAll('[data-id][data-prop]').forEach(input => {
    const inputType = input.type;
    const prop = input.dataset.prop;
    
    // Special handling for content checkboxes
    if (inputType === 'checkbox' && prop === 'content') {
      input.addEventListener('change', (e) => {
        const labelId = e.target.dataset.id;
        const contentValue = e.target.dataset.contentValue;
        const label = activeLabels.find(l => l.id === labelId);
        if (!label) return;
        
        // Ensure content is an array
        if (!Array.isArray(label.content)) {
          label.content = label.content ? [label.content] : [];
        }
        
        // Add or remove the content value
        if (e.target.checked) {
          if (!label.content.includes(contentValue)) {
            label.content.push(contentValue);
          }
        } else {
          label.content = label.content.filter(v => v !== contentValue);
        }
        
        // Ensure at least one item is selected
        if (label.content.length === 0) {
          label.content = ['name'];
          // Re-render will update all checkbox states correctly
          renderLabelFXList();
          return;
        }
        
        renderLabelFXList();
      });
      return; // Skip the normal handler
    }
    
    // For color and select inputs, only use change event
    // For text and number inputs, debounce input
    if (inputType === 'color' || input.tagName === 'SELECT') {
      input.addEventListener('change', (e) => {
        updateLabelFXProperty(e.target.dataset.id, e.target.dataset.prop, e.target.value);
      });
    } else if (inputType === 'checkbox') {
      // Handle other checkboxes (e.g., loop)
      input.addEventListener('change', (e) => {
        updateLabelFXProperty(e.target.dataset.id, e.target.dataset.prop, e.target.checked);
      });
    } else {
      // Debounce input events with per-element timeout tracking
      input.addEventListener('input', (e) => {
        const existingTimeout = labelInputTimeouts.get(input);
        if (existingTimeout) clearTimeout(existingTimeout);
        const timeoutId = setTimeout(() => {
          updateLabelFXProperty(e.target.dataset.id, e.target.dataset.prop, e.target.value);
        }, 150);
        labelInputTimeouts.set(input, timeoutId);
      });
      input.addEventListener('change', (e) => {
        const existingTimeout = labelInputTimeouts.get(input);
        if (existingTimeout) clearTimeout(existingTimeout);
        updateLabelFXProperty(e.target.dataset.id, e.target.dataset.prop, e.target.value);
      });
    }
  });
}

// Update label property
function updateLabelFXProperty(id, prop, value) {
  const label = activeLabels.find(l => l.id === id);
  if (!label) return;
  
  // Handle nested properties (e.g., categoryColors.landmark, line1.bold)
  if (prop.includes('.')) {
    const parts = prop.split('.');
    let obj = label;
    for (let i = 0; i < parts.length - 1; i++) {
      // Create intermediate object if it doesn't exist, but only if current value isn't already a non-object
      if (!obj[parts[i]] || obj[parts[i]] === null || typeof obj[parts[i]] !== 'object') {
        obj[parts[i]] = {};
      }
      obj = obj[parts[i]];
    }
    // Handle value types for nested properties
    const finalProp = parts[parts.length - 1];
    if (value === 'true' || value === 'false') {
      obj[finalProp] = value === 'true';
    } else if (typeof value === 'boolean') {
      obj[finalProp] = value;
    } else if (!isNaN(value) && value !== '') {
      obj[finalProp] = parseFloat(value);
    } else {
      obj[finalProp] = value;
    }
  } else {
    // Handle boolean values
    if (value === 'true' || value === 'false') {
      label[prop] = value === 'true';
    } else if (typeof value === 'boolean') {
      label[prop] = value;
    } else if (!isNaN(value) && value !== '') {
      label[prop] = parseFloat(value);
    } else {
      label[prop] = value;
    }
  }
  
  // Re-render if certain properties change
  if (prop === 'format' || prop === 'content' || prop === 'type' || 
      prop === 'lineColorMode' || prop === 'displayShapeColorMode' || prop === 'pillColorMode' ||
      prop === 'useMultiLine' || prop.startsWith('line1.') || prop.startsWith('line2.') || prop.startsWith('line3.')) {
    renderLabelFXList();
  }
  
  applyAllLabelFX();
}

// Render individual label controls
function renderLabelFXControls(label) {
  const isLabelMode = label.type === 'label';
  const isHoverMode = label.type === 'hover';
  
  // Check if any element uses category mode (to show category colors section)
  const usesCategoryColors = (
    label.lineColorMode === 'category' ||
    label.displayShapeColorMode === 'category' ||
    label.pillColorMode === 'category'
  );
  
  if (isLabelMode) {
    return `
      <!-- Line Controls -->
      <div class="ctrlRow" style="align-items:center;">
        <label style="flex:1;">
          <input type="checkbox" data-id="${label.id}" data-prop="showLine" ${label.showLine ? 'checked' : ''}>
          <span>Show Line</span>
        </label>
      </div>
      
      ${label.showLine ? `
      <div class="ctrlRow">
        <label>Line Height (world)</label>
        <input type="number" data-id="${label.id}" data-prop="lineHeight" value="${label.lineHeight || 40}" step="1" min="5" max="140">
      </div>
      
      <div class="ctrlRow">
        <label>Line Color Mode</label>
        <select data-id="${label.id}" data-prop="lineColorMode">
          <option value="single" ${(label.lineColorMode || 'single') === 'single' ? 'selected' : ''}>Single Color</option>
          <option value="category" ${label.lineColorMode === 'category' ? 'selected' : ''}>Category</option>
          <option value="visibility" ${label.lineColorMode === 'visibility' ? 'selected' : ''}>Visibility %</option>
        </select>
      </div>
      
      ${label.lineColorMode === 'single' ? `
      <div class="ctrlRow">
        <label>Line Color</label>
        <input type="color" data-id="${label.id}" data-prop="lineColor" value="${label.lineColor || '#00ff00'}">
      </div>
      ` : ''}
      
      <div class="ctrlRow">
        <label>Line Width</label>
        <input type="number" data-id="${label.id}" data-prop="lineWidth" value="${label.lineWidth || 2}" step="0.5" min="0.5" max="10">
      </div>
      ` : ''}
      
      <!-- Display Shape Controls -->
      <hr style="border:none;border-top:1px solid rgba(255,255,255,.12);margin:12px 0;">
      <div class="ctrlRow" style="align-items:center;">
        <label style="flex:1;">
          <input type="checkbox" data-id="${label.id}" data-prop="showDisplayShape" ${label.showDisplayShape ? 'checked' : ''}>
          <span>Show Display Shape</span>
        </label>
      </div>
      
      ${label.showDisplayShape ? `
      <div class="ctrlRow">
        <label>Shape Type</label>
        <select data-id="${label.id}" data-prop="displayShapeType">
          <option value="circle" ${(label.displayShapeType || 'square') === 'circle' ? 'selected' : ''}>Circle</option>
          <option value="square" ${(label.displayShapeType || 'square') === 'square' ? 'selected' : ''}>Square</option>
          <option value="diamond" ${label.displayShapeType === 'diamond' ? 'selected' : ''}>Diamond</option>
          <option value="triangle" ${label.displayShapeType === 'triangle' ? 'selected' : ''}>Triangle</option>
          <option value="asterisk" ${label.displayShapeType === 'asterisk' ? 'selected' : ''}>Asterisk</option>
        </select>
      </div>
      
      <div class="ctrlRow">
        <label>Display Shape Size</label>
        <input type="number" data-id="${label.id}" data-prop="displayShapeSize" value="${label.displayShapeSize || 6}" step="1" min="2" max="18">
      </div>
      
      <div class="ctrlRow">
        <label>Shape Vertical Offset</label>
        <input type="number" data-id="${label.id}" data-prop="displayShapeOffset" value="${label.displayShapeOffset || 0}" step="0.5" min="-50" max="50">
        <small style="opacity:0.7;font-size:10px;margin-left:4px;">0=line top, +higher, -lower</small>
      </div>
      
      <div class="ctrlRow">
        <label>Shape Color Mode</label>
        <select data-id="${label.id}" data-prop="displayShapeColorMode">
          <option value="single" ${(label.displayShapeColorMode || 'single') === 'single' ? 'selected' : ''}>Single Color</option>
          <option value="category" ${label.displayShapeColorMode === 'category' ? 'selected' : ''}>Category</option>
          <option value="visibility" ${label.displayShapeColorMode === 'visibility' ? 'selected' : ''}>Visibility %</option>
        </select>
      </div>
      
      <div class="ctrlRow">
        <label>Shape Fill Color</label>
        <input type="text" data-id="${label.id}" data-prop="displayShapeFillColor" value="${label.displayShapeFillColor || 'rgba(0,0,0,0.95)'}" placeholder="rgba(0,0,0,0.95)" style="font-size:11px;">
      </div>
      
      <div class="ctrlRow">
        <label>Shape Stroke Color</label>
        <input type="text" data-id="${label.id}" data-prop="displayShapeStrokeColor" value="${label.displayShapeStrokeColor || 'rgba(255,255,255,0.8)'}" placeholder="rgba(255,255,255,0.8)" style="font-size:11px;">
      </div>
      
      <div class="ctrlRow">
        <label>Shape Stroke Width</label>
        <input type="number" data-id="${label.id}" data-prop="displayShapeStrokeWidth" value="${label.displayShapeStrokeWidth || 0}" step="0.5" min="0" max="5">
      </div>
      
      <div class="ctrlRow">
        <label>Shape Opacity</label>
        <input type="number" data-id="${label.id}" data-prop="displayShapeOpacity" value="${label.displayShapeOpacity !== undefined ? label.displayShapeOpacity : 1.0}" step="0.05" min="0" max="1">
      </div>
      ` : ''}
      
      <!-- Pill Label Controls -->
      <hr style="border:none;border-top:1px solid rgba(255,255,255,.12);margin:12px 0;">
      <div style="font-weight:700;margin-bottom:8px;">Pill Label</div>
      
      <div class="ctrlRow">
        <label>Pill Shape</label>
        <select data-id="${label.id}" data-prop="pillShape">
          <option value="rounded" ${(label.pillShape || 'rounded') === 'rounded' ? 'selected' : ''}>Rounded</option>
          <option value="soft-rounded" ${label.pillShape === 'soft-rounded' ? 'selected' : ''}>Soft-rounded</option>
          <option value="square" ${label.pillShape === 'square' ? 'selected' : ''}>Square</option>
        </select>
      </div>
      
      <div class="ctrlRow">
        <label>Pill Position</label>
        <select data-id="${label.id}" data-prop="pillPosition">
          <option value="top-center" ${(label.pillPosition || 'top-center') === 'top-center' ? 'selected' : ''}>Top Center</option>
          <option value="top-left" ${label.pillPosition === 'top-left' ? 'selected' : ''}>Top Left</option>
          <option value="top-right" ${label.pillPosition === 'top-right' ? 'selected' : ''}>Top Right</option>
          <option value="side-left" ${label.pillPosition === 'side-left' ? 'selected' : ''}>Side Left</option>
          <option value="side-right" ${label.pillPosition === 'side-right' ? 'selected' : ''}>Side Right</option>
        </select>
      </div>
      
      ${(label.pillPosition || 'top-center').startsWith('top') ? `
      <div class="ctrlRow">
        <label>Pill Top Gap</label>
        <input type="number" data-id="${label.id}" data-prop="pillTopGap" value="${label.pillTopGap !== undefined ? label.pillTopGap : 2.0}" step="0.5" min="0" max="10">
      </div>
      ` : ''}
      
      ${(label.pillPosition || 'top-center').startsWith('side') ? `
      <div class="ctrlRow">
        <label>Pill Side Gap</label>
        <input type="number" data-id="${label.id}" data-prop="pillSideGap" value="${label.pillSideGap !== undefined ? label.pillSideGap : 2.0}" step="0.5" min="0" max="10">
      </div>
      
      <div class="ctrlRow">
        <label>Side Alignment</label>
        <select data-id="${label.id}" data-prop="pillSideAlignment">
          <option value="shape" ${(label.pillSideAlignment || 'shape') === 'shape' ? 'selected' : ''}>Align to Shape</option>
          <option value="line" ${label.pillSideAlignment === 'line' ? 'selected' : ''}>Align to Line</option>
        </select>
      </div>
      ` : ''}
      
      <div class="ctrlRow">
        <label>Pill Vertical Offset</label>
        <input type="number" data-id="${label.id}" data-prop="pillOffset" value="${label.pillOffset || 0}" step="0.5" min="-50" max="50">
        <small style="opacity:0.7;font-size:10px;margin-left:4px;">+higher, -lower</small>
      </div>
      
      <!-- Content Checkboxes -->
      <div class="ctrlRow" style="flex-direction: column; align-items: flex-start;">
        <label style="margin-bottom: 6px;">Content (select multiple)</label>
        <div style="display: flex; flex-direction: column; gap: 4px; width: 100%;">
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="name" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('name') ? 'checked' : ''}>
            <span>Name</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="distance" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('distance') ? 'checked' : ''}>
            <span>Distance</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="bearing" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('bearing') ? 'checked' : ''}>
            <span>Bearing</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="category" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('category') ? 'checked' : ''}>
            <span>Category</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="subtype" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('subtype') ? 'checked' : ''}>
            <span>Subtype</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="visibility" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('visibility') ? 'checked' : ''}>
            <span>Visibility %</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="elevation" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('elevation') ? 'checked' : ''}>
            <span>Elevation</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="id" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('id') ? 'checked' : ''}>
            <span>Identifier</span>
          </label>
        </div>
      </div>
      
      <div class="ctrlRow">
        <label>Pill Color Mode</label>
        <select data-id="${label.id}" data-prop="pillColorMode">
          <option value="single" ${(label.pillColorMode || 'single') === 'single' ? 'selected' : ''}>Single Color</option>
          <option value="category" ${label.pillColorMode === 'category' ? 'selected' : ''}>Category</option>
          <option value="visibility" ${label.pillColorMode === 'visibility' ? 'selected' : ''}>Visibility %</option>
        </select>
      </div>
      
      ${label.pillColorMode === 'single' ? `
      <div class="ctrlRow">
        <label>Pill Background</label>
        <input type="text" data-id="${label.id}" data-prop="pillBackgroundColor" value="${label.pillBackgroundColor || 'rgba(0,0,0,0.75)'}" placeholder="rgba(0,0,0,0.75)" style="font-size:11px;">
      </div>
      
      <div class="ctrlRow">
        <label>Pill Border</label>
        <input type="text" data-id="${label.id}" data-prop="pillBorderColor" value="${label.pillBorderColor || 'rgba(255,255,255,0.18)'}" placeholder="rgba(255,255,255,0.18)" style="font-size:11px;">
      </div>
      ` : ''}
      
      <div class="ctrlRow">
        <label>Text Color</label>
        <input type="color" data-id="${label.id}" data-prop="pillTextColor" value="${label.pillTextColor || '#ffffff'}">
      </div>
      
      <div class="ctrlRow">
        <label>Font Size</label>
        <input type="number" data-id="${label.id}" data-prop="fontSize" value="${label.fontSize || 12}" step="1" min="8" max="24">
      </div>
      
      <div class="ctrlRow">
        <label>Font</label>
        <select data-id="${label.id}" data-prop="font">
          <option value="helvetica" ${(label.font || 'helvetica') === 'helvetica' ? 'selected' : ''}>Helvetica</option>
          <option value="times" ${label.font === 'times' ? 'selected' : ''}>Times New Roman</option>
          <option value="caslon" ${label.font === 'caslon' ? 'selected' : ''}>Caslon</option>
          <option value="inter" ${label.font === 'inter' ? 'selected' : ''}>Inter</option>
          <option value="manrope" ${label.font === 'manrope' ? 'selected' : ''}>Manrope</option>
          <option value="ibmplex" ${label.font === 'ibmplex' ? 'selected' : ''}>IBM Plex Sans</option>
          <option value="spacegrotesk" ${label.font === 'spacegrotesk' ? 'selected' : ''}>Space Grotesk</option>
          <option value="system" ${label.font === 'system' ? 'selected' : ''}>System UI</option>
        </select>
      </div>
      
      <div class="ctrlRow">
        <label>Padding X</label>
        <input type="number" data-id="${label.id}" data-prop="paddingX" value="${label.paddingX || 18}" step="1" min="0" max="40">
      </div>
      
      <div class="ctrlRow">
        <label>Padding Y</label>
        <input type="number" data-id="${label.id}" data-prop="paddingY" value="${label.paddingY || 12}" step="1" min="0" max="40">
      </div>
      
      ${usesCategoryColors ? `
      <!-- Category Colors -->
      <hr style="border:none;border-top:1px solid rgba(255,255,255,.12);margin:12px 0;">
      <div style="font-weight:700;margin-bottom:8px;">Category Colors</div>
      
      <div class="ctrlRow">
        <label>Landmark</label>
        <input type="color" data-id="${label.id}" data-prop="categoryColors.landmark" value="${label.categoryColors?.landmark || '#ff0000'}">
      </div>
      
      <div class="ctrlRow">
        <label>Leisure</label>
        <input type="color" data-id="${label.id}" data-prop="categoryColors.leisure" value="${label.categoryColors?.leisure || '#00ff00'}">
      </div>
      
      <div class="ctrlRow">
        <label>Amenity</label>
        <input type="color" data-id="${label.id}" data-prop="categoryColors.amenity" value="${label.categoryColors?.amenity || '#0000ff'}">
      </div>
      
      <div class="ctrlRow">
        <label>Place</label>
        <input type="color" data-id="${label.id}" data-prop="categoryColors.place" value="${label.categoryColors?.place || '#ffff00'}">
      </div>
      ` : ''}
      
      <!-- Animation -->
      <hr style="border:none;border-top:1px solid rgba(255,255,255,.12);margin:12px 0;">
      <div style="font-weight:700;margin-bottom:8px;">Animation</div>
      
      <div class="ctrlRow">
        <label>Duration (sec)</label>
        <input type="number" data-id="${label.id}" data-prop="animSeconds" value="${label.animSeconds || 1.8}" step="0.1" min="0.2" max="10">
      </div>
      
      <div class="ctrlRow">
        <label>Loop</label>
        <input type="checkbox" data-id="${label.id}" data-prop="loop" ${label.loop ? 'checked' : ''}>
      </div>
    `;
  } else if (isHoverMode) {
    return `
      <!-- Copy from Label Button -->
      <div class="ctrlRow">
        <button class="copyFromLabelBtn" data-id="${label.id}" style="width:100%;padding:8px;background:rgba(100,150,255,0.2);border:1px solid rgba(100,150,255,0.4);border-radius:6px;color:#fff;cursor:pointer;font-weight:600;">
          📋 Copy Settings from Label
        </button>
      </div>
      
      <!-- Line Controls -->
      <hr style="border:none;border-top:1px solid rgba(255,255,255,.12);margin:12px 0;">
      <div class="ctrlRow" style="align-items:center;">
        <label style="flex:1;">
          <input type="checkbox" data-id="${label.id}" data-prop="showLine" ${label.showLine ? 'checked' : ''}>
          <span>Show Line</span>
        </label>
      </div>
      
      ${label.showLine ? `
      <div class="ctrlRow">
        <label>Line Height (world)</label>
        <input type="number" data-id="${label.id}" data-prop="lineHeight" value="${label.lineHeight || 40}" step="1" min="5" max="140">
      </div>
      
      <div class="ctrlRow">
        <label>Line Color Mode</label>
        <select data-id="${label.id}" data-prop="lineColorMode">
          <option value="single" ${(label.lineColorMode || 'single') === 'single' ? 'selected' : ''}>Single Color</option>
          <option value="category" ${label.lineColorMode === 'category' ? 'selected' : ''}>Category</option>
          <option value="visibility" ${label.lineColorMode === 'visibility' ? 'selected' : ''}>Visibility %</option>
        </select>
      </div>
      
      ${label.lineColorMode === 'single' ? `
      <div class="ctrlRow">
        <label>Line Color</label>
        <input type="color" data-id="${label.id}" data-prop="lineColor" value="${label.lineColor || '#00ff00'}">
      </div>
      ` : ''}
      
      <div class="ctrlRow">
        <label>Line Width</label>
        <input type="number" data-id="${label.id}" data-prop="lineWidth" value="${label.lineWidth || 2}" step="0.5" min="0.5" max="10">
      </div>
      ` : ''}
      
      <!-- Display Shape Controls -->
      <hr style="border:none;border-top:1px solid rgba(255,255,255,.12);margin:12px 0;">
      <div class="ctrlRow" style="align-items:center;">
        <label style="flex:1;">
          <input type="checkbox" data-id="${label.id}" data-prop="showDisplayShape" ${label.showDisplayShape ? 'checked' : ''}>
          <span>Show Display Shape</span>
        </label>
      </div>
      
      ${label.showDisplayShape ? `
      <div class="ctrlRow">
        <label>Shape Type</label>
        <select data-id="${label.id}" data-prop="displayShapeType">
          <option value="circle" ${(label.displayShapeType || 'square') === 'circle' ? 'selected' : ''}>Circle</option>
          <option value="square" ${(label.displayShapeType || 'square') === 'square' ? 'selected' : ''}>Square</option>
          <option value="diamond" ${label.displayShapeType === 'diamond' ? 'selected' : ''}>Diamond</option>
          <option value="triangle" ${label.displayShapeType === 'triangle' ? 'selected' : ''}>Triangle</option>
          <option value="asterisk" ${label.displayShapeType === 'asterisk' ? 'selected' : ''}>Asterisk</option>
        </select>
      </div>
      
      <div class="ctrlRow">
        <label>Display Shape Size</label>
        <input type="number" data-id="${label.id}" data-prop="displayShapeSize" value="${label.displayShapeSize || 6}" step="1" min="2" max="18">
      </div>
      
      <div class="ctrlRow">
        <label>Shape Vertical Offset</label>
        <input type="number" data-id="${label.id}" data-prop="displayShapeOffset" value="${label.displayShapeOffset || 0}" step="0.5" min="-50" max="50">
        <small style="opacity:0.7;font-size:10px;margin-left:4px;">0=line top, +higher, -lower</small>
      </div>
      
      <div class="ctrlRow">
        <label>Shape Color Mode</label>
        <select data-id="${label.id}" data-prop="displayShapeColorMode">
          <option value="single" ${(label.displayShapeColorMode || 'single') === 'single' ? 'selected' : ''}>Single Color</option>
          <option value="category" ${label.displayShapeColorMode === 'category' ? 'selected' : ''}>Category</option>
          <option value="visibility" ${label.displayShapeColorMode === 'visibility' ? 'selected' : ''}>Visibility %</option>
        </select>
      </div>
      
      <div class="ctrlRow">
        <label>Shape Fill Color</label>
        <input type="text" data-id="${label.id}" data-prop="displayShapeFillColor" value="${label.displayShapeFillColor || 'rgba(0,0,0,0.95)'}" placeholder="rgba(0,0,0,0.95)" style="font-size:11px;">
      </div>
      
      <div class="ctrlRow">
        <label>Shape Stroke Color</label>
        <input type="text" data-id="${label.id}" data-prop="displayShapeStrokeColor" value="${label.displayShapeStrokeColor || 'rgba(255,255,255,0.8)'}" placeholder="rgba(255,255,255,0.8)" style="font-size:11px;">
      </div>
      
      <div class="ctrlRow">
        <label>Shape Stroke Width</label>
        <input type="number" data-id="${label.id}" data-prop="displayShapeStrokeWidth" value="${label.displayShapeStrokeWidth || 0}" step="0.5" min="0" max="5">
      </div>
      
      <div class="ctrlRow">
        <label>Shape Opacity</label>
        <input type="number" data-id="${label.id}" data-prop="displayShapeOpacity" value="${label.displayShapeOpacity !== undefined ? label.displayShapeOpacity : 1.0}" step="0.05" min="0" max="1">
      </div>
      ` : ''}
      
      <!-- Pill Label Controls -->
      <hr style="border:none;border-top:1px solid rgba(255,255,255,.12);margin:12px 0;">
      <div style="font-weight:700;margin-bottom:8px;">Pill Label</div>
      
      <div class="ctrlRow">
        <label>Pill Shape</label>
        <select data-id="${label.id}" data-prop="pillShape">
          <option value="rounded" ${(label.pillShape || 'rounded') === 'rounded' ? 'selected' : ''}>Rounded</option>
          <option value="soft-rounded" ${label.pillShape === 'soft-rounded' ? 'selected' : ''}>Soft-rounded</option>
          <option value="square" ${label.pillShape === 'square' ? 'selected' : ''}>Square</option>
        </select>
      </div>
      
      <div class="ctrlRow">
        <label>Pill Position</label>
        <select data-id="${label.id}" data-prop="pillPosition">
          <option value="top-center" ${(label.pillPosition || 'top-center') === 'top-center' ? 'selected' : ''}>Top Center</option>
          <option value="top-left" ${label.pillPosition === 'top-left' ? 'selected' : ''}>Top Left</option>
          <option value="top-right" ${label.pillPosition === 'top-right' ? 'selected' : ''}>Top Right</option>
          <option value="side-left" ${label.pillPosition === 'side-left' ? 'selected' : ''}>Side Left</option>
          <option value="side-right" ${label.pillPosition === 'side-right' ? 'selected' : ''}>Side Right</option>
        </select>
      </div>
      
      ${(label.pillPosition || 'top-center').startsWith('top') ? `
      <div class="ctrlRow">
        <label>Pill Top Gap</label>
        <input type="number" data-id="${label.id}" data-prop="pillTopGap" value="${label.pillTopGap !== undefined ? label.pillTopGap : 2.0}" step="0.5" min="0" max="10">
      </div>
      ` : ''}
      
      ${(label.pillPosition || 'top-center').startsWith('side') ? `
      <div class="ctrlRow">
        <label>Pill Side Gap</label>
        <input type="number" data-id="${label.id}" data-prop="pillSideGap" value="${label.pillSideGap !== undefined ? label.pillSideGap : 2.0}" step="0.5" min="0" max="10">
      </div>
      
      <div class="ctrlRow">
        <label>Side Alignment</label>
        <select data-id="${label.id}" data-prop="pillSideAlignment">
          <option value="shape" ${(label.pillSideAlignment || 'shape') === 'shape' ? 'selected' : ''}>Align to Shape</option>
          <option value="line" ${label.pillSideAlignment === 'line' ? 'selected' : ''}>Align to Line</option>
        </select>
      </div>
      ` : ''}
      
      <div class="ctrlRow">
        <label>Pill Vertical Offset</label>
        <input type="number" data-id="${label.id}" data-prop="pillOffset" value="${label.pillOffset || 0}" step="0.5" min="-50" max="50">
        <small style="opacity:0.7;font-size:10px;margin-left:4px;">+higher, -lower</small>
      </div>
      
      <!-- Content Checkboxes -->
      <div class="ctrlRow" style="flex-direction: column; align-items: flex-start;">
        <label style="margin-bottom: 6px;">Content (select multiple)</label>
        <div style="display: flex; flex-direction: column; gap: 4px; width: 100%;">
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="name" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('name') ? 'checked' : ''}>
            <span>Name</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="distance" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('distance') ? 'checked' : ''}>
            <span>Distance</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="bearing" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('bearing') ? 'checked' : ''}>
            <span>Bearing</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="category" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('category') ? 'checked' : ''}>
            <span>Category</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="subtype" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('subtype') ? 'checked' : ''}>
            <span>Subtype</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="visibility" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('visibility') ? 'checked' : ''}>
            <span>Visibility %</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="elevation" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('elevation') ? 'checked' : ''}>
            <span>Elevation</span>
          </label>
          <label style="display: flex; align-items: center; gap: 6px; font-weight: 400; cursor: pointer;">
            <input type="checkbox" data-id="${label.id}" data-prop="content" data-content-value="id" 
              ${(Array.isArray(label.content) ? label.content : [label.content]).includes('id') ? 'checked' : ''}>
            <span>Identifier</span>
          </label>
        </div>
      </div>
      
      <div class="ctrlRow">
        <label>Pill Color Mode</label>
        <select data-id="${label.id}" data-prop="pillColorMode">
          <option value="single" ${(label.pillColorMode || 'single') === 'single' ? 'selected' : ''}>Single Color</option>
          <option value="category" ${label.pillColorMode === 'category' ? 'selected' : ''}>Category</option>
          <option value="visibility" ${label.pillColorMode === 'visibility' ? 'selected' : ''}>Visibility %</option>
        </select>
      </div>
      
      ${label.pillColorMode === 'single' ? `
      <div class="ctrlRow">
        <label>Pill Background</label>
        <input type="text" data-id="${label.id}" data-prop="pillBackgroundColor" value="${label.pillBackgroundColor || 'rgba(0,0,0,0.75)'}" placeholder="rgba(0,0,0,0.75)" style="font-size:11px;">
      </div>
      
      <div class="ctrlRow">
        <label>Pill Border</label>
        <input type="text" data-id="${label.id}" data-prop="pillBorderColor" value="${label.pillBorderColor || 'rgba(255,255,255,0.18)'}" placeholder="rgba(255,255,255,0.18)" style="font-size:11px;">
      </div>
      ` : ''}
      
      <div class="ctrlRow">
        <label>Text Color</label>
        <input type="color" data-id="${label.id}" data-prop="pillTextColor" value="${label.pillTextColor || '#ffffff'}">
      </div>
      
      <div class="ctrlRow">
        <label>Font Size</label>
        <input type="number" data-id="${label.id}" data-prop="fontSize" value="${label.fontSize || 12}" step="1" min="8" max="24">
      </div>
      
      <div class="ctrlRow">
        <label>Font</label>
        <select data-id="${label.id}" data-prop="font">
          <option value="helvetica" ${(label.font || 'helvetica') === 'helvetica' ? 'selected' : ''}>Helvetica</option>
          <option value="times" ${label.font === 'times' ? 'selected' : ''}>Times New Roman</option>
          <option value="caslon" ${label.font === 'caslon' ? 'selected' : ''}>Caslon</option>
          <option value="inter" ${label.font === 'inter' ? 'selected' : ''}>Inter</option>
          <option value="manrope" ${label.font === 'manrope' ? 'selected' : ''}>Manrope</option>
          <option value="ibmplex" ${label.font === 'ibmplex' ? 'selected' : ''}>IBM Plex Sans</option>
          <option value="spacegrotesk" ${label.font === 'spacegrotesk' ? 'selected' : ''}>Space Grotesk</option>
          <option value="system" ${label.font === 'system' ? 'selected' : ''}>System UI</option>
        </select>
      </div>
      
      <div class="ctrlRow">
        <label>Padding X</label>
        <input type="number" data-id="${label.id}" data-prop="paddingX" value="${label.paddingX || 10}" step="1" min="0" max="40">
      </div>
      
      <div class="ctrlRow">
        <label>Padding Y</label>
        <input type="number" data-id="${label.id}" data-prop="paddingY" value="${label.paddingY || 8}" step="1" min="0" max="40">
      </div>
      
      ${usesCategoryColors ? `
      <!-- Category Colors -->
      <hr style="border:none;border-top:1px solid rgba(255,255,255,.12);margin:12px 0;">
      <div style="font-weight:700;margin-bottom:8px;">Category Colors</div>
      
      <div class="ctrlRow">
        <label>Landmark</label>
        <input type="color" data-id="${label.id}" data-prop="categoryColors.landmark" value="${label.categoryColors?.landmark || '#ff0000'}">
      </div>
      
      <div class="ctrlRow">
        <label>Leisure</label>
        <input type="color" data-id="${label.id}" data-prop="categoryColors.leisure" value="${label.categoryColors?.leisure || '#00ff00'}">
      </div>
      
      <div class="ctrlRow">
        <label>Amenity</label>
        <input type="color" data-id="${label.id}" data-prop="categoryColors.amenity" value="${label.categoryColors?.amenity || '#0000ff'}">
      </div>
      
      <div class="ctrlRow">
        <label>Place</label>
        <input type="color" data-id="${label.id}" data-prop="categoryColors.place" value="${label.categoryColors?.place || '#ffff00'}">
      </div>
      ` : ''}
      
      <!-- Fade Properties -->
      <hr style="border:none;border-top:1px solid rgba(255,255,255,.12);margin:12px 0;">
      <div style="font-weight:700;margin-bottom:8px;">Distance Fade</div>
      
      <div class="ctrlRow">
        <label>Fade Start (m)</label>
        <input type="number" data-id="${label.id}" data-prop="fadeDistance" value="${label.fadeDistance || 100}" step="10" min="0">
      </div>
      <div class="ctrlRow">
        <label>Fade End (m)</label>
        <input type="number" data-id="${label.id}" data-prop="maxDistance" value="${label.maxDistance || 500}" step="10" min="0">
      </div>
    `;
  }
  
  return '<!-- Unknown label type -->';
}

// Apply all active labels to scene (placeholder - actual implementation depends on rendering system)
function applyAllLabelFX() {
  // Clear all existing callouts
  currentMarkers.forEach(m => {
    if (m.userData?.callout) {
      m.remove(m.userData.callout);
      m.userData.callout = null;
    }
  });

  // Apply each active label config
  activeLabels.forEach(config => {
    applyLabelConfigToMarkers(config);
  });
}

function applyLabelConfigToMarkers(config) {
  // This function is called when Label FX configs change
  // But we don't want to recreate all callouts here - they're created once per marker
  // The actual showing/hiding is handled by updateCalloutsVisibility
  // This function can be used to update global label text/colors if needed in the future
  
  // For now, just ensure all markers have callouts created
  const markers = _getVerifierMarkers();
  
  markers.forEach(m => {
    const cand = m.userData?.cand;
    if (!cand) return;
    
    // If marker doesn't have a callout yet, create one with default config
    if (!m.userData?.callout) {
      const labelConfig = activeLabels.find(l => l.type === 'label');
      const hoverConfig = activeLabels.find(l => l.type === 'hover');
      const useConfig = labelConfig || hoverConfig;
      
      // Resolve line color
      let lineColorHex = null;
      if (useConfig && useConfig.type === 'label' && useConfig.showLine) {
        const lineColorStr = resolveColorForElement(useConfig, cand, 'line');
        lineColorHex = parseInt(lineColorStr.replace('#', ''), 16);
      }
      
      // Build callout with config parameters
      const callout = makeCalloutAnimated(
        m,
        getLabelText(useConfig?.content || ['name'], cand),
        isVisibleCandidate(cand),
        m.userData.colorHex || 0x00c8ff,
        lineColorHex,
        useConfig
      );
    }
  });
}

function getLabelText(contentType, cand) {
  // Handle array of content types (checkbox selections)
  if (Array.isArray(contentType)) {
    const parts = contentType.map(type => {
      switch(type) {
        case 'name': return candidateName(cand);
        case 'category': return safeStr(cand?.dst_type || '');
        case 'subtype': return safeStr(cand?.amenity || cand?.leisure || cand?.place || '');
        case 'visibility': return `${fmt(getCandidateVisPct(cand), 0)}%`;
        case 'distance': return `${fmt(getCandidateDistanceM(cand), 1)}m`;
        case 'bearing': {
          const baseRel = cand?.base_rel_yaw;
          return baseRel !== undefined ? `${fmt(baseRel, 1)}°` : '';
        }
        case 'elevation': {
          const baseElev = cand?.base_elev;
          return baseElev !== undefined ? `${fmt(baseElev, 2)}°` : '';
        }
        case 'id': {
          // ID types: LMID (Landmark ID), osm_id (OpenStreetMap ID), dst_id (Destination ID)
          // LMID uses all-caps per original dataset convention
          const id = cand?.LMID || cand?.osm_id || cand?.dst_id || cand?.id;
          return safeStr(id || '');
        }
        default: return '';
      }
    }).filter(part => part); // Remove empty strings
    return parts.join(' • ');
  }
  
  // Legacy single content type handling
  switch(contentType) {
    case 'name': return candidateName(cand);
    case 'type': return safeStr(cand?.dst_type || '');
    case 'nameAndType': return `${candidateName(cand)} (${safeStr(cand?.dst_type)})`;
    case 'visibility': return `${fmt(getCandidateVisPct(cand), 0)}% visible`;
    case 'distance': return `${fmt(getCandidateDistanceM(cand), 1)}m`;
    case 'full': return `${candidateName(cand)} • ${safeStr(cand?.dst_type)} • ${fmt(getCandidateDistanceM(cand), 1)}m`;
    default: return candidateName(cand);
  }
}

function makeConfiguredLabelSprite(text, worldSize, textColor, bgColor, borderColor, font) {
  // Use existing makePillLabelSprite but with config colors
  const fontStack = FONT_STACKS[font] || FONT_STACKS.helvetica;
  
  // Temporarily update global font stack for rendering
  const oldFont = currentLabelFontStack;
  currentLabelFontStack = fontStack;
  
  // Parse hex from borderColor if needed
  let strokeHex = 0x000000;
  if (borderColor && borderColor.startsWith('#')) {
    strokeHex = parseInt(borderColor.slice(1), 16);
  }
  
  const sprite = makePillLabelSprite(text, worldSize, strokeHex);
  
  // Restore old font
  currentLabelFontStack = oldFont;
  
  return sprite;
}

// Initialize modular label system
function initModularLabelSystem() {
  const addBtn = document.getElementById('addLabelBtn');
  const typeSelector = document.getElementById('labelTypeSelector');
  
  if (addBtn && typeSelector) {
    addBtn.addEventListener('click', () => {
      // Toggle dropdown visibility
      if (typeSelector.style.display === 'none') {
        typeSelector.style.display = 'block';
        addBtn.style.display = 'none';
      }
    });
    
    typeSelector.addEventListener('change', (e) => {
      const type = e.target.value;
      if (type && labelTypeDefaults[type]) {
        addLabelFX(type);
        // Reset dropdown
        e.target.value = '';
        typeSelector.style.display = 'none';
        addBtn.style.display = 'block';
      }
    });
  }
}

function hookMarkerFxUI(){
  const sel = document.getElementById("markerFxSel");
  const cH = document.getElementById("fxHelixColor");
  const cR = document.getElementById("fxRingColor");
  const cB = document.getElementById("fxBirdColor");
  const sp = document.getElementById("fxSpeed");
  const dr = document.getElementById("fxDir");
  const topY = document.getElementById("fxTopY");
  const botY = document.getElementById("fxBotY");
  const rad  = document.getElementById("fxRadius");
  const trn  = document.getElementById("fxTurns");
  const jit  = document.getElementById("fxJitter");
  const flk  = document.getElementById("fxFlock");

  function reapply(){
    for(const m of _getVerifierMarkers()) applyMarkerFxToMarker(m);
  }

  if(sel){
    sel.value = markerFxMode;
    sel.onchange = ()=>{
      markerFxMode = sel.value;
      reapply();
    };
  }
  if(cH) cH.oninput = ()=> markerFxCfg.helixColor = cH.value;
  if(cR) cR.oninput = ()=> markerFxCfg.ringColor  = cR.value;
  if(cB) cB.oninput = ()=> markerFxCfg.birdColor  = cB.value;

  if(sp) sp.oninput = ()=> markerFxCfg.speed = parseFloat(sp.value || "1");
  if(dr) dr.onchange = ()=> markerFxCfg.dir = dr.value;

  if(topY) topY.oninput = ()=>{ markerFxCfg.topY = parseFloat(topY.value||"55"); reapply(); };
  if(botY) botY.oninput = ()=>{ markerFxCfg.botY = parseFloat(botY.value||"-55"); reapply(); };
  if(rad)  rad.oninput  = ()=>{ markerFxCfg.radius = parseFloat(rad.value||"18"); reapply(); };
  if(trn)  trn.oninput  = ()=>{ markerFxCfg.turns  = parseFloat(trn.value||"5"); reapply(); };
  if(jit)  jit.oninput  = ()=> markerFxCfg.jitter = parseFloat(jit.value||"2.2");
  if(flk)  flk.oninput  = ()=> markerFxCfg.flock  = parseFloat(flk.value||"0.35");
}
async function init(){
  setStatus(`Fetching ${JSON_PATH}…`);
  const res = await fetch(JSON_PATH, { cache:'no-store' });
  if (!res.ok) throw new Error(`JSON fetch failed: ${res.status} ${res.statusText}`);
  DATA = await res.json();

  // Overlay system init
  hookOverlayUI();
  hookMarkerFxUI();
  initModularMarkerSystem();
  initModularLabelSystem();

  // Initialize default X marker so it appears in the list
  addMarkerFX('x');

  // Initialize default label
  addLabelFX('hover');


    hookSkyGroundUI();
// Overlay UI hooks
  if (ovOpacity) ovOpacity.addEventListener('input', syncOverlayUI);
  if (ovOn) ovOn.addEventListener('change', ()=> loadOverlayForSource(currentSource()));
  if (ovType) ovType.addEventListener('change', ()=> loadOverlayForSource(currentSource()));
  syncOverlayUI();


  const srcs = Array.isArray(DATA.sources) ? DATA.sources : [];
  SOURCES = srcs.map(s=>({
    type: s.type || 'pano',
    id: s.id,
    yaw_deg: (s.yaw_deg==null ? null : Number(s.yaw_deg)),
    sourcefile: s.sourcefile || s.SourceFile || null,
    image: s.image || null,
    candidates: Array.isArray(s.candidates) ? s.candidates : []
  }))
  .filter(s=>!!s.id)
  .sort((a,b)=>{
    const ta=(a.type==='pano')?0:1;
    const tb=(b.type==='pano')?0:1;
    if (ta!==tb) return ta-tb;
    const na=numericKey(a.id);
    const nb=numericKey(b.id);
    if (na!==nb) return na-nb;
    return String(a.id).localeCompare(String(b.id));
  });

  if (!SOURCES.length){
    setStatus('❌ No sources found in JSON.');
    return;
  }

  buildSourceDropdown();
  await setSourceByIndex(0);

  // set distance slider default to max in this dataset (≤ 2000m cap)
  const maxD = computeMaxDistanceFromData();
  distMaxIn.value = String(maxD);
  distMaxLabel.textContent = `≤ ${distMaxIn.value}m`;

  // if mouse snap enabled on load, force point adjust mode
  if (reticleEnabled() && adjustModeSel.value !== 'point'){
    adjustModeSel.value = 'point';
  }
}

function animate(){
  requestAnimationFrame(animate);
  const _dt = (typeof clock !== 'undefined' && clock) ? clock.getDelta() : 0.016;
  updateMarkerFx(_dt);
  updateCamera();
  updateCalloutAnims();

  
  // animate / control loading circle markers (mode-aware)
  const nowSpin = performance.now();
  const dtSpin = Math.min(0.05, (nowSpin - lastSpinT)/1000);
  lastSpinT = nowSpin;

  markerGroup.children.forEach(m=>{
    const ring = m?.userData?.markerVisual;
    if (!ring || !ring.userData?.isLoadingCircle) return;

    // Modes:
    // - hover: hide loading rings entirely
    // - loading: show + animate (verifier default)
    // - helix: hide loading rings (helix provides its own motion cue)
    if (markerFxMode === "hover" || markerFxMode === "helix"){
      ring.visible = false;
      return;
    }

    // loading mode
    ring.visible = (m !== focusedMarker);

    const base = ring.userData.baseScale || ring.scale;
    const pulse = ring.userData.pulse ?? 0.18;
    const spin  = ring.userData.spin  ?? 1.4;
    const s = 1.0 + pulse * Math.sin(nowSpin * 0.006);
    ring.scale.set(base.x * s, base.y * s, 1);

    if (ring.material) ring.material.rotation = (nowSpin * 0.001) * (Math.PI * 2) * spin;
  });

  // billboard callouts so the leader line stays vertical on screen
  markerGroup.children.forEach(m=>{
    const c = m?.userData?.callout;
    if (!c) return;
    c.quaternion.copy(camera.quaternion);
  });

  // LEGACY: Old label group system replaced by callout system attached to markers
  // labelGroup.children.forEach(lbl=>{
  //   const m = lbl.userData.marker;
  //   if (!m) return;
  //   const dir = m.position.clone().normalize();
  //   lbl.position.copy(dir.multiplyScalar(MARKER_RADIUS - 10));
  // });

  renderer.clear();
  renderer.render(scenePano, camera);
  renderer.render(sceneOverlay, camera);
}


// ================= SKY / GROUND MASK OVERLAY (module-scope) =================
let sgMesh=null, sgTex=null;

function makeSkyGroundMat(){
  return new THREE.ShaderMaterial({
    transparent:true,
    depthWrite:false,
    depthTest:false,
    uniforms:{
      maskTex:{value:null},
      skyColor:{value:new THREE.Color("#9bd7ff")},
      groundColor:{value:new THREE.Color("#f2e8d5")},
      skyAlpha:{value:0.35},
      groundAlpha:{value:0.18},
      skyOn:{value:1.0},
      groundOn:{value:1.0},
      invertMask:{value:0.0},
      feather:{value:0.03},
      enabled:{value:1.0},
    },
    vertexShader:`
      varying vec2 vUv;
      void main(){
        vUv=uv;
        gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
      }`,
    fragmentShader:`
      varying vec2 vUv;
      uniform sampler2D maskTex;
      uniform vec3 skyColor;
      uniform vec3 groundColor;
      uniform float skyAlpha;
      uniform float groundAlpha;
      uniform float skyOn;
      uniform float groundOn;
      uniform float invertMask;
      uniform float feather;
      uniform float enabled;

      void main(){
        if(enabled<0.5) discard;

        float m = texture2D(maskTex, vUv).r;
        if(invertMask>0.5) m = 1.0 - m;

        float f = max(feather, 0.0001);
        float skyMix = smoothstep(0.5 - f, 0.5 + f, m);

        vec3 col = mix(groundColor, skyColor, skyMix);
        float a = mix(groundAlpha*groundOn, skyAlpha*skyOn, skyMix);

        if(a<0.001) discard;
        gl_FragColor = vec4(col, a);
      }`
  });
}

function ensureSkyGroundMesh(){
  if(sgMesh) return;
  const geom = new THREE.SphereGeometry(SPHERE_RADIUS - 0.75, 64, 48);
  geom.scale(-1,1,1);
  const mat = makeSkyGroundMat();
  sgMesh = new THREE.Mesh(geom, mat);sgMesh.renderOrder = 1;
  try{ sgMesh.material.depthTest=false; sgMesh.material.depthWrite=false; }catch(e){}
  scenePano.add(sgMesh);
}

const SKY_MASK_DIR = "./images/Overlays";

function panoStemFromSource(src){
  const fn = (src?.sourcefile || src?.image || "").split(/[\\\/]/).pop() || "";
  return fn ? fn.replace(/\.[^.]+$/, "") : "";
}

function loadSkyMaskForSource(src){
  ensureSkyGroundMesh();
  const stem = panoStemFromSource(src);
  if(!stem) return;
  let url = `${SKY_MASK_DIR}/${stem}_skymask.png`;
  let altUrl = `${SKY_MASK_DIR}/${stem}_sky_mask.png`;

  const loader = new THREE.TextureLoader();
  loader.load(
    url,
    (tex)=>{
      if(sgTex) sgTex.dispose();
      sgTex = tex;
      sgTex.wrapS = sgTex.wrapT = THREE.ClampToEdgeWrapping;
      sgTex.minFilter = THREE.LinearFilter;
      sgTex.magFilter = THREE.LinearFilter;
      sgMesh.material.uniforms.maskTex.value = sgTex;
      sgMesh.material.needsUpdate = true;
    },
    undefined,
    ()=>{ 
        console.warn("[sky_mask] missing primary:", url);
        loader.load(
          altUrl,
          (tex)=>{
            if(sgTex) sgTex.dispose();
            sgTex = tex;
            sgTex.wrapS = sgTex.wrapT = THREE.ClampToEdgeWrapping;
            sgTex.minFilter = THREE.LinearFilter;
            sgTex.magFilter = THREE.LinearFilter;
            sgMesh.material.uniforms.maskTex.value = sgTex;
            sgMesh.material.needsUpdate = true;
            console.warn("[sky_mask] loaded legacy name:", altUrl);
          },
          undefined,
          ()=>{ console.warn("[sky_mask] missing both:", url, altUrl); }
        );
      }
  );
}

function hookSkyGroundUI(){
  const el = (id)=>document.getElementById(id);
  const sgEnable = el("sgEnable");
  const sgSkyOn = el("sgSkyOn");
  const sgGroundOn = el("sgGroundOn");
  const sgSkyColor = el("sgSkyColor");
  const sgGroundColor = el("sgGroundColor");
  const sgSkyAlpha = el("sgSkyAlpha");
  const sgGroundAlpha = el("sgGroundAlpha");
  const sgInvert = el("sgInvert");
  const sgFeather = el("sgFeather");

  if(!sgEnable) return;

  function clamp01(x){
    x = Number(x);
    if(!Number.isFinite(x)) return 0;
    return Math.max(0, Math.min(1, x));
  }

  function apply(){
    ensureSkyGroundMesh();
    const u = sgMesh.material.uniforms;

    u.enabled.value = sgEnable.checked ? 1.0 : 0.0;
    u.skyOn.value = sgSkyOn.checked ? 1.0 : 0.0;
    u.groundOn.value = sgGroundOn.checked ? 1.0 : 0.0;
    u.invertMask.value = sgInvert.checked ? 1.0 : 0.0;

    u.skyColor.value.set(sgSkyColor.value);
    u.groundColor.value.set(sgGroundColor.value);

    u.skyAlpha.value = clamp01(sgSkyAlpha.value);
    u.groundAlpha.value = clamp01(sgGroundAlpha.value);

    u.feather.value = Math.max(0, Math.min(0.2, Number(sgFeather.value) || 0.03));
  }

  ["input","change"].forEach(evt=>{
    [sgEnable,sgSkyOn,sgGroundOn,sgSkyColor,sgGroundColor,sgSkyAlpha,sgGroundAlpha,sgInvert,sgFeather]
      .forEach(x=>x && x.addEventListener(evt, apply));
  });

  apply();
}
// ============================================================================



// --- Edge reopen buttons (hardfix, no guessing) ---
if(!window.__edgeHardInit){
  window.__edgeHardInit = true;

  const edgeLeftBtn  = document.getElementById("edgeReopenLeft");
  const edgeRightBtn = document.getElementById("edgeReopenRight");

  const docks = Array.from(document.querySelectorAll(".dock"));
  const dv = document.getElementById("dockVerifier") || docks[0] || null;
  const dox = document.getElementById("dockOverlay")  || docks[1] || null;

  const applyBodyFlags = ()=>{
    try{
      document.body.classList.toggle("verifier-collapsed", !!dv?.classList.contains("collapsed"));
      document.body.classList.toggle("overlay-collapsed",  !!dox?.classList.contains("collapsed"));
    }catch(e){}
  };

  if(edgeLeftBtn){
    edgeLeftBtn.addEventListener("click", ()=>{
      if(!dv) return;
      dv.classList.remove("collapsed");
      applyBodyFlags();
      window.dispatchEvent(new Event("resize"));
    });
  }
  if(edgeRightBtn){
    edgeRightBtn.addEventListener("click", ()=>{
      if(!dox) return;
      dox.classList.remove("collapsed");
      applyBodyFlags();
      window.dispatchEvent(new Event("resize"));
    });
  }

  // Observe docks for collapse class changes
  try{
    const mo = new MutationObserver(()=>applyBodyFlags());
    if(dv)  mo.observe(dv,  {attributes:true, attributeFilter:["class"]});
    if(dox) mo.observe(dox, {attributes:true, attributeFilter:["class"]});
  }catch(e){}

  // Also wire the dock toggle buttons (if present) so flags update immediately
  try{
    dv?.querySelector(".dockToggle")?.addEventListener("click", ()=>setTimeout(applyBodyFlags, 0));
    dox?.querySelector(".dockToggle")?.addEventListener("click", ()=>setTimeout(applyBodyFlags, 0));
  }catch(e){}

  applyBodyFlags();
}

init().then(()=>animate()).catch(err=>{
  console.error(err);
  setStatus(`❌ ${err.message}`);
});

// ---- EDGE REOPEN (hard sync) ----
(function(){
  const leftDock = document.getElementById('leftDock');
  const rightDock = document.getElementById('rightDock');
  const bL = document.getElementById('edgeReopenLeft');
  const bR = document.getElementById('edgeReopenRight');
  function sync(){
    if(!leftDock||!rightDock||!bL||!bR) return;
    bL.style.display = leftDock.classList.contains('collapsed') ? 'flex' : 'none';
    bR.style.display = rightDock.classList.contains('collapsed') ? 'flex' : 'none';
  }
  // patch toggleDock if present
  try{
    const _toggleDock = window.toggleDock;
    if(typeof _toggleDock === 'function'){
      window.toggleDock = function(which, collapse){
        const r = _toggleDock.apply(this, arguments);
        sync();
        return r;
      };
    }
  }catch(e){}
  // initial + periodic safety sync (covers any later DOM overwrites)
  window.addEventListener('load', ()=>{ sync(); setInterval(sync, 250); }, { once:true });
  // also sync on resize
  window.addEventListener('resize', sync);
})();

</script>

<!-- ================= Overlay Controls ================= -->

<div id="uiOverlay">
  <div id="ovHeader">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
      <b>Overlay</b>
      <button id="ovCollapseBtn" type="button">Collapse</button>
    </div>

    <div class="ovRow">
      <label style="display:flex;align-items:center;gap:8px">
        <input id="toggleOverlay" type="checkbox" checked> Show overlay
      </label>

      <div style="display:flex;gap:8px">
        <button id="exportPngBtn" type="button">Export PNG</button>
        <button id="copySettingsBtn" type="button">Copy settings</button>
        <button id="shareLinkBtn" type="button">Share link</button>
      </div>
    </div>

    <div class="ovRow">
      <span>Overlay file</span>
      <select id="ovType" style="flex:1">
<option value="edges_colour">Colour edges</option>
        <option value="edges_mask">Mask</option>
      </select>
    </div>

    <div class="ovRow">
      <span>Mask file</span>
      <select id="maskKindSel" style="flex:1">
        <option value="edges_mask">Edges mask</option>
        <option value="sky_mask">Sky-only mask</option>
</select>
    </div>
  </div>

  <div id="ovBody">

  <div class="ovSection" style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,.12)">
    <div style="font-weight:800;margin-bottom:8px">Sky / Ground tint</div>

    <div class="ovRow" style="justify-content:space-between;gap:12px;flex-wrap:wrap">
      <label style="display:flex;align-items:center;gap:8px">
        <input id="sgEnable" type="checkbox" checked>
        <span>Enable</span>
      </label>

      <label style="display:flex;align-items:center;gap:8px">
        <input id="sgInvert" type="checkbox">
        <span>Invert</span>
      </label>

      <label style="display:flex;align-items:center;gap:8px">
        <span style="opacity:.75">Feather</span>
        <input id="sgFeather" type="number" step="0.005" min="0" max="0.2" value="0.03" style="width:78px">
      </label>
    </div>

    <div class="ovRow" style="gap:10px;flex-wrap:wrap">
      <label style="display:flex;align-items:center;gap:8px">
        <input id="sgSkyOn" type="checkbox" checked>
        <span>Sky</span>
      </label>
      <input id="sgSkyColor" type="color" value="#9bd7ff">
      <label style="display:flex;align-items:center;gap:6px">
        <span style="opacity:.75">α</span>
        <input id="sgSkyAlpha" type="number" step="0.01" min="0" max="1" value="0.35" style="width:78px">
      </label>
    </div>

    <div class="ovRow" style="gap:10px;flex-wrap:wrap">
      <label style="display:flex;align-items:center;gap:8px">
        <input id="sgGroundOn" type="checkbox" checked>
        <span>Ground</span>
      </label>
      <input id="sgGroundColor" type="color" value="#f2e8d5">
      <label style="display:flex;align-items:center;gap:6px">
        <span style="opacity:.75">α</span>
        <input id="sgGroundAlpha" type="number" step="0.01" min="0" max="1" value="0.18" style="width:78px">
      </label>
    </div>

    <div style="opacity:.65;font-size:12px;line-height:1.2;margin-top:6px">
      Uses <code>images/Overlays/&lt;stem&gt;_skymask.png</code> (white=sky, black=ground)
    </div>
  </div>


    <div class="ovRow">
      <span>Mode</span>
      <select id="modeSel">
        <option value="0">Original overlay colours</option>
        <option value="1">Single colour</option>
        <option value="2">Rules (ranges)</option>
      </select>
    </div>

    <div id="singleGroup" style="display:none">
      <div class="ovRow"><span>Single colour</span><input id="singleColor" type="color" value="#00ffd0"></div>
    </div>

    <div id="rulesGroup" style="display:none">
      <div class="ovSmall">
        Rules are evaluated top → bottom. First match wins.<br>
        Click on the hue bar to jump; drag to fine tune (nearest handle becomes active).
      </div>

      <div class="ovRow" style="margin-top:10px">
        <span>Rules</span>
        <button id="addRuleBtn" type="button">+ Add rule</button>
      </div>

      <div id="rulesPanel"></div>

      <div class="ovSmall">Guards (stop greys/white edges being classified)</div>
      <div class="ovRow"><span>Min saturation</span><div style="display:flex;gap:10px;align-items:center"><input id="minSat" type="range" min="0" max="1" step="0.005" value="0.16"><input id="minSatNum" type="number" min="0" max="1" step="0.005" value="0.16" style="width:76px"></div></div>
      <div class="ovRow"><span>Min value</span><div style="display:flex;gap:10px;align-items:center"><input id="minVal" type="range" min="0" max="1" step="0.005" value="0.10"><input id="minValNum" type="number" min="0" max="1" step="0.005" value="0.10" style="width:76px"></div></div>
    </div>

    <hr class="ovSep"/>

    <div class="ovRow"><span>Overlay opacity</span><div style="display:flex;gap:10px;align-items:center"><input id="overlayOpacity" type="range" min="0" max="1" step="0.005" value="0.65"><input id="overlayOpacityNum" type="number" min="0" max="1" step="0.005" value="0.65" style="width:76px"></div></div>
    <div class="ovRow"><span>Line width</span><div style="display:flex;gap:10px;align-items:center"><input id="lineWidth" type="range" min="0" max="6" step="1" value="0"><input id="lineWidthNum" type="number" min="0" max="6" step="1" value="0" style="width:76px"></div></div>
    <div class="ovRow"><span>Mask threshold</span><div style="display:flex;gap:10px;align-items:center"><input id="maskThresh" type="range" min="0" max="1" step="0.005" value="0.12"><input id="maskThreshNum" type="number" min="0" max="1" step="0.005" value="0.12" style="width:76px"></div></div>
    <div class="ovRow"><span>Pano fade</span><div style="display:flex;gap:10px;align-items:center"><input id="panoFade" type="range" min="0" max="1" step="0.01" value="1"><input id="panoFadeNum" type="number" min="0" max="1" step="0.01" value="1" style="width:76px"></div></div>
    <div class="ovRow"><span>Global background</span><input id="bgColor" type="color" value="#0b0b0b"></div>
<div class="ovRow"><span>Background opacity</span><div style="display:flex;gap:10px;align-items:center"><input id="bgOpacity" type="range" min="0" max="1" step="0.01" value="1"><input id="bgOpacityNum" type="number" min="0" max="1" step="0.01" value="1" style="width:76px"></div></div>

    <div id="ovStatus">Ready.</div>
  </div>

  <div id="ovFooter">
    <div class="ovRow" style="margin-top:0">
      <b>Presets</b>
      <span class="ovMini">always visible</span>
    </div>

    <div class="ovRow">
      <input id="presetName" type="text" placeholder="Name (e.g. Cream + Light Blue)" />
      <button id="savePresetBtn" type="button">Save</button>
    </div>

    <div class="ovRow">
      <select id="presetSel" style="width:100%"></select>
    </div>

    <div class="ovRow">
      <button id="loadPresetBtn" type="button">Load</button>
      <button id="deletePresetBtn" type="button">Delete</button>
      <button id="applySettingsBtn" type="button">Apply JSON</button>
    </div>

    <textarea id="settingsBox" placeholder="Click Copy settings → paste JSON here → Apply JSON"></textarea>
  </div>
</div>

<style>
#uiOverlay{
  position:fixed; top:14px; right:14px; z-index:20;
  width:260px; max-width:calc(100vw - 28px);
  background:rgba(0,0,0,.55);
  border:1px solid rgba(255,255,255,.15);
  border-radius:12px;
  color:#fff;
  padding:12px;
  user-select:none;
}
#uiOverlay select, #uiOverlay input[type="range"]{ accent-color:#fff; }


</style>


<button id="edgeReopenLeft" class="edgeReopen" title="Open verifier">▶</button>
<button id="edgeReopenRight" class="edgeReopen" title="Open overlays">◀</button>

</body>
</html>