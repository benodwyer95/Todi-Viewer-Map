<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Todi Pano Landmark Verifier</title>

<script type="importmap">
{
  "imports": {
    "three": "./node_modules/three/build/three.module.js"
  }
}
</script>

<style>

/* ================= Right Dock ================= */
#rightDock{
  position:fixed;
  top:14px;
  right:14px;
  width:880px;
  max-width:calc(100vw - 28px);
  height:calc(100vh - 28px);
  z-index:60;
  display:flex;
  flex-direction:column;
  background:rgba(0,0,0,.50);
  border:1px solid rgba(255,255,255,.18);
  border-radius:14px;
  overflow:hidden;
  backdrop-filter: blur(8px);
}
#dockTabs{
  display:flex;
  gap:8px;
  align-items:center;
  padding:10px 10px;
  border-bottom:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.35);
}
.dockTab{
  cursor:pointer;
  border:none;
  background:rgba(255,255,255,.10);
  color:#fff;
  padding:8px 14px;
  border-radius:999px;
  font:700 13px/1 Helvetica, Arial, sans-serif;
  opacity:.75;
}
.dockTab.active{ opacity:1; background:rgba(255,255,255,.16); }
.dockIcon{
  cursor:pointer;
  border:none;
  width:34px;
  height:34px;
  border-radius:10px;
  background:rgba(255,255,255,.10);
  color:#fff;
  font:700 14px/1 Helvetica, Arial, sans-serif;
}
#dockBody{ flex:1; display:flex; }
.dockPanel{
  flex:1;
  overflow:hidden;
  display:none;
}
.dockPanel.active{
  display:flex;
  flex-direction:column;
  overflow:hidden;
}

/* mini collapsed launcher */
  position:fixed;
  top:14px;
  right:14px;
  z-index:61;
  display:none;
  gap:8px;
  background:rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.18);
  border-radius:999px;
  padding:6px;
  backdrop-filter: blur(8px);
}
  cursor:pointer;
  border:none;
  background:rgba(255,255,255,.10);
  color:#fff;
  padding:8px 12px;
  border-radius:999px;
  font:700 13px/1 Helvetica, Arial, sans-serif;
}

#rightDock.dock-collapsed{ display:none; }

/* override legacy absolute positioning so panels can live inside dock */
#dockPanelVerifier #ui,
#dockPanelOverlay #uiOverlay{
  position:static !important;
  top:auto !important; left:auto !important; right:auto !important; bottom:auto !important;
  width:100% !important;
  max-width:none !important;
  max-height:none !important;
  height:100% !important;
  border:none !important;
  border-radius:0 !important;
  background:transparent !important;
}
#dockPanelVerifier #ui{ display:flex; flex-direction:column; overflow:hidden; }
#dockPanelVerifier #uiBody{ overflow:auto; }
#dockPanelVerifier #uiFooter{ overflow:auto; }

#dockPanelOverlay #uiOverlay{ display:flex; flex-direction:column; overflow:hidden; }
#dockPanelOverlay #ovBody{ overflow:auto; }



/* ================= Overlay panel (ported) ================= */

#uiOverlay{
  position:relative; top:60px; right:14px; z-index:20;
  width:640px;
  max-width:calc(100vw - 28px);
  max-height:calc(100vh - 88px);
  background:rgba(0,0,0,.55);
  border:1px solid rgba(255,255,255,.15);
  border-radius:12px;
  color:#fff;
  user-select:none;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  pointer-events:auto;
}
#ovHeader{padding:12px 12px 8px 12px;}
#ovBody{padding:0 12px 0 12px; overflow:hidden; overflow-y:auto;}
#ovFooter{
  padding:10px 12px 12px 12px;
  border-top:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.30);
}

.ovRow{display:flex;justify-content:space-between;align-items:center;margin:7px 0;font-size:13px;gap:10px}
.ovSmall{font-size:11px;opacity:.82;line-height:1.25}
.ovMini{font-size:11px;opacity:.82;line-height:1.2}
hr.ovSep{border:none;border-top:1px solid rgba(255,255,255,.12);margin:10px 0}

#uiOverlay input[type=range]{width:420px}
#uiOverlay input[type=color]{width:44px;height:26px;border:none;background:none}
#uiOverlay input[type=text]{width:260px}
#uiOverlay select,#uiOverlay button,#uiOverlay textarea{
  background:rgba(255,255,255,.1);
  border:1px solid rgba(255,255,255,.2);
  color:#fff;border-radius:8px;padding:6px 8px;font-size:12px
}
#uiOverlay option{color:#000}
#uiOverlay button{cursor:pointer}
#uiOverlay button:disabled{opacity:.5;cursor:not-allowed}
#uiOverlay textarea{
  width:100%;
  height:92px;
  resize:vertical;
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace
}

/* rules panel */
#rulesPanel{
  border:1px solid rgba(255,255,255,.12);
  border-radius:10px;
  background:rgba(255,255,255,.04);
  padding:10px;
  margin:10px 0 8px 0;
  max-height:240px;
  overflow-y:auto;
}
#rulesPanel::-webkit-scrollbar{width:10px}
#rulesPanel::-webkit-scrollbar-thumb{background:rgba(255,255,255,.18);border-radius:999px}
#rulesPanel::-webkit-scrollbar-track{background:rgba(255,255,255,.06);border-radius:999px}

/* rule card */
.rule{
  border:1px solid rgba(255,255,255,.12);
  border-radius:10px;
  padding:10px;
  background:rgba(0,0,0,.18);
  margin-bottom:10px;
}
.rule:last-child{margin-bottom:0}
.ruleHead{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:8px}
.ruleHead b{font-size:12px}
.ruleBtns{display:flex;gap:8px;align-items:center}
.ruleGrid{
  display:grid;
  grid-template-columns: 100px 1fr 110px;
  gap:8px 10px;
  align-items:center;
  font-size:12px;
}
.ruleGrid .lbl{opacity:.85}
.ruleGrid .right{justify-self:end}
.mini{font-size:11px;opacity:.82;line-height:1.2}

/* Hue picker */
.huePicker{position:relative;height:18px;margin-top:6px;cursor:pointer;}
.hueTrack{
  position:absolute; inset:0;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.18);
  background:linear-gradient(to right,
    rgb(255,0,0), rgb(255,255,0), rgb(0,255,0),
    rgb(0,255,255), rgb(0,0,255), rgb(255,0,255), rgb(255,0,0)
  );
}
.hueHandle{
  position:absolute;
  top:-3px;
  width:6px;
  height:24px;
  background:#fff;
  border:1px solid #000;
  border-radius:2px;
  cursor:ew-resize;
  box-shadow:0 0 0 1px rgba(255,255,255,.25);
  transform:translateX(-50%);
}
.hueHandle.active{
  box-shadow:0 0 0 2px rgba(255,255,255,.55), 0 0 0 1px rgba(0,0,0,.9) inset;
}
.hueSwatches{display:flex;gap:8px;margin-top:6px;align-items:center;}
.hueSwatch{width:22px;height:22px;border-radius:50%;border:1px solid rgba(255,255,255,.25);}
.hueSwatchLabel{font-size:11px;opacity:.82}
#ovStatus{font-size:11px;opacity:.85;margin-top:8px;line-height:1.25;white-space:pre-wrap}

/* collapsed */
#uiOverlay.collapsed #ovBody,
#uiOverlay.collapsed #ovFooter{ display:none; }


  html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:Arial,Helvetica,sans-serif}
  #app{position:fixed;inset:0}
  canvas{display:block}

  #ui{
    position:relative;top:14px;left:14px;z-index:10;
    width:760px;max-width:calc(100vw - 28px);
    background:rgba(0,0,0,.60);
    border:1px solid rgba(255,255,255,.16);
    border-radius:12px;color:#fff;user-select:none;overflow:hidden;
    display:flex;flex-direction:column;backdrop-filter: blur(6px);
  }
  #uiHeader{padding:12px 12px 10px 12px;border-bottom:1px solid rgba(255,255,255,.10);}
  #uiTitle{font-weight:800;letter-spacing:.5px;font-size:14px;opacity:.95}
  #uiSub{margin-top:4px;font-size:12px;opacity:.75;line-height:1.25}
  #uiBody{padding:10px 12px 12px 12px;display:flex;flex-direction:column;gap:10px}
  #row1{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  select,button,input,label{
    border-radius:10px;border:1px solid rgba(255,255,255,.16);
    background:rgba(0,0,0,.40); color:#fff;
    padding:8px 10px; font-size:12px; outline:none;
  }
  label{display:inline-flex;gap:8px;align-items:center;cursor:pointer}
  label input{border:none;background:transparent;padding:0;margin:0}
  button{cursor:pointer}
  button:hover{border-color:rgba(255,255,255,.28)}
  button:active{transform:translateY(1px)}
  .btnSmall{padding:8px 10px}
  .grow{flex:1;min-width:260px}
  #row2{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .pill{
    font-size:11px;opacity:.85;border:1px solid rgba(255,255,255,.16);
    padding:6px 8px;border-radius:999px;display:inline-flex;gap:8px;align-items:center;
    background:rgba(0,0,0,.35)
  }
  .pill b{font-weight:800;opacity:.95}
  .muted{opacity:.7}

  #list{
    margin-top:6px;border:1px solid rgba(255,255,255,.12);
    border-radius:12px;overflow:hidden;max-height:44vh;overflow-y:auto;
  }
  .item{
    padding:10px 10px;border-bottom:1px solid rgba(255,255,255,.08);
    display:flex;gap:10px;align-items:flex-start;cursor:pointer;
  }
  .item:last-child{border-bottom:none}
  .item:hover{background:rgba(255,255,255,.06)}
  .item.sel{background:rgba(255,255,255,.12)}
  .item .left{min-width:38px;text-align:right;opacity:.65;font-size:11px;padding-top:1px}
  .item .main{flex:1}
  .item .name{font-weight:800;font-size:12px;line-height:1.15}
  .item .meta{margin-top:3px;font-size:11px;opacity:.8;display:flex;flex-wrap:wrap;gap:8px}
  .tag{padding:2px 6px;border:1px solid rgba(255,255,255,.16);border-radius:999px;opacity:.9}
  #status{font-size:11px;opacity:.85;margin-top:8px;line-height:1.25}

  #tip{
    position:fixed;z-index:20;pointer-events:none;transform:translate(10px,10px);
    padding:8px 10px;background:rgba(0,0,0,.75);
    border:1px solid rgba(255,255,255,.18);border-radius:10px;
    color:#fff;font-size:12px;max-width:340px;display:none;backdrop-filter: blur(6px);
  }
  #tip .t1{font-weight:800;margin-bottom:2px}
  #tip .t2{font-size:11px;opacity:.85}

  /* --- Mouse magnifier reticle (overlay DOM) --- */
  #reticleWrap{
    position:fixed;z-index:200;pointer-events:none;
    width:160px;height:160px;display:none;
    transform:translate(-80px,-80px);
  }
  #reticle{
    position:absolute;inset:0;
    border:2px solid rgba(255,255,255,.85);
    border-radius:10px;
    box-shadow:0 0 0 1px rgba(0,0,0,.55), 0 0 14px rgba(0,0,0,.45);
    overflow:hidden;
    background:rgba(0,0,0,.15);
    backdrop-filter: blur(0px);
  }
  #reticle::before{
    content:"";
    position:absolute;left:50%;top:0;bottom:0;width:1px;
    background:rgba(255,255,255,.55);
    transform:translateX(-0.5px);
  }
  #reticle::after{
    content:"";
    position:absolute;top:50%;left:0;right:0;height:1px;
    background:rgba(255,255,255,.55);
    transform:translateY(-0.5px);
  }
  #reticleInner{
    position:absolute;left:50%;top:50%;
    width:28px;height:28px;
    transform:translate(-50%,-50%);
    border:2px solid rgba(255,255,255,.95);
    border-radius:6px;
    box-shadow:0 0 0 1px rgba(0,0,0,.55);
  }
  #reticleMeta{
    position:absolute;left:6px;right:6px;bottom:6px;
    font-size:10px;opacity:.92;line-height:1.2;
    text-shadow:0 1px 2px rgba(0,0,0,.65);
    display:flex;justify-content:space-between;gap:8px;
  }
  #reticleMeta span{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  #reticleHint{
    position:absolute;left:6px;right:6px;top:6px;
    font-size:10px;opacity:.85;line-height:1.2;
    text-shadow:0 1px 2px rgba(0,0,0,.65);
  }

  #warn{
    position:fixed;inset:0;z-index:999;
    display:none;align-items:center;justify-content:center;
    background:rgba(0,0,0,.92);color:#fff;padding:20px;
  }
  #warnBox{
    width:min(720px,94vw);
    border:1px solid rgba(255,255,255,.18);
    border-radius:14px;padding:18px;background:rgba(255,255,255,.05);
  }
  #warnBox code{
    display:block;margin-top:8px;padding:10px 12px;border-radius:10px;
    background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.12);
    white-space:pre-wrap;
  }

  /* --- Tiny colored swatch for list items --- */
  .swatch{
    width:10px;height:10px;border-radius:999px;
    margin-top:3px;flex:0 0 auto;
    border:1px solid rgba(255,255,255,.25);
    box-shadow:0 0 0 1px rgba(0,0,0,.45);
  }

/* verifier collapse */
#ui.collapsed #uiBody, #ui.collapsed #uiFooter{ display:none !important; }
#ui.collapsed{ width:320px; }


/* ===== Dual dock layout (Verifier left, Overlay right) ===== */
.dock{ position:fixed; top:10px; bottom:10px;
  width:620px;
  background:rgba(0,0,0,.55);
  border:1px solid rgba(255,255,255,.14);
  border-radius:14px;
  color:#fff;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  z-index:20;
  backdrop-filter: blur(6px);
}
#leftDock{ left:10px; }
#rightDock{ right:10px; }

.dockHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:10px 10px 8px 10px;
  border-bottom:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.35);
}
.dockTabs{ display:flex; gap:8px; }
.dockTabs .tab{
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(0,0,0,.35);
  color:#fff;
  font-size:12px;
}
.dockTabs .tab.active{ background:rgba(255,255,255,.10); }
.dockActions{ display:flex; gap:8px; align-items:center; }
.dockBtn{
  width:30px;height:26px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(0,0,0,.35);
  color:#fff;
  cursor:pointer;
}

.dockBody{
  flex:1;
  overflow:auto;
  padding:10px;
}

/* collapse */
.dock.collapsed{display:none !important;}
.dock.collapsed *{ display:none !important; }
#leftDock.collapsed{ left:0 !important; }
#rightDock.collapsed{ right:0 !important; }
.dock.collapsed .dockBody{ display:none !important; }
.dock.collapsed .dockTabs{ display:none !important; }
.dock.collapsed .dockBody{ display:none; }
.dock.collapsed .dockTabs{ display:none; }

/* Make overlay ranges responsive in dock */
#uiOverlay input[type=range]{ width:100% !important; }

/* ---- Fix: wide verifier, proper overlay mounting ---- */
#leftDock{ width:680px !important; }
#rightDock{ width:560px !important; }
.dockBody{ overflow-x:hidden !important; }

/* force panels to live inside docks (no fixed positioning) */
#ui, #uiOverlay{
  position:relative !important;
  inset:auto !important;
  top:auto !important; left:auto !important; right:auto !important; bottom:auto !important;
  width:100% !important;
  max-width:none !important;
  margin:0 !important;
}

/* --- Overlay color swatches --- */
.ovRow{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:6px 0;}
.ovRow > span{min-width:140px;opacity:.92;}
.ovRow input[type="color"]{
  width:48px;height:24px;padding:0;border:none;border-radius:6px;
  background:transparent;cursor:pointer;box-shadow: inset 0 0 0 1px rgba(255,255,255,.22);
}
.ovRow input[type="color"]::-webkit-color-swatch-wrapper{padding:0;border-radius:6px;}
.ovRow input[type="color"]::-webkit-color-swatch{border:none;border-radius:6px;}

/* Edge reopen buttons (visible only when dock collapsed) */
.edgeReopen{
  position:fixed;
  top:50%;
  transform:translateY(-50%);
  width:30px;height:54px;
  display:flex;
  align-items:center;justify-content:center;
  background:rgba(0,0,0,.60);
  border:1px solid rgba(255,255,255,.22);
  border-radius:12px;
  color:#fff;
  cursor:pointer;
  user-select:none;
  z-index:100000;
  backdrop-filter: blur(8px);
  font-weight:900;
  opacity:0;
  pointer-events:none;
  transition: opacity .12s ease;
}
body.verifier-collapsed #edgeReopenLeft{ opacity:1; pointer-events:auto; }
body.overlay-collapsed  #edgeReopenRight{ opacity:1; pointer-events:auto; }
#edgeReopenLeft{ left:8px; }
#edgeReopenRight{ right:8px; }


/* --- Edge reopen buttons (appear only when docks collapsed) --- */

/* --- EDGE REOPEN (hard) --- */

#edgeReopenLeft{ left:10px !important; }
#edgeReopenRight{ right:10px !important; }

.edgeReopenBtn:hover{ transform: scale(1.04); }
#edgeReopenLeft{ left:10px; }
#edgeReopenRight{ right:10px; }
body.verifier-collapsed #edgeReopenLeft{ opacity:1; pointer-events:auto; }
body.overlay-collapsed  #edgeReopenRight{ opacity:1; pointer-events:auto; }


/* === CLEAN EDGE REOPEN === */
.edgeReopen{
  position:fixed;
  top:50%;
  transform:translateY(-50%);
  width:34px;
  height:64px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,.65);
  border:1px solid rgba(255,255,255,.25);
  border-radius:12px;
  color:#fff;
  cursor:pointer;
  z-index:999999;
  backdrop-filter: blur(8px);
  font-weight:900;
  opacity:0;
  pointer-events:none;
}
body.verifier-collapsed #edgeReopenLeft{opacity:1;pointer-events:auto;}
body.overlay-collapsed #edgeReopenRight{opacity:1;pointer-events:auto;}
#edgeReopenLeft{left:8px;}
#edgeReopenRight{right:8px;}

</style>
</head>
<body>


<div id="leftDock" class="dock">
  <div class="dockHeader">
    <div class="dockTabs">
      <button class="tab active">Verifier</button>
    </div>
    <div class="dockActions">
      <button id="leftCollapseBtn" class="dockBtn" title="Collapse">⟨</button>
    </div>
  </div>
  <div id="leftDockBody" class="dockBody"></div>
</div>

<div id="rightDock" class="dock">
  <div class="dockHeader">
    <div class="dockTabs">
      <button class="tab active">Overlay</button>
    </div>
    <div class="dockActions">
      <button id="rightCollapseBtn" class="dockBtn" title="Collapse">⟩</button>
    </div>
  </div>
  <div id="rightDockBody" class="dockBody"></div>
</div>
<!-- ================= Right Dock (Verifier / Overlay) ================= -->

<!-- removed duplicate rightDock -->

    <div id="dockPanelOverlay" class="dockPanel"></div>
  </div>
</div>

</div>


<div id="app"></div>

<div id="ui">
  <div id="uiHeader">
  <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
    <div style="font-weight:700;">Verifier</div>
    
  </div>

    <div id="uiTitle">Todi Pano • Landmark Alignment Verifier</div>
    <div id="uiSub">
      Uses <b>rel_bear</b> + <b>elev_ang_d</b>. Images load by DJI basename from <b>sourcefile</b>.
      Markers render in an <b>overlay scene</b> so they can’t hide behind the pano.
      <span class="muted">Z offset (m) applies: elev += atan2(z_m, dist_m). Per-point offsets are stored per pano+candidate.</span>
    </div>
  <div class="row" style="margin-top:8px;gap:10px;align-items:center;">
    <span class="muted" style="min-width:54px;">Source</span>
    <select id="sourceSelect" style="flex:1;"></select>
  </div>

    <div id="status">Loading…</div>
  </div>

  <div id="uiBody">
  <div style="margin:10px 0 12px 0; padding:10px; border:1px solid rgba(255,255,255,.12); border-radius:12px; background:rgba(255,255,255,.04)">
    
<div class="sec">
  <div class="secTitle">Marker FX</div>

  <div class="row">
    <label>Style</label>
    <select id="markerFxSel">
      <option value="hover">Hover only</option>
      <option value="loading">Loading rings</option>
      <option value="helix">Helix (starlings)</option>
      <option value="ring">Ground ring</option>
      <option value="halo">Bird halo</option>
      <option value="birdshape">Bird shape</option>
      <option value="combo">Combo (helix+ring+halo)</option>
    </select>
  </div>

  <div class="row">
    <label>Top Y</label>
    <input id="fxTopY" type="number" step="1" value="55"/>
  </div>

  <div class="row">
    <label>Bottom Y</label>
    <input id="fxBotY" type="number" step="1" value="-55"/>
  </div>

  <div class="row">
    <label>Radius</label>
    <input id="fxRadius" type="number" step="1" value="18"/>
  </div>

  <div class="row">
    <label>Turns</label>
    <input id="fxTurns" type="number" step="0.5" value="5"/>
  </div>

  <div class="row">
    <label>Jitter</label>
    <input id="fxJitter" type="number" step="0.1" value="2.2"/>
  </div>

  <div class="row">
    <label>Flockiness</label>
    <input id="fxFlock" type="number" step="0.05" value="0.35"/>
  </div>

  <div class="row">
    <label>Speed</label>
    <input id="fxSpeed" type="number" step="0.05" value="1.00"/>
  </div>

  <div class="row">
    <label>Direction</label>
    <select id="fxDir">
      <option value="cw">Clockwise</option>
      <option value="ccw">Counter-clockwise</option>
    </select>
  </div>

  <div class="row">
    <label>Helix</label>
    <input id="fxHelixColor" type="color" value="#7efcff"/>
  </div>

  <div class="row">
    <label>Ring</label>
    <input id="fxRingColor" type="color" value="#b6ff6a"/>
  </div>

  <div class="row">
    <label>Bird</label>
    <input id="fxBirdColor" type="color" value="#ffffff"/>
  </div>

  <div class="hint" style="opacity:.8;margin-top:8px;line-height:1.35">
    Helix uses a noisy flow field so it “flutters” like a murmuration rather than a perfect spiral.
    Use Top/Bottom/Radius to tighten the whole effect.
  </div>
</div>


    <div id="row2">
      <span class="pill"><b>Type</b> <span id="srcType">—</span></span>
      <span class="pill"><b>ID</b> <span id="srcId">—</span></span>
      <span class="pill"><b>Yaw</b> <span id="srcYaw">—</span></span>
      <span class="pill"><b>Yaw off</b> <span id="srcOff">—</span></span>
      <span class="pill"><b>Z off</b> <span id="srcZ">—</span></span>
      <span class="pill"><b>Sel</b> <span id="selId">—</span></span>
      <span class="pill"><b>Markers</b> <span id="srcMk">—</span></span>
    </div>

    <!-- Placement / QA controls -->
    <div id="row2">
      <span class="pill"><b>Adjust mode</b>
        <select id="adjustMode" style="padding:6px 8px">
          <option value="global" selected>Global (pano)</option>
          <option value="point">Selected point</option>
        </select>
      </span>

      <span class="pill"><b>Place</b>
        <select id="placeMode" style="padding:6px 8px">
          <option value="arrows" selected>Arrows only</option>
          <option value="mouse">Mouse snap</option>
          <option value="both">Mouse + arrows</option>
        </select>
      </span>

      <span class="pill"><b>Auto-next</b>
        <label style="border:none;background:transparent;padding:0">
          <input id="autoNext" type="checkbox" checked style="accent-color:#fff">
          after click
        </label>
      </span>

      <button id="nudgeLeft"  class="btnSmall" title="Yaw -">◀</button>
      <button id="nudgeRight" class="btnSmall" title="Yaw +">▶</button>
      <button id="nudgeUp"    class="btnSmall" title="Pitch +">▲</button>
      <button id="nudgeDown"  class="btnSmall" title="Pitch -">▼</button>

      <span class="pill"><b>Yaw step</b>
        <select id="yawStepPreset" style="padding:6px 8px">
          <option value="5">5</option>
          <option value="2">2</option>
          <option value="1" selected>1</option>
          <option value="0.5">0.5</option>
          <option value="0.01">0.01</option>
        </select>
        <span class="muted">deg</span>
      </span>

      <span class="pill"><b>Pitch step</b>
        <input id="pitchStep" type="number" value="0.25" min="0.01" step="0.01" style="width:80px;padding:6px 8px">
        <span class="muted">deg</span>
      </span>

      <button id="resetAdj" class="btnSmall">Reset (mode)</button>
    </div>

    <!-- Z controls (global or per-point via adjust mode) -->
    <div id="row2">
      <button id="zDown" class="btnSmall">⬇ Z -</button>
      <button id="zUp"   class="btnSmall">⬆ Z +</button>

      <span class="pill"><b>Z step</b>
        <select id="zStepPreset" style="padding:6px 8px">
          <option value="5">5</option>
          <option value="2">2</option>
          <option value="1">1</option>
          <option value="0.5">0.5</option>
          <option value="0.01">0.01</option>
        </select>
        <span class="muted">m</span>
      </span>

      <button id="zZero" class="btnSmall">Reset Z (mode)</button>

      <span class="muted" style="font-size:11px">
        Tip: point Z is best for DSM/DTM + pano height mismatch, global Z for systematic sensor height bias.
      </span>
    </div>

    <!-- Filtering -->
    <div id="row2">
      <span class="pill"><b>Visibility</b>
        <select id="visFilter" style="padding:6px 8px">
          <option value="any" selected>All</option>
          <option value="visible">Visible</option>
          <option value="not_visible">Not visible</option>
        </select>
      </span>

      <span class="pill"><b>Category</b>
        <select id="categoryFilter" style="padding:6px 8px">
          <option value="all" selected>All</option>
          <option value="building">Buildings</option>
          <option value="amenity">Amenities</option>
          <option value="leisure">Leisure</option>
          <option value="place">Places</option>
        </select>
      </span>

      <span class="pill"><b>Landmarks</b>
        <select id="landmarkFilter" style="padding:6px 8px">
          <option value="any" selected>All</option>
          <option value="landmarks_all">Only landmarks</option>
          <option value="landmarks_buildings">Landmarks: buildings</option>
          <option value="landmarks_leisure">Landmarks: leisure</option>
          <option value="landmarks_places">Landmarks: places</option>
          <option value="non_landmarks">Non-landmarks</option>
        </select>
      </span>

      <span class="pill"><b>Distance</b>
        <input id="distMax" type="range" min="0" max="2000" step="25" value="2000" style="width:220px;padding:0">
        <span id="distMaxLabel" class="muted">≤ 2000m</span>
      </span>

      <span class="pill"><b>Top</b>
        <input id="topN" type="number" value="25" min="1" max="200" step="1" style="width:80px;padding:6px 8px">
      </span>

      <span class="pill"><b>Min vis%</b>
        <input id="minVis" type="number" value="0" min="0" max="100" step="1" style="width:80px;padding:6px 8px">
      </span>
    </div>

    <!-- Visual options -->
    <div id="row2">
      <span class="pill"><b>Marker size</b><span class="muted">world</span>
        <input id="mWorld" type="number" value="18" min="4" max="80" step="1" style="width:80px;padding:6px 8px">
      </span>

      <span class="pill"><b>Exposure</b>
        <input id="exposure" type="number" value="1.0" min="0.6" max="1.6" step="0.05" style="width:80px;padding:6px 8px">
      </span>

      <span class="pill">
        <label style="border:none;background:transparent;padding:0">
          <input id="showLabels" type="checkbox" style="accent-color:#fff">
          Show labels
        </label>
      </span>

      <span class="pill">
        <label style="border:none;background:transparent;padding:0">
          <input id="callouts" type="checkbox" checked style="accent-color:#fff">
          Callout preview
        </label>
      </span>

      <span class="pill">
        <label style="border:none;background:transparent;padding:0">
          <input id="allCallouts" type="checkbox" style="accent-color:#fff">
          All callouts
        </label>
      </span>

      <span class="pill">
        <label style="border:none;background:transparent;padding:0">
          <input id="debugDot" type="checkbox" checked style="accent-color:#fff">
          Debug dot
        </label>
      </span>
    </div>

    <!-- Callout tuning -->
    <div id="row2">
      <span class="pill"><b>Rise</b><span class="muted">world</span>
        <input id="riseWorld" type="number" value="40" min="5" max="140" step="1" style="width:80px;padding:6px 8px">
      </span>
      <span class="pill"><b>Square</b><span class="muted">world</span>
        <input id="sqWorld" type="number" value="6" min="2" max="18" step="1" style="width:80px;padding:6px 8px">
      </span>
      <span class="pill"><b>Label</b><span class="muted">world</span>
        <input id="lblWorld" type="number" value="18" min="6" max="60" step="1" style="width:80px;padding:6px 8px">
      </span>
      <span class="pill"><b>Font</b><span class="muted">labels</span>
        <select id="fontSel" style="width:160px;padding:6px 8px">
          <option value="helvetica" selected>Helvetica</option>
          <option value="inter">Inter</option>
          <option value="manrope">Manrope</option>
          <option value="ibmplex">IBM Plex Sans</option>
          <option value="spacegrotesk">Space Grotesk</option>
          <option value="system">System UI</option>
        </select>
      </span>

      <span class="pill"><b>Anim sec</b><span class="muted">0→1</span>
        <input id="animSeconds" type="number" value="1.80" min="0.20" max="10.00" step="0.05" style="width:80px;padding:6px 8px">
      </span>
      <span class="pill">
        <label style="border:none;background:transparent;padding:0">
          <input id="loopCallout" type="checkbox" style="accent-color:#fff">
          Loop callout
        </label>
      </span>

      <span class="muted" style="font-size:11px">
        (Preview matches your end animation: square → line → square → HELVETICA CAPS 11.)

      <span class="pill"><b>Anim</b><span class="muted">sec</span>
        <input id="animSeconds" type="number" value="1.8" min="0.4" max="10" step="0.1" style="width:80px;padding:6px 8px">
      </span>
      <span class="pill">
        <label style="border:none;background:transparent;padding:0">
          <input id="loopCallout" type="checkbox" style="accent-color:#fff">
          Loop callout
        </label>
      </span>

      </span>
    </div>

    <!-- Export / Import -->
    <div id="row2">
      <button id="exportOffsets" class="btnSmall">Export offsets</button>
      <label class="btnSmall" style="padding:0;border:none;background:transparent">
        <input id="importOffsets" type="file" accept=".json" style="width:260px">
      </label>
      <span class="muted" style="font-size:11px">
        Exports/imports: global yaw+Z per pano + per-point yaw/pitch/Z per pano.
      </span>
    </div>

    <div id="list"></div>
  </div>
</div>

<div id="tip">
  <div class="t1" id="tipTitle">—</div>
  <div class="t2" id="tipMeta">—</div>
</div>

<!-- Reticle overlay -->
<div id="reticleWrap">
  <div id="reticle">
    <div id="reticleHint">Mouse snap: move to target → click to lock</div>
    <div id="reticleInner"></div>
    <div id="reticleMeta">
      <span id="reticleA">yaw —</span>
      <span id="reticleB">pitch —</span>
    </div>
  </div>
</div>

<div id="warn">
  <div id="warnBox">
    <div style="font-weight:900;font-size:16px;letter-spacing:.4px;">You opened this via <code>file://</code></div>
    <div class="muted" style="margin-top:8px;line-height:1.35">
      Browsers block JSON + images under <code>file://</code>. Serve the folder over HTTP.
    </div>
    <div style="margin-top:12px;font-weight:900">Run this in CMD:</div>
    <code>cd /d "E:\Portent Maps\Italy\Todi\Viewer"
npx http-server . -a 127.0.0.1 -p 8000 -c-1</code>
    <div style="margin-top:10px;font-weight:900">Then open:</div>
    <code>http://127.0.0.1:8000/index.html</code>
  </div>
</div>

<script type="module">

// --------------------
// Dual dock bootstrap: mount UIs into left/right docks
// --------------------
(function(){
  const mount = ()=>{
    const ui = document.getElementById("ui");
    const ov = document.getElementById("uiOverlay");
    const leftBody = document.getElementById("leftDockBody");
    const rightBody= document.getElementById("rightDockBody");
    if (ui && leftBody && ui.parentElement !== leftBody) leftBody.appendChild(ui);
    if (ov && rightBody && ov.parentElement !== rightBody) rightBody.appendChild(ov);

    // collapse buttons + edge reopen buttons
    const leftDock  = document.getElementById("leftDock");
    const rightDock = document.getElementById("rightDock");
    const lbtn = document.getElementById("leftCollapseBtn");
    const rbtn = document.getElementById("rightCollapseBtn");

    const ensureEdgeButtons = ()=>{
      if (window.__edgeButtonsInit) return;
      window.__edgeButtonsInit = true;

      const mk = (id, side)=>{
        const b = document.createElement("button");
        b.id = id;
        b.className = "edgeReopen";
        b.type = "button";
        b.title = side === "left" ? "Reopen Verifier" : "Reopen Overlay";
        b.textContent = side === "left" ? "›" : "‹";
        b.addEventListener("click", ()=>{
          if (side === "left" && leftDock){
            leftDock.classList.remove("collapsed");
            if (lbtn) lbtn.textContent = "⟨";
          }
          if (side === "right" && rightDock){
            rightDock.classList.remove("collapsed");
            if (rbtn) rbtn.textContent = "⟩";
          }
          applyBodyFlags();
        });
        document.body.appendChild(b);
      };

      mk("edgeReopenLeft","left");
      mk("edgeReopenRight","right");
    };

    const applyBodyFlags = ()=>{
      const body = document.body;
      const lc = !!(leftDock && leftDock.classList.contains("collapsed"));
      const rc = !!(rightDock && rightDock.classList.contains("collapsed"));
      body.classList.toggle("verifier-collapsed", lc);
      body.classList.toggle("overlay-collapsed",  rc);
    };

    ensureEdgeButtons();
    applyBodyFlags();

    if (lbtn && leftDock){
      lbtn.addEventListener("click", ()=>{
        leftDock.classList.toggle("collapsed");
        lbtn.textContent = leftDock.classList.contains("collapsed") ? "⟩" : "⟨";
        applyBodyFlags();
      });
    }
    if (rbtn && rightDock){
      rbtn.addEventListener("click", ()=>{
        rightDock.classList.toggle("collapsed");
        rbtn.textContent = rightDock.classList.contains("collapsed") ? "⟨" : "⟩";
        applyBodyFlags();
      });
    }
  };
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", mount);
  else mount();

  // Wire overlay Collapse button (from overlay panel) to right dock collapse
  try{
    const ovBtn = document.getElementById("ovCollapseBtn");
    const rightDock = document.getElementById("rightDock");
    if (ovBtn && rightDock){
      ovBtn.addEventListener("click", (e)=>{
        e.preventDefault();
        rightDock.classList.toggle("collapsed");
      });
    }
  }catch(e){}
})();

import * as THREE from 'three';

if (location.protocol === 'file:') {
  document.getElementById('warn').style.display = 'flex';
  throw new Error("Opened via file:// — use http://127.0.0.1:8000/index.html");
}

// --------------------
// Config
// --------------------
const JSON_PATH = './pano_candidates_within2km_ALLTYPES__BAKED_OFFSETS.json';
const SPHERE_RADIUS = 500;
const MARKER_RADIUS = SPHERE_RADIUS - 1.5;
const MAX_PITCH_DEG = 85;

// --------------------
// Helpers
// --------------------
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const norm360 = (d)=>((d%360)+360)%360;
const normType = (t)=>String(t||'').trim().toLowerCase();

function numericKey(id){
  const m = String(id).match(/(\d+)/);
  return m ? parseInt(m[1],10) : 999999;
}
function fmt(n, d=2){
  if (n==null || !Number.isFinite(n)) return '—';
  return n.toFixed(d);
}
function safeStr(x){ return (x==null) ? '' : String(x); }
function upperSafe(s){ return safeStr(s).toUpperCase(); }

// yaw 0 => forward (-Z), yaw 90 => right (+X), pitch up +
function yawPitchToDir(yawDeg, pitchDeg){
  const yaw = THREE.MathUtils.degToRad(yawDeg);
  const pitch = THREE.MathUtils.degToRad(pitchDeg);
  const cp = Math.cos(pitch);
  const x = Math.sin(yaw) * cp;
  const y = Math.sin(pitch);
  const z = -Math.cos(yaw) * cp;
  return new THREE.Vector3(x,y,z).normalize();
}

function dirToYawPitchDeg(dir){
  // Inverse of yawPitchToDir (with our convention):
  // x = sin(yaw)*cos(pitch)
  // y = sin(pitch)
  // z = -cos(yaw)*cos(pitch)
  const d = dir.clone().normalize();
  const pitch = Math.asin(clamp(d.y, -1, 1));
  const yaw = Math.atan2(d.x, -d.z);
  return {
    yawDeg: norm360(THREE.MathUtils.radToDeg(yaw)),
    pitchDeg: THREE.MathUtils.radToDeg(pitch)
  };
}

function sourceToImagePath(source){
  // ignore legacy "0001.JPG"
  if (source.image && typeof source.image === 'string'){
    const img = source.image.trim();
    const base = img.split('/').pop().split('\\').pop();
    const isLegacy = /^\d{4}\.(jpe?g|png)$/i.test(base);
    if (!isLegacy){
      if (img.startsWith('images/')) return './' + img;
      if (img.startsWith('./images/')) return img;
      return './images/' + base;
    }
  }
  const sf = source.sourcefile || source.SourceFile || '';
  if (!sf) return null;
  const fname = sf.split('/').pop().split('\\').pop();
  if (!fname) return null;
  return './images/' + fname;
}

function basenameNoExt(path){
  const p = String(path || '').replace(/\\/g,'/');
  const name = p.split('/').pop() || '';
  return name.replace(/\.[^.]+$/, '');
}

function overlayPathForSource(source, kind){
  const imgRel = sourceToImagePath(source); // existing helper
  if (!imgRel) return null;
  const base = basenameNoExt(imgRel);
  return `./images/Overlays/${base}_${kind}.png`;
}



function candidateName(c){
  // Label priority:
  // 1) dst_lm_name when present (real landmark name)
  // 2) dst_name when present
  // 3) fallback to "Type - Subtype" (pretty formatted), with amenity defaulting to "Amenity - Parking"
  function isNullLike(v){
    if (v == null) return true;
    const s = String(v).trim();
    if (!s) return true;
    const up = s.toUpperCase();
    return up === 'NULL' || up === 'NONE' || up === 'N/A';
  }
  function prettyTitle(s){
    const clean = String(s).trim().replace(/_/g,' ').replace(/\s+/g,' ');
    return clean.split(' ').filter(Boolean).map(w=>{
      const low = w.toLowerCase();
      return low.charAt(0).toUpperCase() + low.slice(1);
    }).join(' ');
  }

  const lmName = c?.dst_lm_name;
  if (!isNullLike(lmName)) return prettyTitle(lmName);

  const dstName = c?.dst_name || c?.name || c?.title || c?.label;
  if (!isNullLike(dstName)) return prettyTitle(dstName);

  const t = prettyTitle(normType(c?.dst_type));
  let st = c?.dst_subtype;
  if (isNullLike(st)){
    if (normType(c?.dst_type) === 'amenity') return 'Amenity - Parking';
    return t;
  }
  st = prettyTitle(st);
  return `${t} - ${st}`;
}


function candidateStableId(c){
  // stable-ish key used for per-point offsets
  const t = normType(c.dst_type || 'dst');
  const id =
    safeStr(c.LMID_ ?? c.dst_id ?? c.osm_id ?? c.LM_ID ?? c.id ?? '');
  const name = safeStr(c.LM_Name ?? c.name ?? '');
  return id ? `${t}:${id}` : `${t}:name:${name}`;
}

function getCandidateDistanceM(c){
  const d = Number(c.dist_m ?? c.dist ?? c.distance_m ?? NaN);
  return Number.isFinite(d) ? d : NaN;
}
function getCandidateVisPct(c){
  const v = Number(c.vis_pct ?? c.visibility ?? NaN);
  return Number.isFinite(v) ? v : 0;
}

function isVisibleCandidate(c){
  // Prefer explicit boolean if present, else infer from vis_pct
  if (c.visible != null) return !!c.visible;
  return getCandidateVisPct(c) > 0;
}

function categoryOf(c){
  // Stronger classification for your ALLTYPES JSON
  const dt = normType(c.dst_type);
  if (dt.includes('amenity')) return 'amenity';
  if (dt.includes('leisure')) return 'leisure';
  if (dt.includes('place')) return 'place';

  // buildings (landmark buildings) often come through as 'building' or 'landmark'
  if (dt === 'building' || dt.includes('building')) return 'building';
  if (dt === 'landmark' || dt.includes('landmark') || dt === 'lm') return 'building';

  // fallbacks: if amenity/leisure/place fields exist
  if (c.amenity) return 'amenity';
  if (c.leisure) return 'leisure';
  if (c.place) return 'place';

  return 'other';
}

function hasLandmarkIdentity(c){
  // For your pipeline: LMID_/LM_Name indicates "this candidate is a landmark entity"
  return !!(c.LMID_ || c.LM_Name);
}

function landmarkGroupOf(c){
  // Which “landmark group” a landmark belongs to
  // buildings vs leisure vs places (amenities typically non-landmark in your spec)
  const cat = categoryOf(c);
  if (!hasLandmarkIdentity(c)) return 'non';
  if (cat === 'leisure') return 'leisure';
  if (cat === 'place') return 'places';
  return 'buildings';
}

// Z meters -> pitch deg
function zMetersToDeg(z_m, dist_m){
  if (!Number.isFinite(z_m) || !Number.isFinite(dist_m) || dist_m <= 0) return 0;
  return Math.atan2(z_m, dist_m) * THREE.MathUtils.RAD2DEG;
}

// --------------------
// Color coding (persistent across filters)
// --------------------
const TYPE_COLORS = {
  building_landmark: 0x00c8ff, // cyan
  leisure_landmark:  0xffb000, // amber
  place_landmark:    0xff4d4d, // red-ish
  amenity:           0x64ff7a, // green
  other:             0xffffff
};

function colorKeyForCandidate(c){
  const cat = categoryOf(c);
  const isLm = hasLandmarkIdentity(c);
  if (cat === 'amenity' && !isLm) return 'amenity';
  if (isLm){
    const g = landmarkGroupOf(c);
    if (g === 'leisure') return 'leisure_landmark';
    if (g === 'places')  return 'place_landmark';
    return 'building_landmark';
  }
  if (cat === 'amenity') return 'amenity';
  return 'other';
}

function colorHexForCandidate(c){
  const k = colorKeyForCandidate(c);
  return TYPE_COLORS[k] ?? TYPE_COLORS.other;
}

// --------------------
// DOM
// --------------------
const app = document.getElementById('app');
const statusEl = document.getElementById('status');
const sourceSelect = document.getElementById('sourceSelect');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const listEl = document.getElementById('list');

const srcTypeEl = document.getElementById('srcType');
const srcIdEl = document.getElementById('srcId');
const srcYawEl = document.getElementById('srcYaw');
const srcOffEl = document.getElementById('srcOff');
const srcZEl   = document.getElementById('srcZ');
const selIdEl  = document.getElementById('selId');
const srcMkEl  = document.getElementById('srcMk');

const adjustModeSel = document.getElementById('adjustMode');
const placeModeSel  = document.getElementById('placeMode');
const autoNextIn    = document.getElementById('autoNext');

const nudgeLeft  = document.getElementById('nudgeLeft');
const nudgeRight = document.getElementById('nudgeRight');
const nudgeUp    = document.getElementById('nudgeUp');
const nudgeDown  = document.getElementById('nudgeDown');
const yawStepPresetSel = document.getElementById('yawStepPreset');
const pitchStepIn= document.getElementById('pitchStep');
const resetAdjBtn= document.getElementById('resetAdj');

const zDown = document.getElementById('zDown');
const zUp   = document.getElementById('zUp');
const zZero = document.getElementById('zZero');
const zStepPresetSel = document.getElementById('zStepPreset');

const mWorld = document.getElementById('mWorld');
const topN = document.getElementById('topN');
const minVis = document.getElementById('minVis');
const exposureIn = document.getElementById('exposure');

const visFilterSel = document.getElementById('visFilter');
const categoryFilterSel = document.getElementById('categoryFilter');
const landmarkFilterSel = document.getElementById('landmarkFilter');
const distMaxIn = document.getElementById('distMax');
const distMaxLabel = document.getElementById('distMaxLabel');

const showLabelsIn = document.getElementById('showLabels');
const calloutsIn   = document.getElementById('callouts');
const allCalloutsIn= document.getElementById('allCallouts');
const debugDotIn   = document.getElementById('debugDot');

const riseWorldIn  = document.getElementById('riseWorld');
const sqWorldIn    = document.getElementById('sqWorld');
const lblWorldIn   = document.getElementById('lblWorld');

const fontSel      = document.getElementById('fontSel');

const FONT_STACKS = {
  helvetica: '"Helvetica Neue", Helvetica, Arial, sans-serif',
  inter: '"Inter", "Helvetica Neue", Helvetica, Arial, sans-serif',
  manrope: '"Manrope", "Helvetica Neue", Helvetica, Arial, sans-serif',
  ibmplex: '"IBM Plex Sans", "Helvetica Neue", Helvetica, Arial, sans-serif',
  spacegrotesk: '"Space Grotesk", "Helvetica Neue", Helvetica, Arial, sans-serif',
  system: 'system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif'
};
let currentLabelFontStack = FONT_STACKS.helvetica;

const animSecondsIn = document.getElementById('animSeconds');
const loopCalloutIn = document.getElementById('loopCallout');
const exportOffsetsBtn = document.getElementById('exportOffsets');
const importOffsetsIn  = document.getElementById('importOffsets');

const tip = document.getElementById('tip');
const tipTitle = document.getElementById('tipTitle');
const tipMeta = document.getElementById('tipMeta');

const reticleWrap = document.getElementById('reticleWrap');
const reticleA = document.getElementById('reticleA');
const reticleB = document.getElementById('reticleB');

function setStatus(msg){ statusEl.textContent = msg; }

const ovOn = document.getElementById('ovOn');
const ovType = document.getElementById('ovType');
const ovOpacity = document.getElementById('ovOpacity');
function showTooltip(x,y,title,meta){
  tip.style.display='block';
  tip.style.left = x+'px';
  tip.style.top  = y+'px';
  tipTitle.textContent = title || '';
  tipMeta.textContent  = meta || '';
}
function hideTooltip(){ tip.style.display='none'; }

// --------------------
// Three: 2 scenes (pano + overlay markers)
// --------------------
const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.autoClear = false;
renderer.toneMapping = THREE.NoToneMapping;
renderer.toneMappingExposure = 1.0;
app.appendChild(renderer.domElement);

const scenePano = new THREE.Scene();
const sceneOverlay = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0,0,0);

const sphereGeo = new THREE.SphereGeometry(SPHERE_RADIUS, 64, 40);
sphereGeo.scale(-1,1,1);
const sphereMesh = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial({ color: 0x111111 }));
scenePano.add(sphereMesh);

// ---- Overlay sphere (PNG bitmap) ----
const overlayGeo = new THREE.SphereGeometry(SPHERE_RADIUS - 0.5, 64, 40);
overlayGeo.scale(-1, 1, 1);

let overlayTexture = null;
const overlayMesh = new THREE.Mesh(
  overlayGeo,
  new THREE.MeshBasicMaterial({
    transparent: true,
    opacity: 0.65,
    depthWrite: false,
    depthTest: true
  })
);
overlayMesh.visible = true;
scenePano.add(overlayMesh);


const markerGroup = new THREE.Group();
sceneOverlay.add(markerGroup);

const labelGroup = new THREE.Group();
sceneOverlay.add(labelGroup);

// --------------------
// Data
// --------------------
let DATA=null;
let SOURCES=[];
let currentIndex=0;

// --------------------
// Storage: global + per-point offsets
// --------------------
function offsetKey(srcId){ return `todi_pano_offset_deg__${srcId}`; }
function getOffsetDeg(srcId){
  const v = localStorage.getItem(offsetKey(srcId));
  const n = v==null ? 0 : parseFloat(v);
  return Number.isFinite(n) ? n : 0;
}
function setOffsetDeg(srcId, deg){
  localStorage.setItem(offsetKey(srcId), String(deg));
}

function zOffsetKey(srcId){ return `todi_pano_zoff_m__${srcId}`; }
function getZOffsetM(srcId){
  const v = localStorage.getItem(zOffsetKey(srcId));
  const n = v==null ? 0 : parseFloat(v);
  return Number.isFinite(n) ? n : 0;
}
function setZOffsetM(srcId, m){
  localStorage.setItem(zOffsetKey(srcId), String(m));
}

function pointKey(srcId, candKey){ return `todi_point_adj__${srcId}__${candKey}`; }
function getPointAdj(srcId, candKey){
  const raw = localStorage.getItem(pointKey(srcId, candKey));
  if (!raw) return { yaw:0, pitch:0, z:0 };
  try {
    const j = JSON.parse(raw);
    return {
      yaw:   Number.isFinite(+j.yaw)   ? +j.yaw   : 0,
      pitch: Number.isFinite(+j.pitch) ? +j.pitch : 0,
      z:     Number.isFinite(+j.z)     ? +j.z     : 0
    };
  } catch {
    return { yaw:0, pitch:0, z:0 };
  }
}
function setPointAdj(srcId, candKey, adj){
  const clean = {
    yaw:   Number.isFinite(+adj.yaw)   ? +adj.yaw   : 0,
    pitch: Number.isFinite(+adj.pitch) ? +adj.pitch : 0,
    z:     Number.isFinite(+adj.z)     ? +adj.z     : 0
  };
  localStorage.setItem(pointKey(srcId, candKey), JSON.stringify(clean));
}
function resetPointAdj(srcId, candKey){
  localStorage.removeItem(pointKey(srcId, candKey));
}

// --------------------
// Camera yaw/pitch + smooth turn
// --------------------
let yaw = 0;
let pitch = 0;
let dragging=false, lastX=0, lastY=0;
const MAX_PITCH = THREE.MathUtils.degToRad(85);

let animating=false;
let yawFrom=0, pitchFrom=0, yawTo=0, pitchTo=0;
let t0=0, dur=420;

function shortestAngle(a,b){
  let d = (b - a) % (Math.PI*2);
  if (d > Math.PI) d -= Math.PI*2;
  if (d < -Math.PI) d += Math.PI*2;
  return d;
}
function setViewYawPitch(targetYaw, targetPitch, smooth=true){
  const tp = clamp(targetPitch, -MAX_PITCH, MAX_PITCH);
  if (!smooth){
    yaw = targetYaw;
    pitch = tp;
    animating = false;
    return;
  }
  animating = true;
  t0 = performance.now();
  yawFrom = yaw;
  pitchFrom = pitch;
  yawTo = targetYaw;
  pitchTo = tp;
}
function updateCamera(){
  if (animating){
    const t = (performance.now() - t0) / dur;
    if (t >= 1){
      animating=false;
      yaw=yawTo; pitch=pitchTo;
    } else {
      const k = t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
      yaw = yawFrom + shortestAngle(yawFrom, yawTo)*k;
      pitch = pitchFrom + (pitchTo - pitchFrom)*k;
    }
  }
  pitch = clamp(pitch, -MAX_PITCH, MAX_PITCH);

  const yawDeg = THREE.MathUtils.radToDeg(yaw);
  const pitchDeg = THREE.MathUtils.radToDeg(pitch);
  const dir = yawPitchToDir(yawDeg, pitchDeg);
  camera.lookAt(dir);
}

// --------------------
// Marker sprites + labels
// --------------------
function makeCrosshairMarkerSprite(worldSize=18, colorHex=0xffffff){
  const c = document.createElement('canvas');
  c.width=128; c.height=128;
  const g=c.getContext('2d');
  g.clearRect(0,0,128,128);

  const color = `#${(colorHex>>>0).toString(16).padStart(6,'0')}`;

  // ring
  g.beginPath();
  g.arc(64,64,34,0,Math.PI*2);
  g.strokeStyle = color;
  g.lineWidth = 6;
  g.lineJoin = 'round';
  g.lineCap = 'round';
  g.stroke();

  // inner ring faint
  g.beginPath();
  g.arc(64,64,22,0,Math.PI*2);
  g.strokeStyle = 'rgba(255,255,255,0.28)';
  g.lineWidth = 3;
  g.stroke();

  // crosshair
  g.strokeStyle = color;
  g.lineWidth = 4;
  g.beginPath();
  g.moveTo(64,22); g.lineTo(64,106);
  g.moveTo(22,64); g.lineTo(106,64);
  g.stroke();

  // tiny center dot
  g.fillStyle = '#ffffff';
  g.beginPath(); g.arc(64,64,3.5,0,Math.PI*2); g.fill();

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;

  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
  mat.depthTest = false;
  mat.depthWrite = false;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 9999;
  spr.scale.set(worldSize, worldSize, 1);
  return spr;
}


function makeLoadingCircleMarker(worldSize=18, colorHex=0x00c8ff){
  // Smooth pulsing/rotating ring that always faces the camera (Sprite)
  const c = document.createElement('canvas');
  const SZ = 256;
  c.width = SZ; c.height = SZ;
  const g = c.getContext('2d', { alpha:true });

  g.clearRect(0,0,SZ,SZ);
  const cx = SZ/2, cy = SZ/2;
  const r1 = SZ*0.34;
  const r2 = SZ*0.42;

  // faint outer glow
  g.beginPath();
  g.arc(cx, cy, r2, 0, Math.PI*2);
  g.strokeStyle = 'rgba(255,255,255,0.18)';
  g.lineWidth = SZ*0.02;
  g.lineCap = 'round';
  g.stroke();

  // main ring (solid, clean)
  const col = `#${(colorHex>>>0).toString(16).padStart(6,'0')}`;
  g.beginPath();
  g.arc(cx, cy, r1, 0, Math.PI*2);
  g.strokeStyle = col;
  g.lineWidth = SZ*0.045;
  g.lineJoin = 'round';
  g.lineCap = 'round';
  g.stroke();

  // small "loading" notch (we'll rotate the sprite)
  g.beginPath();
  g.arc(cx, cy, r1, -0.35, 0.35);
  g.strokeStyle = 'rgba(0,0,0,0.18)';
  g.lineWidth = SZ*0.06;
  g.lineCap = 'round';
  g.stroke();

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.premultiplyAlpha = true;
  tex.needsUpdate = true;

  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
  mat.depthTest = false;
  mat.depthWrite = false;
  mat.premultipliedAlpha = true;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 10002;
  spr.scale.set(worldSize, worldSize, 1);
  spr.userData.isLoadingCircle = true;
  spr.userData.baseScale = spr.scale.clone();
  spr.userData.spin = 1.4;     // rotations/sec (editable via code if needed)
  spr.userData.pulse = 0.18;   // pulse amplitude (scale)
  return spr;
}

function makeSquareSprite(worldSize=6){
  const c = document.createElement('canvas');
  c.width=32; c.height=32;
  const g=c.getContext('2d');
  g.clearRect(0,0,32,32);
  g.fillStyle='rgba(0,0,0,0.95)';
  g.fillRect(6,6,20,20);

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
  mat.depthTest=false; mat.depthWrite=false;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 10005;
  spr.scale.set(worldSize, worldSize, 1);
  return spr;
}

function makeXSprite(worldSize=6){
  const c = document.createElement('canvas');
  c.width=64; c.height=64;
  const g=c.getContext('2d');
  g.clearRect(0,0,64,64);

  g.strokeStyle='rgba(0,0,0,0.95)';
  g.lineWidth=10;
  g.lineCap='round';
  g.beginPath();
  g.moveTo(16,16); g.lineTo(48,48);
  g.moveTo(48,16); g.lineTo(16,48);
  g.stroke();

  // subtle white halo for contrast
  g.strokeStyle='rgba(255,255,255,0.35)';
  g.lineWidth=14;
  g.beginPath();
  g.moveTo(16,16); g.lineTo(48,48);
  g.moveTo(48,16); g.lineTo(16,48);
  g.stroke();

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
  mat.depthTest=false; mat.depthWrite=false;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 10006;
  spr.scale.set(worldSize, worldSize, 1);
  return spr;
}

function makeLabelSpriteHelveticaBoldBlack(text, worldSize=18){
  const txt = upperSafe(text);

  const fontPx = 28;
  const padX = 6;
  const padY = 6;

  const c = document.createElement('canvas');
  const g = c.getContext('2d', { alpha:true });

  g.font = `900 ${fontPx}px ${currentLabelFontStack}`;
  const tw = Math.ceil(g.measureText(txt).width);
  const w = tw + padX*2;
  const h = fontPx + padY*2;

  c.width = w;
  c.height = h;

  // hard reset state
  g.setTransform(1,0,0,1,0,0);
  g.globalAlpha = 1;
  g.globalCompositeOperation = 'source-over';
  g.imageSmoothingEnabled = true;

  g.clearRect(0,0,w,h);

  // absolutely no shadow / stroke
  g.shadowColor = 'transparent';
  g.shadowBlur = 0;
  g.shadowOffsetX = 0;
  g.shadowOffsetY = 0;

  g.font = `900 ${fontPx}px ${currentLabelFontStack}`;
  g.textBaseline = 'middle';
  g.textAlign = 'left';

  // BLACK ONLY
  g.fillStyle = '#000000';
  g.fillText(txt, padX, h/2);

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;

  // critical: premultiply alpha to avoid light fringe
  tex.premultiplyAlpha = true;
  tex.needsUpdate = true;

  const mat = new THREE.SpriteMaterial({
    map: tex,
    transparent: true,
    depthTest: false,
    depthWrite: false
  });

  // critical: match premultiply mode
  mat.premultipliedAlpha = true;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 10006;

  const aspect = w / h;
  spr.scale.set(worldSize * aspect, worldSize * 0.75, 1);
  return spr;
}

function disposeSprite(obj){
  if (!obj) return;
  if (obj.material?.map) obj.material.map.dispose();
  if (obj.material) obj.material.dispose();
}

function clearMarkers(){
  markerGroup.traverse(o=>{
    if (o.isSprite) disposeSprite(o);
    if (o.isLine){
      if (o.geometry) o.geometry.dispose();
      if (o.material) o.material.dispose();
    }
  });
  markerGroup.clear();
}
function disposeLabels(){
  labelGroup.children.forEach(l=>disposeSprite(l));
  labelGroup.clear();
}

// --------------------
// Hover/select syncing
// --------------------
let currentMarkers=[]; // marker roots (Group)
let hovered=null;
let selected=null;

function rebuildLabels(){
  disposeLabels();
  return; // hard-disable old point labels
}

function updateCalloutsVisibility(){
  // Visibility is driven by animated callouts.
  // We only decide targets here (selected vs all).
  const enabled = !!calloutsIn.checked;
  const showAll = !!allCalloutsIn.checked;

  currentMarkers.forEach(m=>{
    const c = m?.userData?.callout;
    if (!c) return;
    const ud = c.userData;
    if (!enabled) ud.target = 0;
    else if (showAll) ud.target = 1;
    else ud.target = (m === selected) ? 1 : 0;

    // loop (ping-pong) the selected callout if enabled
    if (enabled && !showAll && loopCalloutIn?.checked && (m === selected)){
      if (Math.abs(ud.t - ud.target) < 0.0005){
        ud.target = 1 - ud.target;
      }
    }
  });
}

function setSelected(m){
  // restore previous marker visual
  if (selected && selected.userData?.markerVisual){
    selected.userData.markerVisual.visible = true;
  }

  selected = m;
  focusCallout(m);

  // hide ring on selected marker (label becomes the focus)
  if (selected && selected.userData?.markerVisual){
    selected.userData.markerVisual.visible = false;
  }

  [...listEl.querySelectorAll('.item')].forEach(el=>el.classList.remove('sel'));
  if (m){
    const row = listEl.querySelector(`.item[data-idx="${m.userData.idx}"]`);
    if (row){
      row.classList.add('sel');
      row.scrollIntoView({ block:'nearest' });
    }
  }
  selIdEl.textContent = m ? (m.userData.candKey || '—') : '—';
  rebuildLabels();
  updateCalloutsVisibility();
}

function setHovered(m, x, y){
  hovered = m;
  if (!m){
    hideTooltip();
    rebuildLabels();
    updateCalloutsVisibility();
    return;
  }
  const ud=m.userData;
  showTooltip(
    x, y,
    ud.name,
    `${safeStr(ud.cand?.dst_type)} • rel ${fmt(ud.baseRel,1)}° • elev ${fmt(ud.baseElev,2)}° • final yaw ${fmt(ud.yawDeg,1)}° • final pitch ${fmt(ud.pitchDeg,2)}°`
  );
  rebuildLabels();
  updateCalloutsVisibility();
}

// --------------------
// Raycast for markers
// --------------------
const raycaster = new THREE.Raycaster();
raycaster.params.Sprite = { threshold: 0.7 };
const mouse = new THREE.Vector2();

function markerRootFromObject(obj){
  let o = obj;
  while (o){
    if (o.userData && o.userData.isMarkerRoot) return o;
    o = o.parent;
  }
  return null;
}

function doHover(clientX, clientY){
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(markerGroup.children, true);
  if (!hits.length){
    if (hovered) setHovered(null, clientX, clientY);
    return;
  }
  const root = markerRootFromObject(hits[0].object);
  if (!root){
    if (hovered) setHovered(null, clientX, clientY);
    return;
  }
  if (root !== hovered){
    setHovered(root, clientX, clientY);
  } else {
    if (hovered){
      const ud=hovered.userData;
      showTooltip(clientX, clientY, ud.name,
        `${safeStr(ud.cand?.dst_type)} • rel ${fmt(ud.baseRel,1)}° • elev ${fmt(ud.baseElev,2)}° • final yaw ${fmt(ud.yawDeg,1)}° • final pitch ${fmt(ud.pitchDeg,2)}°`);
    }
  }
}

// --------------------
// Candidate filtering
// --------------------
function passesFilters(c){

  // hard exclude "NULL" placeholder candidates
  const ck = safeStr(c?.cand_key);
  const t  = safeStr(c?.dst_type).toLowerCase();
  const id = safeStr(c?.dst_id);
  if ((ck === 'landmark:NULL') || (ck === 'landmark:null')) return false;
  if ((ck === 'leisure:NULL')  || (ck === 'leisure:null'))  return false;
  if ((t === 'landmark' || t === 'leisure') && (id === 'NULL' || id === 'null' || id === '')) return false;

  const visMode = visFilterSel.value; // any|visible|not_visible
  const catMode = categoryFilterSel.value; // all|building|amenity|leisure|place
  const lmMode  = landmarkFilterSel.value; // any|landmarks_all|landmarks_buildings|...|non_landmarks

  const distLimit = Number(distMaxIn.value || 2000);
  const d = getCandidateDistanceM(c);
  if (Number.isFinite(d) && d > distLimit) return false;

  const minV = Number(minVis.value || 0);
  if (getCandidateVisPct(c) < minV) return false;

  if (visMode === 'visible' && !isVisibleCandidate(c)) return false;
  if (visMode === 'not_visible' && isVisibleCandidate(c)) return false;

  if (catMode !== 'all'){
    const cat = categoryOf(c);
    if (cat !== catMode) return false;
  }

  const isLm = hasLandmarkIdentity(c);
  if (lmMode === 'landmarks_all' && !isLm) return false;
  if (lmMode === 'non_landmarks' && isLm) return false;

  if (lmMode === 'landmarks_buildings'){
    if (!isLm || landmarkGroupOf(c) !== 'buildings') return false;
  }
  if (lmMode === 'landmarks_leisure'){
    if (!isLm || landmarkGroupOf(c) !== 'leisure') return false;
  }
  if (lmMode === 'landmarks_places'){
    if (!isLm || landmarkGroupOf(c) !== 'places') return false;
  }

  return true;
}

function currentSource(){ return SOURCES[currentIndex] || null; }

function getFilteredCandidates(source){
  const nTop = parseInt(topN.value, 10);

  let arr = Array.isArray(source.candidates) ? source.candidates.slice() : [];
  arr = arr.filter(passesFilters);

  // sort: visible first (by vis%), then closer
  arr.sort((a,b)=>{
    const av=getCandidateVisPct(a);
    const bv=getCandidateVisPct(b);
    if (bv!==av) return bv-av;
    const ad=getCandidateDistanceM(a); const bd=getCandidateDistanceM(b);
    const A = Number.isFinite(ad) ? ad : 1e18;
    const B = Number.isFinite(bd) ? bd : 1e18;
    return A-B;
  });

  if (Number.isFinite(nTop) && nTop > 0) arr = arr.slice(0, nTop);
  return arr;
}

function buildSourceDropdown(){
  const sel = document.getElementById('sourceSelect');
  if (!sel){
    console.warn('[buildSourceDropdown] #sourceSelect not found; skipping dropdown build.');
    return;
  }
  sel.innerHTML = '';
  const optgrpP = document.createElement('optgroup'); optgrpP.label='Panoramas';
  const optgrpV = document.createElement('optgroup'); optgrpV.label='Vistas';

  SOURCES.forEach((s, idx)=>{
    const o = document.createElement('option');
    o.value = String(idx);
    o.textContent = s.id;
    (s.type==='vista' ? optgrpV : optgrpP).appendChild(o);
  });

  if (optgrpP.children.length) sel.appendChild(optgrpP);
  if (optgrpV.children.length) sel.appendChild(optgrpV);

  // wire change (idempotent)
  if (!sel.__wired){
    sel.addEventListener('change', ()=>{
      const i = Number(sel.value);
      if (Number.isFinite(i)) setSourceByIndex(i);
    });
    sel.__wired = true;
  }
}

function updateHeader(){
  const s=currentSource();
  if (!s) return;
  srcTypeEl.textContent = s.type || '—';
  srcIdEl.textContent = s.id || '—';
  srcYawEl.textContent = (s.yaw_deg==null) ? '—' : `${fmt(Number(s.yaw_deg),1)}°`;
  srcOffEl.textContent = `${fmt(getOffsetDeg(s.id),2)}°`;
  srcZEl.textContent   = `${fmt(getZOffsetM(s.id),2)} m`;
  srcMkEl.textContent  = String(markerGroup.children.length);
}

// --------------------
// Callouts (animated focus + reverse)
// --------------------
function lerp(a,b,t){ return a + (b-a)*t; }
function easeOutCubic(t){ return 1 - Math.pow(1-t,3); }
function easeInOutCubic(t){ return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }

function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w*0.5, h*0.5);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y,   x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x,   y+h, rr);
  ctx.arcTo(x,   y+h, x,   y,   rr);
  ctx.arcTo(x,   y,   x+w, y,   rr);
  ctx.closePath();
}

// Black translucent fill + stroke that animates from black -> type color
function makePillLabelSprite(text, worldSize=18, strokeHex=0x000000){
  const txt = safeStr(text);

  // ---- styling knobs ----
  const fontPx = 28;
  const padX = 18;
  const padY = 12;

  // Render at higher pixel density so the outline doesn't look blocky after texture filtering.
  // (The sprite is then scaled in world units.)
  const dpr = Math.max(2, Math.round((window.devicePixelRatio || 1) * 2) / 2); // 2, 2.5, 3...
  const c = document.createElement('canvas');
  const g = c.getContext('2d', { alpha:true });

  // measure text at 1x
  g.font = `900 ${fontPx}px ${currentLabelFontStack}`;
  const tw = Math.ceil(g.measureText(txt).width);
  const w1 = tw + padX*2;
  const h1 = fontPx + padY*2;

  // allocate hi-res
  c.width  = Math.ceil(w1 * dpr);
  c.height = Math.ceil(h1 * dpr);

  // draw in 1x logical coords
  g.setTransform(dpr, 0, 0, dpr, 0, 0);
  g.clearRect(0,0,w1,h1);

  const radius = h1/2;          // true pill
  const inset  = 3;             // keep stroke away from texture edge to prevent clipping
  const x = inset;
  const y = inset;
  const w = w1 - inset*2;
  const h = h1 - inset*2;

  // Fill: transparent-ish black (requested)
  g.fillStyle = 'rgba(0,0,0,0.55)';
  g.beginPath();
  roundRect(g, x, y, w, h, radius);
  g.fill();

  // Stroke: smooth round joins/caps
  const r = (strokeHex >> 16) & 255;
  const gg = (strokeHex >> 8) & 255;
  const b = (strokeHex) & 255;
  g.strokeStyle = `rgba(${r},${gg},${b},0.98)`;
  g.lineWidth = 2.5;
  g.lineJoin = 'round';
  g.lineCap  = 'round';
  g.beginPath();
  roundRect(g, x, y, w, h, radius);
  g.stroke();

  // Text: white (requested)
  g.font = `900 ${fontPx}px ${currentLabelFontStack}`;
  g.textBaseline = 'middle';
  g.textAlign = 'left';
  g.fillStyle = '#ffffff';
  g.fillText(txt, padX, h1/2);

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.premultiplyAlpha = true;
  tex.generateMipmaps = false; // avoids outline stepping as mip levels switch
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.needsUpdate = true;

  const mat = new THREE.SpriteMaterial({
    map: tex,
    transparent: true,
    depthTest: false,
    depthWrite: false
  });
  mat.premultipliedAlpha = true;

  const spr = new THREE.Sprite(mat);
  spr.renderOrder = 10006;

  const aspect = w1 / h1;
  spr.scale.set(worldSize * aspect, worldSize * 0.85, 1);
  spr.userData.baseScale = spr.scale.clone();
  spr.userData._pillText = txt;
  spr.userData._pillWorldSize = worldSize;
  return spr;
}

function updatePillSprite(sprite, text, worldSize, strokeHex){
  // dispose old
  if (sprite.material?.map) sprite.material.map.dispose();
  if (sprite.material) sprite.material.dispose();

  const fresh = makePillLabelSprite(text, worldSize, strokeHex);
  sprite.material = fresh.material;
  sprite.scale.copy(fresh.scale);
  sprite.userData.baseScale = fresh.userData.baseScale.clone();
  sprite.userData._pillText = fresh.userData._pillText;
  sprite.userData._pillWorldSize = fresh.userData._pillWorldSize;
}

function updatePillFont(sprite){
  if (!sprite?.userData) return;
  const txt = sprite.userData._pillText;
  const ws  = sprite.userData._pillWorld;
  const st  = sprite.userData._pillStroke;
  if (!txt || !ws) return;
  updatePillSprite(sprite, txt, ws, st || 0x000000);
}

function updateAllPillFonts(){
  currentMarkers.forEach(m=>{
    const call = m.userData?.callout;
    if (call?.userData?.label) updatePillFont(call.userData.label);
  });
}

function makeCalloutAnimated(root, name, isVisible=true, typeHex=0x00c8ff){
  const rise = parseFloat(riseWorldIn.value) || 40;
  const sqW  = parseFloat(sqWorldIn.value) || 6;
  const lblW = parseFloat(lblWorldIn.value) || 18;

  // gaps: square -> line start, line end -> square, square -> label
  const gap1 = Math.max(1.5, sqW * 0.35);
  const gap2 = Math.max(1.5, sqW * 0.35);
  const gap3 = Math.max(2.0, sqW * 0.45);

  const call = new THREE.Group();
  call.renderOrder = 10000;
  call.userData.isCallout = true;

  // bottom square
  const sq1 = makeSquareSprite(sqW);
  sq1.position.set(0,0,0);
  call.add(sq1);

  // line (animate end Y). Start at gap1 so there's an air gap above square.
  const pts = [new THREE.Vector3(0, gap1, 0), new THREE.Vector3(0, gap1, 0)];
  const geo = new THREE.BufferGeometry().setFromPoints(pts);

  let line;
  if (isVisible){
    const mat = new THREE.LineBasicMaterial({ color: 0x000000, transparent:true, opacity:0.0 });
    mat.depthTest = false;
    line = new THREE.Line(geo, mat);
  } else {
    const mat = new THREE.LineDashedMaterial({
      color: 0x000000,
      transparent:true,
      opacity:0.0,
      dashSize: Math.max(3, rise * 0.18),
      gapSize:  Math.max(2, rise * 0.12)
    });
    mat.depthTest = false;
    line = new THREE.Line(geo, mat);
    line.computeLineDistances();
  }
  line.renderOrder = 10001;
  call.add(line);

  // X marker at halfway for NOT visible (fades with the line)
  let xSpr = null;
  if (!isVisible){
    xSpr = makeXSprite(Math.max(5, sqW*0.95));
    xSpr.position.set(0, rise*0.5, 0);
    xSpr.material.opacity = 0.0;
    call.add(xSpr);
  }

  // top square (moves with line end)
  const sq2 = makeSquareSprite(sqW);
  sq2.position.set(0, gap1 + gap2, 0);
  call.add(sq2);

  // pill label (appears last)
  const label = makePillLabelSprite(name, lblW, 0x000000);
  const labelHalfH = (label.userData?.baseScale ? (label.userData.baseScale.y*0.5) : (label.scale.y*0.5));
  label.position.set(0, (gap1 + gap2) + (sqW*0.5) + gap3 + labelHalfH, 0);
  label.material.opacity = 0.0;
  call.add(label);

  // init hidden
  const bs1 = sq1.userData?.baseScale;
  const bs2 = sq2.userData?.baseScale;
  if (bs1) sq1.scale.copy(bs1).multiplyScalar(0.0001); else sq1.scale.setScalar(0.0001);
  if (bs2) sq2.scale.copy(bs2).multiplyScalar(0.0001); else sq2.scale.setScalar(0.0001);

  // always on top
  call.traverse(o=>{
    if (o.isSprite && o.material){
      o.material.depthTest = false;
      o.material.depthWrite = false;
    }
    if (o.isLine && o.material){
      o.material.depthTest = false;
    }
  });

  call.userData = {
    isCallout: true,
    name,
    rise, sqW, lblW,
    gap1, gap2, gap3,
    typeHex: (typeHex ?? 0x00c8ff),
    sq1, sq2, line, label, xSpr,
    t: 0,
    target: 0,
    speed: (1 / Math.max(0.05, (parseFloat(animSecondsIn?.value)||1.8))) ,
    lastStrokeHex: 0x000000
  };

  root.userData.callout = call;
  root.add(call);
  return call;
}

let focusedMarker = null;

function focusCallout(marker){
  // reverse old
  if (focusedMarker && focusedMarker.userData?.callout){
    focusedMarker.userData.callout.userData.target = 0;
  }
  focusedMarker = marker || null;
  if (focusedMarker && focusedMarker.userData?.callout){
    focusedMarker.userData.callout.userData.target = 1;
  }
}

let lastCalloutFrameT = performance.now();
let lastSpinT = performance.now();
let spinSpeed = 2.4; // turns/sec-ish

function updateCalloutAnims(){
  const now = performance.now();
  const dt = Math.min(0.05, (now - lastCalloutFrameT) / 1000);
  lastCalloutFrameT = now;

  const enabled = !!calloutsIn.checked;
  const showAll = !!allCalloutsIn.checked;

  currentMarkers.forEach(m=>{
    const call = m?.userData?.callout;
    if (!call) return;
    const ud = call.userData;

    // decide whether this callout should be "up"
    if (!enabled) ud.target = 0;
    else if (showAll) ud.target = 1;
    else ud.target = (m === selected) ? 1 : 0;

    // loop (ping-pong) the selected callout if enabled
    if (enabled && !showAll && loopCalloutIn?.checked && (m === selected)){
      if (Math.abs(ud.t - ud.target) < 0.0005){
        ud.target = 1 - ud.target;
      }
    }

    // allow live edit of animation seconds
    ud.speed = (1 / Math.max(0.05, (parseFloat(animSecondsIn?.value)||1.8)));

    // advance t toward target
    if (ud.t !== ud.target){
      const dir = (ud.target > ud.t) ? 1 : -1;
      ud.t = clamp(ud.t + dir * ud.speed * dt, 0, 1);
    }

    // show/hide
    call.visible = (ud.t > 0.001);

    // staged timing:
    // 0-0.16: bottom square pop
    // 0.16-0.62: line grows
    // 0.52-0.76: top square pop
    // 0.72-1.00: label + pill
    const t = ud.t;

    const t1 = clamp((t - 0.00)/0.16, 0, 1);
    const t2 = clamp((t - 0.16)/0.46, 0, 1);
    const t3 = clamp((t - 0.52)/0.24, 0, 1);
    const t4 = clamp((t - 0.72)/0.28, 0, 1);

    const k1 = easeOutCubic(t1);
    const k2 = easeInOutCubic(t2);
    const k3 = easeOutCubic(t3);
    const k4 = easeOutCubic(t4);

    // bottom square
    {
      const bs = ud.sq1.userData?.baseScale;
      const s = Math.max(0.0001, k1);
      if (bs) ud.sq1.scale.copy(bs).multiplyScalar(s);
      else ud.sq1.scale.setScalar(s);
    }
// line end Y, leaving gaps
    const usable = Math.max(0, ud.rise - ud.gap1 - ud.gap2);
    const endY = ud.gap1 + usable * k2;

    const pos = ud.line.geometry.attributes.position;
    pos.setXYZ(0, 0, ud.gap1, 0);
    pos.setXYZ(1, 0, endY, 0);
    pos.needsUpdate = true;

    ud.line.material.opacity = 0.95 * k2;
    if (ud.line.isLine && ud.line.material.isLineDashedMaterial){
      ud.line.computeLineDistances();
    }

    // optional X marker
    if (ud.xSpr && ud.xSpr.material){
      ud.xSpr.material.opacity = 0.95 * k2;
    }

    // top square follows line end + gap2
    ud.sq2.position.set(0, endY + ud.gap2, 0);
    {
      const bs = ud.sq2.userData?.baseScale;
      const s = Math.max(0.0001, k3);
      if (bs) ud.sq2.scale.copy(bs).multiplyScalar(s);
      else ud.sq2.scale.setScalar(s);
    }
// label above top square with small gap
    const topCenterY = endY + ud.gap2;
    const topEdgeY = topCenterY + (ud.sqW*0.5);
    const baseH = (ud.label.userData?.baseScale ? ud.label.userData.baseScale.y : ud.label.scale.y);
    const labelHalfH = baseH * 0.5;
    ud.label.position.set(0, topEdgeY + ud.gap3 + labelHalfH, 0);
    ud.label.material.opacity = k4;

    // slight scale-in while keeping aspect
    const baseScale = 0.90 + 0.10 * k4;
    const bs = ud.label.userData?.baseScale;
    if (bs){
      ud.label.scale.set(bs.x * baseScale, bs.y * baseScale, 1);
    }

    // stroke color transition near the end: black -> typeHex
    const strokePhase = clamp((t - 0.82)/0.18, 0, 1);
    const sp = easeOutCubic(strokePhase);

    const tr = (ud.typeHex >> 16) & 255;
    const tg = (ud.typeHex >> 8) & 255;
    const tb = ud.typeHex & 255;
    const rr = Math.round(lerp(0, tr, sp));
    const rg = Math.round(lerp(0, tg, sp));
    const rb = Math.round(lerp(0, tb, sp));
    const strokeHex = (rr<<16) | (rg<<8) | rb;

    // line matches pill stroke colour
    if (ud.line?.material?.color) ud.line.material.color.setHex(strokeHex);

    if (strokeHex !== ud.lastStrokeHex){
      updatePillSprite(ud.label, ud.name, ud.lblW, strokeHex);
      ud.lastStrokeHex = strokeHex;
    }
  });
}
// --------------------
// Marker building
// --------------------
function addMarker(source, cand, idx){
  const baseRel  = Number(cand.rel_bear ?? 0);
  const baseElev = Number(cand.elev_ang_d ?? 0);
  const dist     = getCandidateDistanceM(cand);

  const candKey = candidateStableId(cand);
  const pAdj = getPointAdj(source.id, candKey);

  const offYaw = getOffsetDeg(source.id);
  const offZ_m = getZOffsetM(source.id);

  // Total yaw = rel - globalYaw - pointYaw
  const yawDeg = norm360(baseRel - offYaw - (pAdj.yaw || 0));

  // Total pitch = baseElev + globalZ(dist) + pointZ(dist) + pointPitchDeg
  let pitchDeg = baseElev;
  pitchDeg += zMetersToDeg(offZ_m, dist);
  pitchDeg += zMetersToDeg((pAdj.z || 0), dist);
  pitchDeg += (pAdj.pitch || 0);
  pitchDeg = clamp(pitchDeg, -MAX_PITCH_DEG, MAX_PITCH_DEG);

  const dir = yawPitchToDir(yawDeg, pitchDeg);
  const pos = dir.clone().multiplyScalar(MARKER_RADIUS);

  const size = parseFloat(mWorld.value) || 18;

  const colorHex = colorHexForCandidate(cand);

  const root = new THREE.Group();
  root.position.copy(pos);
  root.userData = {
    isMarkerRoot: true,
    cand,
    idx,
    candKey,
    name: candidateName(cand),
    baseRel,
    baseElev,
    yawDeg,
    pitchDeg,
    colorHex
  };

  // hit target (invisible) so selection still works when visual is hidden
  const hit = new THREE.Mesh(new THREE.SphereGeometry(Math.max(1.5, size*0.25), 8, 8), new THREE.MeshBasicMaterial({transparent:true, opacity:0.0, depthTest:false, depthWrite:false,
    depthTest:false}));
  hit.renderOrder = 10001;
  root.add(hit);

  const ring = makeLoadingCircleMarker(size, colorHex);
  ring.userData.markerVisual = true;
  root.userData.markerVisual = ring;
  root.add(ring);

  makeCalloutAnimated(root, root.userData.name, isVisibleCandidate(cand), colorHex);
markerGroup.add(root);
  return root;
}

function addDebugMarker(){
  if (!debugDotIn.checked) return null;
  const size = Math.max(22, (parseFloat(mWorld.value)||18) + 8);

  const dir = yawPitchToDir(0, 0);
  const pos = dir.clone().multiplyScalar(MARKER_RADIUS);

  const root = new THREE.Group();
  root.position.copy(pos);
  root.userData = {
    isMarkerRoot: true,
    cand: { dst_type:'debug' },
    idx: -1,
    candKey: 'debug:forward',
    name: 'DEBUG: forward (yaw 0 / pitch 0)',
    baseRel: 0,
    baseElev: 0,
    yawDeg: 0,
    pitchDeg: 0,
    colorHex: 0x00c8ff
  };

    const hit = new THREE.Mesh(new THREE.SphereGeometry(Math.max(1.5, size*0.25), 8, 8), new THREE.MeshBasicMaterial({transparent:true, opacity:0.0, depthTest:false, depthWrite:false,
    depthTest:false}));
  hit.renderOrder = 10001;
  root.add(hit);

  const ring = makeLoadingCircleMarker(size, 0x00c8ff);
  ring.userData.markerVisual = true;
  root.userData.markerVisual = ring;
  root.add(ring);
makeCalloutAnimated(root, root.userData.name, true, root.userData.colorHex);
markerGroup.add(root);
  return root;
}

// --------------------
// Rebuild markers + list (with colors retained)
// --------------------
function rebuildMarkersAndList(){
  clearMarkers();
  disposeLabels();
  currentMarkers = [];
  hovered = null;
  selected = null;
  hideTooltip();
  selIdEl.textContent='—';

  const source = currentSource();
  if (!source) return;

  const cands = getFilteredCandidates(source);

  listEl.innerHTML='';
  if (!cands.length){
    const empty=document.createElement('div');
    empty.style.padding='12px 10px';
    empty.style.opacity='.8';
    empty.textContent='No candidates for current filters.';
    listEl.appendChild(empty);

    addDebugMarker();
    updateHeader();
    setStatus(`Loaded: ${source.id} • markers: ${markerGroup.children.length} (debug may be shown)`);
    rebuildLabels();
    updateCalloutsVisibility();
    return;
  }

  cands.forEach((c,i)=>{
    const m = addMarker(source, c, i);
    currentMarkers.push(m);
    try{ applyMarkerFxToMarker(m); }catch{}

    const item=document.createElement('div');
    item.className='item';
    item.dataset.idx=String(i);

    const left=document.createElement('div');
    left.className='left';
    left.textContent=String(i+1);

    const main=document.createElement('div');
    main.className='main';

    const name=document.createElement('div');
    name.className='name';
    name.textContent=candidateName(c);

    const meta=document.createElement('div');
    meta.className='meta';

    // swatch (persistent type coloring)
    const sw = document.createElement('div');
    sw.className = 'swatch';
    const ch = colorHexForCandidate(c);
    sw.style.background = `#${(ch>>>0).toString(16).padStart(6,'0')}`;

    const ck = candidateStableId(c);
    const adj = getPointAdj(source.id, ck);

    const lm = (c.LMID_ ? `LMID: ${c.LMID_}` : (c.dst_id ? `ID: ${c.dst_id}` : (c.osm_id ? `OSM: ${c.osm_id}` : '')));
    const vis = `vis ${fmt(getCandidateVisPct(c),0)}%`;
    const rb  = `rel ${fmt(Number(c.rel_bear ?? 0),1)}°`;
    const el  = `elev ${fmt(Number(c.elev_ang_d ?? 0),2)}°`;
    const d   = `dist ${fmt(getCandidateDistanceM(c),1)}m`;
    const pa  = `pt yaw ${fmt(adj.yaw,2)}° • pt pitch ${fmt(adj.pitch,2)}° • pt z ${fmt(adj.z,2)}m`;

    meta.innerHTML =
      `<span class="tag">${safeStr(c.dst_type||categoryOf(c)||'dst')}</span>` +
      (lm ? `<span class="tag">${lm}</span>` : '') +
      `<span class="tag">${vis}</span>` +
      `<span class="tag">${rb}</span>` +
      `<span class="tag">${el}</span>` +
      `<span class="tag">${d}</span>` +
      `<span class="tag">${pa}</span>`;

    const nameRow = document.createElement('div');
    nameRow.style.display = 'flex';
    nameRow.style.gap = '8px';
    nameRow.style.alignItems = 'flex-start';
    nameRow.appendChild(sw);
    nameRow.appendChild(name);

    main.appendChild(nameRow);
    main.appendChild(meta);

    item.appendChild(left);
    item.appendChild(main);

    item.addEventListener('mousemove', (e)=> setHovered(m, e.clientX, e.clientY));
    item.addEventListener('mouseleave', ()=> setHovered(null, 0, 0));

    item.addEventListener('click', ()=>{
      setSelected(m);
      setViewYawPitch(
        THREE.MathUtils.degToRad(m.userData.yawDeg),
        THREE.MathUtils.degToRad(m.userData.pitchDeg),
        true
      );
    });

    listEl.appendChild(item);
  });

  addDebugMarker();
  updateHeader();
  setStatus(`Loaded: ${source.id} • markers: ${markerGroup.children.length} (includes debug if on)`);

  rebuildLabels();
  updateCalloutsVisibility();

  // if we had a previously selected candKey and it still exists, restore selection
}

// --------------------
// Pano load
// --------------------
let currentTexture=null;
function loadPanoImage(source){
  return new Promise((resolve)=>{
    const imgRel = sourceToImagePath(source);
    if (!imgRel){
      sphereMesh.material = new THREE.MeshBasicMaterial({ color: 0x111111 });
      setStatus(`No image path for ${source.id}`);
      resolve(false);
      return;
    }

    setStatus(`Loading image: ${imgRel}`);
    const loader = new THREE.TextureLoader();
    loader.load(
      imgRel,
      (tex)=>{
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.needsUpdate = true;
        if (currentTexture) currentTexture.dispose();
        currentTexture = tex;
        sphereMesh.material = new THREE.MeshBasicMaterial({ map: tex });
        sphereMesh.material.needsUpdate = true;
        // ensure pano fade works
        sphereMesh.material.transparent = true;
        sphereMesh.material.opacity = (typeof overlayState !== 'undefined' && overlayState && overlayState.panoFade != null) ? overlayState.panoFade : 1.0;
        sphereMesh.material.needsUpdate = true;
        resolve(true);
      },
      undefined,
      (err)=>{
        console.error('Texture load failed', imgRel, err);
        sphereMesh.material = new THREE.MeshBasicMaterial({ color: 0x111111 });
        setStatus(`❌ Image failed: ${imgRel}`);
        resolve(false);
      }
    );
  });
}


function syncOverlayUI(){
  if (!overlayMesh) return;
  const op = ovOpacity ? parseFloat(ovOpacity.value) : 0.65;
  overlayMesh.material.opacity = Number.isFinite(op) ? op : 0.65;
}


/* ===========================
   Overlay (Rules + Presets)
   Ported from your overlay viewer
=========================== */

function ovSetStatus(msg){
  const el = document.getElementById('ovStatus');
  if (el) el.textContent = String(msg ?? '');
}

function safeUUID(){
  try{ return (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('r_'+Math.random().toString(16).slice(2)); }
  catch{ return 'r_'+Math.random().toString(16).slice(2); }
}

function defaultRule(){
  return {
    id: safeUUID(),
    name: "vegetation",
    hueMin: 70,
    hueMax: 170,
    action: "recolor",
    color: "#00ff5a",
    opacity: 1.0
  };
}

let overlayState = {
  mode: 0,
  showOverlay: true,
  overlayOpacity: 0.65,
  lineWidth: 0,
  maskThresh: 0.12,
  panoFade: 1.0,
  bgColor: "#0b0b0b",
  bgOpacity: 1.0,
  singleColor: "#00ffd0",
  minSat: 0.16,
  minVal: 0.10,
  rules: []
};

const PRESET_KEY = "todi_overlay_presets_v1";
const BUILTIN_PRESETS = [
  {
    name: "Original Tones with Lavender Background",
    settings: {
      "mode": 0,
      "showOverlay": true,
      "overlayOpacity": 0.53,
      "lineWidth": 0,
      "maskThresh": 0.37,
      "panoFade": 0.58,
      "bgColor": "#cca0e3",
      "singleColor": "#f7edf6",
      "minSat": 0.16,
      "minVal": 0.1,
      "rules": [],
      "meta": {
        "title": 'Todi',
        "lat": 42.780,
        "lon": 12.410,
        "epsg3857": { "x": 0, "y": 0 },
        "headingDeg": 0,
        "headingLabel": "N"
      }
    }
  },
  {
    name: "Monochrome green trees",
    settings: {
      "mode": 2,
      "showOverlay": true,
      "overlayOpacity": 0.95,
      "lineWidth": 0,
      "maskThresh": 0.12,
      "panoFade": 0.1,
      "bgColor": "#0b0b0b",
      "singleColor": "#00ffd0",
      "minSat": 0.16,
      "minVal": 0.1,
      "rules": [
        { "id": "a8b898bc-580b-4db0-8954-54b380451028", "name":"vegetation", "hueMin":54, "hueMax":120, "action":"recolor", "color":"#80a38c", "opacity":1 },
        { "id": "ed5afa3c-7724-4e0c-96f1-eb2bd1990440", "name":"sky", "hueMin":185, "hueMax":245, "action":"original", "color":"#33b7ff", "opacity":1 },
        { "id": "d19477d3-0e0e-43f0-bf01-38a525078a9d", "name":"stone", "hueMin":0, "hueMax":35, "action":"recolor", "color":"#b3846b", "opacity":0.43 }
      ]
    }
  },
  {
    name: "Light blue lines — pale tones",
    settings: {
      "mode": 1,
      "showOverlay": true,
      "overlayOpacity": 1,
      "lineWidth": 0,
      "maskThresh": 0.79,
      "panoFade": 0.38,
      "bgColor": "#e8d1a1",
      "singleColor": "#d5e6ec",
      "minSat": 0.16,
      "minVal": 0.1,
      "rules": []
    }
  },
  {
    name: "Mustard and light blue",
    settings: {
      "mode": 1,
      "showOverlay": true,
      "overlayOpacity": 0.65,
      "lineWidth": 0,
      "maskThresh": 0.84,
      "panoFade": 0.38,
      "bgColor": "#e5a315",
      "singleColor": "#d5e6ec",
      "minSat": 0.16,
      "minVal": 0.1,
      "rules": []
    }
  }
];

function loadPresetStore(){
  try{
    const raw = localStorage.getItem(PRESET_KEY);
    const list = raw ? JSON.parse(raw) : [];
    return Array.isArray(list) ? list : [];
  }catch{
    return [];
  }
}
function savePresetStore(list){ localStorage.setItem(PRESET_KEY, JSON.stringify(list)); }
function getAllPresets(){ return [...BUILTIN_PRESETS, ...loadPresetStore()]; }

function getOverlaySettings(){ return JSON.parse(JSON.stringify(overlayState)); }
function syncSettingsBox(){
  const box = document.getElementById('settingsBox');
  if (box) box.value = JSON.stringify(getOverlaySettings(), null, 2);
}

function encodeShareLink(){
  const json = JSON.stringify(getOverlaySettings());
  const b64 = btoa(unescape(encodeURIComponent(json)))
    .replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
  location.hash = "ov=" + b64;
  return location.href;
}
function decodeOverlayFromHash(){
  const h = location.hash || "";
  const m = h.match(/ov=([A-Za-z0-9\-_]+)/);
  if(!m) return null;
  const b64 = m[1].replace(/-/g,"+").replace(/_/g,"/");
  const pad = b64.length % 4 ? "=".repeat(4 - (b64.length % 4)) : "";
  try{
    const json = decodeURIComponent(escape(atob(b64 + pad)));
    return JSON.parse(json);
  }catch{ return null; }
}

function applyOverlaySettings(obj){
  overlayState = {
    ...overlayState,
    ...obj,
    rules: Array.isArray(obj?.rules) ? obj.rules : overlayState.rules
  };
  const modeSel = document.getElementById('modeSel');
  const toggleOverlay = document.getElementById('toggleOverlay');
  const overlayOpacity = document.getElementById('overlayOpacity');
  const overlayOpacityNum = document.getElementById('overlayOpacityNum');
  const lineWidth = document.getElementById('lineWidth');
  const lineWidthNum = document.getElementById('lineWidthNum');
  const maskThresh = document.getElementById('maskThresh');
  const maskThreshNum = document.getElementById('maskThreshNum');
  const panoFade = document.getElementById('panoFade');
  const panoFadeNum = document.getElementById('panoFadeNum');
  const bgColor = document.getElementById('bgColor');
  const bgOpacity = document.getElementById('bgOpacity');
  const bgOpacityNum = document.getElementById('bgOpacityNum');
  const singleColor = document.getElementById('singleColor');
  const minSat = document.getElementById('minSat');
  const minSatNum = document.getElementById('minSatNum');
  const minVal = document.getElementById('minVal');
  const minValNum = document.getElementById('minValNum');

  if (modeSel) modeSel.value = String(overlayState.mode);
  if (toggleOverlay) toggleOverlay.checked = !!overlayState.showOverlay;
  if (overlayOpacity) overlayOpacity.value = String(overlayState.overlayOpacity);
  if (lineWidth) lineWidth.value = String(overlayState.lineWidth);
  if (maskThresh) maskThresh.value = String(overlayState.maskThresh);
  if (panoFade) panoFade.value = String(overlayState.panoFade);
  if (bgColor) bgColor.value = overlayState.bgColor || "#0b0b0b";
  if (bgOpacity) bgOpacity.value = String(overlayState.bgOpacity ?? 1.0);
  if (bgOpacityNum) bgOpacityNum.value = String(overlayState.bgOpacity ?? 1.0);
  if (singleColor) singleColor.value = overlayState.singleColor || "#00ffd0";
  if (minSat) minSat.value = String(overlayState.minSat);
  if (minVal) minVal.value = String(overlayState.minVal);

  // apply to pano sphere
  try{
    if (sphereMesh && sphereMesh.material){
      sphereMesh.material.transparent = true;
      sphereMesh.material.opacity = overlayState.panoFade;
    }
  }catch{}

  // background
  try{
    document.body.style.background = overlayState.bgColor || "#000";
    if (renderer && renderer.setClearColor) renderer.setClearColor(new THREE.Color(overlayState.bgColor || "#000"), (overlayState.bgOpacity ?? 1.0));
  }catch{}

  refreshModeUI_Overlay();
  renderRulesUI();
  syncRulesToShader();
  syncSettingsBox();
}

let overlayShaderMaterial = null;

function buildOverlayMaterial(edgeTex, maskTex){
  if(edgeTex.colorSpace !== undefined) edgeTex.colorSpace = THREE.SRGBColorSpace;
  edgeTex.generateMipmaps = false;
  edgeTex.minFilter = THREE.LinearFilter;
  edgeTex.magFilter = THREE.LinearFilter;
  edgeTex.anisotropy = renderer.capabilities.getMaxAnisotropy();


  if(maskTex){
    if(maskTex.colorSpace !== undefined) maskTex.colorSpace = THREE.SRGBColorSpace;
    maskTex.generateMipmaps = false;
    maskTex.minFilter = THREE.LinearFilter;
    maskTex.magFilter = THREE.LinearFilter;
    maskTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
  }
  overlayShaderMaterial = new THREE.ShaderMaterial({
    transparent:true,
    depthWrite:false,
    depthTest:false,
    uniforms:{
      uTex:{value:edgeTex},
      uMask:{value:maskTex || edgeTex},
      uMode:{value:overlayState.mode},
      uOpacity:{value:overlayState.overlayOpacity},
      uWidth:{value:overlayState.lineWidth},
      uThresh:{value:overlayState.maskThresh},
      uSingle:{value:new THREE.Color(overlayState.singleColor)},
      uMinSat:{value:overlayState.minSat},
      uMinVal:{value:overlayState.minVal},
      uRuleCount:{value:0},
      uHueMin:{value:new Array(12).fill(0)},
      uHueMax:{value:new Array(12).fill(0)},
      uAction:{value:new Array(12).fill(0)},
      uColor:{value:new Array(12).fill(0).map(()=>new THREE.Color("#ffffff"))},
      uOpacityRule:{value:new Array(12).fill(1)},
    },
    vertexShader:`
      varying vec2 vUv;
      void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.); }
    `,
    fragmentShader:`
      varying vec2 vUv;
      uniform sampler2D uTex;
      uniform sampler2D uMask;

      uniform int uMode;
      uniform float uOpacity;
      uniform float uWidth;
      uniform float uThresh;

      uniform vec3 uSingle;

      uniform float uMinSat;
      uniform float uMinVal;

      uniform int uRuleCount;
      uniform float uHueMin[12];
      uniform float uHueMax[12];
      uniform int uAction[12];
      uniform vec3 uColor[12];
      uniform float uOpacityRule[12];

      vec3 rgb2hsv(vec3 c){
        vec4 K=vec4(0.,-1./3.,2./3.,-1.);
        vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));
        vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));
        float d=q.x-min(q.w,q.y);
        return vec3(abs(q.z+(q.w-q.y)/(6.*d+.0001)), d/(q.x+.0001), q.x);
      }
      bool hueIn(float h, float mn, float mx){
        if(mn<=mx) return (h>=mn && h<=mx);
        return (h>=mn || h<=mx);
      }

      float rawMask(vec4 t){
        float a = (t.a > 0.01) ? t.a : dot(t.rgb, vec3(0.2126,0.7152,0.0722));
        return clamp(a, 0.0, 1.0);
      }
      float maskCrisp(float a){
        return smoothstep(uThresh, uThresh + 0.03, a);
      }

      float growOnce(vec2 uv){
        vec2 texel = 1.0 / vec2(textureSize(uMask,0));
        float m = maskCrisp(rawMask(texture2D(uMask, uv)));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2( texel.x, 0.0)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2(-texel.x, 0.0)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2(0.0,  texel.y)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2(0.0, -texel.y)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2( texel.x,  texel.y)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2(-texel.x,  texel.y)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2( texel.x, -texel.y)))));
        m = max(m, maskCrisp(rawMask(texture2D(uTex, uv + vec2(-texel.x, -texel.y)))));
        return m;
      }

      void main(){
        vec4 t = texture2D(uTex, vUv);

        float a = maskCrisp(rawMask(t));

        
        int N = int(clamp(uWidth, 0.0, 6.0) + 0.5);
        float m = a;

        // Better "thicken lines" sampling: expand radius in texels up to N
        vec2 texel = 1.0 / vec2(textureSize(uMask,0));
        for(int r=1; r<=6; r++){
          if(r > N) break;
          float rr = float(r);
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2( rr*texel.x, 0.0)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2(-rr*texel.x, 0.0)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2(0.0,  rr*texel.y)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2(0.0, -rr*texel.y)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2( rr*texel.x,  rr*texel.y)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2(-rr*texel.x,  rr*texel.y)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2( rr*texel.x, -rr*texel.y)))));
          m = max(m, maskCrisp(rawMask(texture2D(uMask, vUv + vec2(-rr*texel.x, -rr*texel.y)))));
        }

        a = m * uOpacity;

        if(a < 0.002) discard;

        vec3 col = t.rgb;

        if(uMode == 1){
          col = uSingle;
        } else if(uMode == 2){
          vec3 hsv = rgb2hsv(t.rgb);
          float h = hsv.x;
          float s = hsv.y;
          float v = hsv.z;

          bool ok = (s >= uMinSat) && (v >= uMinVal);
          if(ok){
            for(int i=0;i<12;i++){
              if(i >= uRuleCount) break;
              if(hueIn(h, uHueMin[i], uHueMax[i])){
                if(uAction[i] == 1){
                  float k = clamp(uOpacityRule[i], 0.0, 1.0);
                  col = mix(t.rgb, uColor[i], k);
                }
                break;
              }
            }
          }
        }

        gl_FragColor = vec4(col, a);
      }
    `
  });

  syncRulesToShader();
  return overlayShaderMaterial;
}

function syncRulesToShader(){
  if(!overlayShaderMaterial) return;
  const maxRules = 12;
  const rules = (overlayState.rules || []).slice(0, maxRules);

  overlayShaderMaterial.uniforms.uRuleCount.value = rules.length;
  overlayShaderMaterial.uniforms.uMinSat.value = overlayState.minSat;
  overlayShaderMaterial.uniforms.uMinVal.value = overlayState.minVal;

  for(let i=0;i<maxRules;i++){
    if(i < rules.length){
      overlayShaderMaterial.uniforms.uHueMin.value[i] = ((rules[i].hueMin % 360) / 360);
      overlayShaderMaterial.uniforms.uHueMax.value[i] = ((rules[i].hueMax % 360) / 360);
      overlayShaderMaterial.uniforms.uAction.value[i] = (rules[i].action === "recolor") ? 1 : 0;
      overlayShaderMaterial.uniforms.uColor.value[i].set(rules[i].color || "#ffffff");
      overlayShaderMaterial.uniforms.uOpacityRule.value[i] = (rules[i].opacity ?? 1.0);
    }else{
      overlayShaderMaterial.uniforms.uHueMin.value[i] = 0;
      overlayShaderMaterial.uniforms.uHueMax.value[i] = 0;
      overlayShaderMaterial.uniforms.uAction.value[i] = 0;
      overlayShaderMaterial.uniforms.uColor.value[i].set("#ffffff");
      overlayShaderMaterial.uniforms.uOpacityRule.value[i] = 1.0;
    }
  }

  overlayShaderMaterial.uniforms.uMode.value = overlayState.mode;
  overlayShaderMaterial.uniforms.uOpacity.value = overlayState.overlayOpacity;
  overlayShaderMaterial.uniforms.uWidth.value = overlayState.lineWidth;
  overlayShaderMaterial.uniforms.uThresh.value = overlayState.maskThresh;
  overlayShaderMaterial.uniforms.uSingle.value.set(overlayState.singleColor);

  overlayShaderMaterial.needsUpdate = true;
}

function refreshModeUI_Overlay(){
  const modeSel = document.getElementById('modeSel');
  const singleGroup = document.getElementById('singleGroup');
  const rulesGroup = document.getElementById('rulesGroup');
  const m = parseInt(modeSel?.value ?? "0", 10);
  if (singleGroup) singleGroup.style.display = (m === 1) ? "" : "none";
  if (rulesGroup) rulesGroup.style.display  = (m === 2) ? "" : "none";
  overlayState.mode = m;
  if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uMode.value = overlayState.mode;
}

function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;" }[c])); }
function escapeAttr(s){ return escapeHtml(s).replace(/'/g,"&#39;"); }

function hueToHex(h){
  const c = new THREE.Color().setHSL((((h%360)+360)%360)/360, 1, 0.5);
  return "#" + c.getHexString();
}
function clampHue(x){
  const n = Number(x);
  if(!Number.isFinite(n)) return 0;
  return Math.max(0, Math.min(360, Math.round(n)));
}
function pctFromHue(h){ return clampHue(h) / 360; }
function hueFromPct(p){ return clampHue(Math.round(p * 360)); }

function renderRulesUI(){
  const panel = document.getElementById("rulesPanel");
  if (!panel) return;
  panel.innerHTML = "";

  (overlayState.rules || []).forEach((r, idx)=>{
    if(!r.action) r.action = "recolor";
    if(r.opacity == null) r.opacity = 1.0;
    if(r.color == null) r.color = "#ffffff";
    r.hueMin = clampHue(r.hueMin);
    r.hueMax = clampHue(r.hueMax);

    const card = document.createElement("div");
    card.className = "rule";

    card.innerHTML = `
      <div class="ruleHead">
        <b>${escapeHtml(r.name || ("Rule " + (idx+1)))}</b>
        <div class="ruleBtns">
          <span class="mini">#${idx+1}</span>
          <button data-act="up" ${idx===0?"disabled":""}>↑</button>
          <button data-act="down" ${idx===overlayState.rules.length-1?"disabled":""}>↓</button>
          <button data-act="del">Delete</button>
        </div>
      </div>

      <div class="ruleGrid">
        <div class="lbl">Name</div>
        <input data-k="name" type="text" value="${escapeAttr(r.name || "")}" />
        <div class="right"></div>

        <div class="lbl">Hue</div>
        <div>
          <div class="huePicker" data-role="picker" title="Click to jump, drag to adjust">
            <div class="hueTrack"></div>
            <div class="hueHandle" data-role="minHandle" title="Min"></div>
            <div class="hueHandle" data-role="maxHandle" title="Max"></div>
          </div>

          <div class="hueSwatches">
            <div class="hueSwatch" data-role="minSwatch"></div>
            <span class="hueSwatchLabel">min</span>
            <div class="hueSwatch" data-role="maxSwatch"></div>
            <span class="hueSwatchLabel">max</span>
          </div>
          <div class="mini">${r.hueMin > r.hueMax ? "wraps around red" : ""}</div>
        </div>
        <div class="right"></div>

        <div class="lbl">Action</div>
        <div style="display:flex;gap:8px;align-items:center">
          <select data-k="action">
            <option value="recolor" ${r.action==="recolor"?"selected":""}>Recolour</option>
            <option value="original" ${r.action==="original"?"selected":""}>Keep original</option>
          </select>
          <input data-k="color" type="color" value="${escapeAttr(r.color)}" title="Target colour"/>
        </div>
        <div class="right"></div>

        <div class="lbl">Opacity</div>
        <input data-k="opacity" type="range" min="0" max="1" step="0.01" value="${Number(r.opacity ?? 1.0)}" />
        <div class="right"></div>
      </div>
    `;

    card.querySelectorAll("button[data-act]").forEach(btn=>{
      btn.onclick = ()=>{
        const act = btn.getAttribute("data-act");
        if(act==="del"){
          overlayState.rules.splice(idx, 1);
        } else if(act==="up" && idx>0){
          const t=overlayState.rules[idx-1]; overlayState.rules[idx-1]=overlayState.rules[idx]; overlayState.rules[idx]=t;
        } else if(act==="down" && idx<overlayState.rules.length-1){
          const t=overlayState.rules[idx+1]; overlayState.rules[idx+1]=overlayState.rules[idx]; overlayState.rules[idx]=t;
        }
        renderRulesUI();
        syncRulesToShader();
        syncSettingsBox();
      };
    });

    const picker = card.querySelector('[data-role="picker"]');
    const minHandle = card.querySelector('[data-role="minHandle"]');
    const maxHandle = card.querySelector('[data-role="maxHandle"]');
    const minSw = card.querySelector('[data-role="minSwatch"]');
    const maxSw = card.querySelector('[data-role="maxSwatch"]');

    function setActive(which){
      minHandle.classList.toggle("active", which==="min");
      maxHandle.classList.toggle("active", which==="max");
    }
    function updateHueUI(){
      minHandle.style.left = (pctFromHue(r.hueMin)*100) + "%";
      maxHandle.style.left = (pctFromHue(r.hueMax)*100) + "%";
      minSw.style.background = hueToHex(r.hueMin);
      maxSw.style.background = hueToHex(r.hueMax);
    }
    updateHueUI();

    let active = null;
    function pointerPct(e){
      const rect = picker.getBoundingClientRect();
      return Math.min(1, Math.max(0, (e.clientX - rect.left) / rect.width));
    }

    picker.onpointerdown = (e)=>{
      const p = pointerPct(e);
      const dMin = Math.abs(p - pctFromHue(r.hueMin));
      const dMax = Math.abs(p - pctFromHue(r.hueMax));
      active = (dMin <= dMax) ? "min" : "max";

      const h = hueFromPct(p);
      if(active === "min") r.hueMin = h;
      else r.hueMax = h;

      setActive(active);
      updateHueUI();
      syncRulesToShader();
      syncSettingsBox();

      picker.setPointerCapture(e.pointerId);
    };

    picker.onpointermove = (e)=>{
      if(!active) return;
      const h = hueFromPct(pointerPct(e));
      if(active === "min") r.hueMin = h;
      else r.hueMax = h;

      updateHueUI();
      syncRulesToShader();
      syncSettingsBox();
    };

    picker.onpointerup = ()=>{ active=null; setActive(null); };
    picker.onpointerleave = ()=>{ active=null; setActive(null); };

    const colorInp  = card.querySelector('[data-k="color"]');
    const opacityInp= card.querySelector('[data-k="opacity"]');

    function refreshRecolorVisibility(){
      const on = (r.action === "recolor");
      colorInp.style.display = on ? "" : "none";
      opacityInp.disabled = !on;
      opacityInp.style.opacity = on ? "1" : "0.55";
    }
    refreshRecolorVisibility();

    card.querySelectorAll("[data-k]").forEach(inp=>{
      inp.oninput = ()=>{
        const k = inp.getAttribute("data-k");
        if(k === "action"){
          r.action = inp.value;
          refreshRecolorVisibility();
          syncRulesToShader();
          syncSettingsBox();
          return;
        }
        if(k === "color"){
          r.color = inp.value;
        } else if(k === "opacity"){
          r.opacity = Math.max(0, Math.min(1, parseFloat(inp.value)));
        } else {
          r[k] = inp.value;
        }
        syncRulesToShader();
        syncSettingsBox();
      };
    });

    panel.appendChild(card);
  });
}

function refreshPresetList(){
  const presetSel = document.getElementById('presetSel');
  if (!presetSel) return;
  const all = getAllPresets();
  presetSel.innerHTML = "";
  all.forEach((p,i)=>{
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = p.name;
    presetSel.appendChild(opt);
  });
}

async function copyOverlaySettings(){
  const txt = JSON.stringify(getOverlaySettings(), null, 2);
  const box = document.getElementById('settingsBox');
  if (box) box.value = txt;
  try{
    await navigator.clipboard.writeText(txt);
    ovSetStatus("Settings copied ✔");
  }catch{
    ovSetStatus("Copied to box (clipboard blocked) ✔");
  }
}

function exportPNG(){
  // render both scenes in the same order as your app
  try{
    renderer.clear();
    renderer.render(scenePano, camera);
    renderer.clearDepth();
    renderer.render(sceneOverlay, camera);
  }catch(e){
    console.warn("export render fail", e);
  }

  const stamp = new Date().toISOString().replace(/[:.]/g,"-");
  const filename = "todi_overlay_" + stamp + ".png";

  renderer.domElement.toBlob((blob)=>{
    if(!blob){
      const url = renderer.domElement.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
      ovSetStatus("Exported PNG (fallback) ✔\n" + filename);
      return;
    }
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
    ovSetStatus("Exported PNG ✔\n" + filename);
  }, "image/png");
}

function hookOverlayUI(){
  const shared = decodeOverlayFromHash();
  if(shared) applyOverlaySettings(shared);

  const modeSel = document.getElementById('modeSel');
  const toggleOverlay = document.getElementById('toggleOverlay');
  const overlayOpacity = document.getElementById('overlayOpacity');
  const overlayOpacityNum = document.getElementById('overlayOpacityNum');
  const lineWidth = document.getElementById('lineWidth');
  const lineWidthNum = document.getElementById('lineWidthNum');
  const maskThresh = document.getElementById('maskThresh');
  const maskThreshNum = document.getElementById('maskThreshNum');
  const panoFade = document.getElementById('panoFade');
  const panoFadeNum = document.getElementById('panoFadeNum');
  const bgColor = document.getElementById('bgColor');
  const bgOpacity = document.getElementById('bgOpacity');
  const bgOpacityNum = document.getElementById('bgOpacityNum');
  const singleColor = document.getElementById('singleColor');
  const minSat = document.getElementById('minSat');
  const minSatNum = document.getElementById('minSatNum');
  const minVal = document.getElementById('minVal');
  const minValNum = document.getElementById('minValNum');
  const addRuleBtn = document.getElementById('addRuleBtn');

  const exportPngBtn = document.getElementById('exportPngBtn');
  const copySettingsBtn = document.getElementById('copySettingsBtn');
  const shareLinkBtn = document.getElementById('shareLinkBtn');
  const applySettingsBtn = document.getElementById('applySettingsBtn');

  const presetName = document.getElementById('presetName');
  const savePresetBtn = document.getElementById('savePresetBtn');
  const presetSel = document.getElementById('presetSel');
  const loadPresetBtn = document.getElementById('loadPresetBtn');
  const deletePresetBtn = document.getElementById('deletePresetBtn');
  const settingsBox = document.getElementById('settingsBox');

  // collapse
  const collapseBtn = document.getElementById('ovCollapseBtn');
  const panel = document.getElementById('uiOverlay');
  if (collapseBtn && panel){
    collapseBtn.onclick = ()=>{
      panel.classList.toggle('collapsed');
      collapseBtn.textContent = panel.classList.contains('collapsed') ? "Expand" : "Collapse";
    };
  }

  refreshPresetList();
  renderRulesUI();
  refreshModeUI_Overlay();
  syncSettingsBox();

  if (exportPngBtn) exportPngBtn.onclick = exportPNG;
  if (copySettingsBtn) copySettingsBtn.onclick = copyOverlaySettings;
  if (shareLinkBtn) shareLinkBtn.onclick = async ()=>{
    const url = encodeShareLink();
    try{ await navigator.clipboard.writeText(url); ovSetStatus("Share link copied ✔"); }
    catch{ ovSetStatus("Share link set in URL bar (copy it) ✔"); }
  };
  if (applySettingsBtn) applySettingsBtn.onclick = ()=>{
    try{
      const obj = JSON.parse(settingsBox.value);
      applyOverlaySettings(obj);
      ovSetStatus("Settings applied ✔");
    }catch(err){
      ovSetStatus("Invalid JSON:\n" + (err?.message || err));
    }
  };

  if (toggleOverlay) toggleOverlay.onchange = e=>{
    overlayState.showOverlay = e.target.checked;
    if (overlayMesh) overlayMesh.visible = overlayState.showOverlay;
    syncSettingsBox();
  };

  if (modeSel) modeSel.onchange = ()=>{
    refreshModeUI_Overlay();
    syncRulesToShader();
    syncSettingsBox();
  };

  if (singleColor) singleColor.oninput = e=>{
    overlayState.singleColor = e.target.value;
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uSingle.value.set(overlayState.singleColor);
    syncSettingsBox();
  };

  if (overlayOpacity) overlayOpacity.oninput = e=>{
    overlayState.overlayOpacity = parseFloat(e.target.value);
    if (overlayOpacityNum) overlayOpacityNum.value = String(overlayState.overlayOpacity);
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uOpacity.value = overlayState.overlayOpacity;
    syncSettingsBox();
  };

  if (overlayOpacityNum) overlayOpacityNum.oninput = e=>{
    overlayState.overlayOpacity = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    overlayOpacity.value = String(overlayState.overlayOpacity);
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uOpacity.value = overlayState.overlayOpacity;
    syncSettingsBox();
  };

  if (lineWidth) lineWidth.oninput = e=>{
    overlayState.lineWidth = parseFloat(e.target.value);
    if (lineWidthNum) lineWidthNum.value = String(overlayState.lineWidth);
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uWidth.value = overlayState.lineWidth;
    syncSettingsBox();
  };

  if (lineWidthNum) lineWidthNum.oninput = e=>{
    overlayState.lineWidth = Math.max(0, Math.min(6, parseFloat(e.target.value)));
    lineWidth.value = String(overlayState.lineWidth);
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uWidth.value = overlayState.lineWidth;
    syncSettingsBox();
  };

  if (maskThresh) maskThresh.oninput = e=>{
    overlayState.maskThresh = parseFloat(e.target.value);
    if (maskThreshNum) maskThreshNum.value = String(overlayState.maskThresh);
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uThresh.value = overlayState.maskThresh;
    syncSettingsBox();
  };

  if (maskThreshNum) maskThreshNum.oninput = e=>{
    overlayState.maskThresh = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    maskThresh.value = String(overlayState.maskThresh);
    if (overlayShaderMaterial) overlayShaderMaterial.uniforms.uThresh.value = overlayState.maskThresh;
    syncSettingsBox();
  };

  if (panoFade) panoFade.oninput = e=>{
    overlayState.panoFade = parseFloat(e.target.value);
    if (panoFadeNum) panoFadeNum.value = String(overlayState.panoFade);
    try{
      if (sphereMesh && sphereMesh.material) sphereMesh.material.opacity = overlayState.panoFade;
    }catch{}
    syncSettingsBox();
  };

  if (panoFadeNum) panoFadeNum.oninput = e=>{
    overlayState.panoFade = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    panoFade.value = String(overlayState.panoFade);
    try{ if (sphereMesh && sphereMesh.material) sphereMesh.material.opacity = overlayState.panoFade; }catch{}
    syncSettingsBox();
  };

  if (bgColor) bgColor.oninput = e=>{
    overlayState.bgColor = e.target.value;
    try{
      document.body.style.background = overlayState.bgColor;
      if (renderer && renderer.setClearColor) renderer.setClearColor(new THREE.Color(overlayState.bgColor), (overlayState.bgOpacity ?? 1.0));
    }catch{}
    syncSettingsBox();
  };

  if (bgOpacity) bgOpacity.oninput = e=>{
    overlayState.bgOpacity = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    if (bgOpacityNum) bgOpacityNum.value = String(overlayState.bgOpacity);
    try{ if (renderer && renderer.setClearColor) renderer.setClearColor(new THREE.Color(overlayState.bgColor || '#000'), overlayState.bgOpacity); }catch{}
    syncSettingsBox();
  };
  if (bgOpacityNum) bgOpacityNum.oninput = e=>{
    overlayState.bgOpacity = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    if (bgOpacity) bgOpacity.value = String(overlayState.bgOpacity);
    try{ if (renderer && renderer.setClearColor) renderer.setClearColor(new THREE.Color(overlayState.bgColor || '#000'), overlayState.bgOpacity); }catch{}
    syncSettingsBox();
  };

  if (minSat) minSat.oninput = e=>{
    overlayState.minSat = parseFloat(e.target.value);
    if (minSatNum) minSatNum.value = String(overlayState.minSat);
    syncRulesToShader(); syncSettingsBox();
  };

  if (minSatNum) minSatNum.oninput = e=>{
    overlayState.minSat = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    minSat.value = String(overlayState.minSat);
    syncRulesToShader(); syncSettingsBox();
  };
  if (minVal) minVal.oninput = e=>{
    overlayState.minVal = parseFloat(e.target.value);
    if (minValNum) minValNum.value = String(overlayState.minVal);
    syncRulesToShader(); syncSettingsBox();
  };

  if (minValNum) minValNum.oninput = e=>{
    overlayState.minVal = Math.max(0, Math.min(1, parseFloat(e.target.value)));
    minVal.value = String(overlayState.minVal);
    syncRulesToShader(); syncSettingsBox();
  };

  if (addRuleBtn) addRuleBtn.onclick = ()=>{
    const suggested = ["vegetation","sky","stone"];
    const used = new Set((overlayState.rules||[]).map(x => (x.name||"").toLowerCase()));
    const pick = suggested.find(n => !used.has(n)) || "vegetation";
    const nr = defaultRule();
    nr.name = pick;
    overlayState.rules.push(nr);
    renderRulesUI(); syncRulesToShader(); syncSettingsBox();
    const rp = document.getElementById('rulesPanel');
    if (rp) rp.scrollTop = rp.scrollHeight;
  };

  if (savePresetBtn) savePresetBtn.onclick = ()=>{
    const name = (presetName?.value || "").trim();
    if(!name){ ovSetStatus("Preset needs a name."); return; }
    const list = loadPresetStore();
    list.push({ name, settings: getOverlaySettings() });
    savePresetStore(list);
    refreshPresetList();
    ovSetStatus("Preset saved ✔");
  };

  if (loadPresetBtn) loadPresetBtn.onclick = ()=>{
    const i = parseInt(presetSel?.value ?? "-1",10);
    const list = getAllPresets();
    if(!list[i]){ ovSetStatus("No preset selected."); return; }
    applyOverlaySettings(list[i].settings);
    ovSetStatus("Preset loaded ✔");
  };

  if (deletePresetBtn) deletePresetBtn.onclick = ()=>{
    const i = parseInt(presetSel?.value ?? "-1",10);
    const builtins = BUILTIN_PRESETS.length;
    if(i < builtins){ ovSetStatus("Built-in preset cannot be deleted."); return; }
    const userIndex = i - builtins;
    const user = loadPresetStore();
    if(!user[userIndex]){ ovSetStatus("No user preset selected."); return; }
    user.splice(userIndex, 1);
    savePresetStore(user);
    refreshPresetList();
    ovSetStatus("User preset deleted ✔");
  };
}


function loadOverlayForSource(source){
  return new Promise((resolve)=>{
    try{
      const kind = (document.getElementById('ovType')?.value) || 'edges';
      const p = overlayPathForSource(source, kind);
      if (!p){
        overlayMesh.visible = false;
        resolve(false);
        return;
      }

      // Always load mask alongside colour/edges so threshold + width operate on a stable mask.
      const maskKind = (document.getElementById('maskKindSel')?.value) || 'edges_mask';
      const pMask = overlayPathForSource(source, maskKind);

      const loaderA = new THREE.TextureLoader();
      const loaderB = new THREE.TextureLoader();

      let texA = null, texM = null;
      let done = 0;
      function finish(){
        done++;
        if(done < 2) return;

        if(!texA){
          overlayMesh.visible = false;
          ovSetStatus("Overlay load failed:\n" + p);
          resolve(false);
          return;
        }

        overlayMesh.material = buildOverlayMaterial(texA, texM || texA);
        overlayMesh.material.needsUpdate = true;
        overlayMesh.visible = !!overlayState.showOverlay;

        syncRulesToShader();
        ovSetStatus("Overlay loaded ✔\n" + p + (texM ? "\n(mask ✔)" : "\n(mask missing)"));

        resolve(true);
      }

      loaderA.load(
        p,
        (tex)=>{
          tex.colorSpace = THREE.SRGBColorSpace;
          tex.needsUpdate = true;
          if (overlayTexture) overlayTexture.dispose();
          overlayTexture = tex;
          texA = tex;
          finish();
        },
        undefined,
        (err)=>{
          console.warn('Overlay load failed:', p, err);
          texA = null;
          finish();
        }
      );

      loaderB.load(
        pMask,
        (tex)=>{
          tex.colorSpace = THREE.SRGBColorSpace;
          tex.needsUpdate = true;
          texM = tex;
          finish();
        },
        undefined,
        (err)=>{
          console.warn('Mask load failed (continuing):', pMask, err);
          texM = null;
          finish();
        }
      );

    }catch(e){
      console.warn('Overlay load error', e);
      overlayMesh.visible = false;
      ovSetStatus("Overlay load error.");
      resolve(false);
    }
  });
}




// --------------------
// Navigation
// --------------------
async function setSourceByIndex(idx){
  idx = clamp(idx, 0, SOURCES.length-1);
  currentIndex = idx;
  { const sel=document.getElementById('sourceSelect'); if (sel) sel.value=String(currentIndex); }
const s=currentSource();
  if (!s) return;

  await loadPanoImage(s);

  await loadOverlayForSource(s);

  
  loadSkyMaskForSource(s);
yaw = 0; pitch = 0; animating = false;

  rebuildMarkersAndList();
}

function nextSource(){ setSourceByIndex(currentIndex+1); }
function prevSource(){ setSourceByIndex(currentIndex-1); }

// --------------------
// Mouse reticle + mouse snap placement
// --------------------
function showReticle(show){
  reticleWrap.style.display = show ? 'block' : 'none';
}
function reticleEnabled(){
  const v = placeModeSel.value;
  return v === 'mouse' || v === 'both';
}
function arrowsEnabled(){
  const v = placeModeSel.value;
  return v === 'arrows' || v === 'both';
}

function setReticleAt(clientX, clientY){
  reticleWrap.style.left = clientX + 'px';
  reticleWrap.style.top  = clientY + 'px';
}

function updateReticleReadout(){
  // show camera yaw/pitch under cursor (same as camera forward direction; actual snap uses cursor ray)
  // We'll update dynamically from cursor ray when moving.
}

function snapCandidateToMouse(){
  // Applies a per-point yaw/pitch adjustment so the selected candidate lands under the cursor ray.
  const s=currentSource();
  if (!s) return false;

  if (!selected || selected.userData?.idx < 0){
    setStatus('⚠ Select a point first, then use mouse snap.');
    return false;
  }
  if (adjustModeSel.value !== 'point'){
    setStatus('ℹ Mouse snap writes to Selected point offsets. Switch Adjust mode → Selected point.');
    return false;
  }

  // Get current cursor ray -> direction in world
  raycaster.setFromCamera(mouse, camera);
  const rayDir = raycaster.ray.direction.clone().normalize();
  const target = dirToYawPitchDeg(rayDir);

  const ck = selected.userData.candKey;
  const c  = selected.userData.cand;

  const baseRel  = Number(c.rel_bear ?? 0);
  const baseElev = Number(c.elev_ang_d ?? 0);
  const dist     = getCandidateDistanceM(c);

  const offYaw = getOffsetDeg(s.id);
  const offZ_m = getZOffsetM(s.id);

  // Desired final yaw/pitch (what the user clicked on)
  const desiredYawDeg = target.yawDeg;
  const desiredPitchDeg = clamp(target.pitchDeg, -MAX_PITCH_DEG, MAX_PITCH_DEG);

  // We solve for point yaw so that:
  // yawFinal = norm360(baseRel - offYaw - pointYaw)  =>  pointYaw = baseRel - offYaw - yawFinal
  const newPointYaw = (baseRel - offYaw - desiredYawDeg);

  // For pitch: pitchFinal = baseElev + zDeg(globalZ) + zDeg(pointZ) + pointPitch
  // We'll keep pointZ as-is, and solve pointPitch to match desiredPitch
  const existing = getPointAdj(s.id, ck);
  const zGlobalDeg = zMetersToDeg(offZ_m, dist);
  const zPointDeg  = zMetersToDeg((existing.z||0), dist);
  const newPointPitch = desiredPitchDeg - (baseElev + zGlobalDeg + zPointDeg);

  setPointAdj(s.id, ck, {
    yaw: newPointYaw,
    pitch: newPointPitch,
    z: existing.z || 0
  });

  // rebuild and restore selection
  const keepKey = ck;
  rebuildMarkersAndList();
  const match = currentMarkers.find(m=>m.userData?.candKey === keepKey);
  if (match){
    setSelected(match);
  }

  setStatus(`✅ Mouse snapped: ${keepKey}`);

  // Auto-advance if enabled
  if (autoNextIn.checked){
    advanceToNextCandidate();
  }

  return true;
}

function advanceToNextCandidate(){
  if (!selected || selected.userData?.idx == null) return;
  const idx = selected.userData.idx;
  const nextIdx = idx + 1;

  if (nextIdx >= currentMarkers.length){
    setStatus('ℹ Reached end of candidate list.');
    return;
  }
  const m = currentMarkers[nextIdx];
  if (!m) return;

  setSelected(m);
  setViewYawPitch(
    THREE.MathUtils.degToRad(m.userData.yawDeg),
    THREE.MathUtils.degToRad(m.userData.pitchDeg),
    true
  );
}

// --------------------
// Pointer events
// --------------------
renderer.domElement.addEventListener('pointerdown', (e)=>{
  dragging=true; lastX=e.clientX; lastY=e.clientY;
  renderer.domElement.setPointerCapture(e.pointerId);
});

renderer.domElement.addEventListener('pointerup', (e)=>{
  dragging=false;
  try { renderer.domElement.releasePointerCapture(e.pointerId); } catch {}
});

renderer.domElement.addEventListener('pointermove', (e)=>{
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);

  doHover(e.clientX, e.clientY);

  // Reticle follows cursor when enabled and a valid point is selected
  const show = reticleEnabled() && !!selected && selected.userData?.idx >= 0;
  showReticle(show);
  if (show){
    setReticleAt(e.clientX, e.clientY);

    // update live cursor yaw/pitch (ray direction)
    raycaster.setFromCamera(mouse, camera);
    const d = raycaster.ray.direction.clone().normalize();
    const yp = dirToYawPitchDeg(d);
    reticleA.textContent = `yaw ${fmt(yp.yawDeg,1)}°`;
    reticleB.textContent = `pitch ${fmt(yp.pitchDeg,1)}°`;
  }

  // drag to rotate camera (always)
  if (!dragging) return;
  const dx=e.clientX-lastX;
  const dy=e.clientY-lastY;
  lastX=e.clientX; lastY=e.clientY;

  const s=0.0032;
  yaw   -= dx*s;
  pitch -= dy*s;
  animating=false;
});

// Click behaviour:
// - if mouse snap enabled and point selected: left click snaps
// - else click selects marker (existing behaviour)
renderer.domElement.addEventListener('click', (e)=>{
  // if in mouse snap mode, snap selected to cursor regardless of marker hit
  if (reticleEnabled() && selected && selected.userData?.idx >= 0 && adjustModeSel.value === 'point'){
    // only trigger if user isn't clicking UI
    const uiRect = document.getElementById('ui').getBoundingClientRect();
    const inUI = (e.clientX >= uiRect.left && e.clientX <= uiRect.right && e.clientY >= uiRect.top && e.clientY <= uiRect.bottom);
    if (!inUI){
      snapCandidateToMouse();
      return;
    }
  }

  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(markerGroup.children, true);
  if (!hits.length) return;

  const root = markerRootFromObject(hits[0].object);
  if (!root) return;

  if (root.userData.idx === -1) {
    setViewYawPitch(0,0,true);
    return;
  }

  setSelected(root);
  setViewYawPitch(
    THREE.MathUtils.degToRad(root.userData.yawDeg),
    THREE.MathUtils.degToRad(root.userData.pitchDeg),
    true
  );
});

renderer.domElement.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const f=clamp(camera.fov + (e.deltaY*0.02), 35, 95);
  camera.fov=f;
  camera.updateProjectionMatrix();
}, { passive:false });

// --------------------
// UI events
// --------------------
prevBtn && prevBtn.addEventListener('click', prevSource);
nextBtn && nextBtn.addEventListener('click', nextSource);

sourceSelect && sourceSelect.addEventListener('change', ()=>{
  const idx=parseInt((document.getElementById('sourceSelect')?.value),10);
  if (Number.isFinite(idx)) setSourceByIndex(idx);
});

// filters rebuild
function rebuildFromFilters(){
  rebuildMarkersAndList();
}
visFilterSel.addEventListener('change', rebuildFromFilters);
categoryFilterSel.addEventListener('change', rebuildFromFilters);
landmarkFilterSel.addEventListener('change', rebuildFromFilters);
minVis.addEventListener('change', rebuildFromFilters);
topN.addEventListener('change', rebuildFromFilters);
mWorld.addEventListener('change', rebuildFromFilters);
debugDotIn.addEventListener('change', rebuildFromFilters);
riseWorldIn.addEventListener('change', rebuildFromFilters);
sqWorldIn.addEventListener('change', rebuildFromFilters);
lblWorldIn.addEventListener('change', rebuildFromFilters);
animSecondsIn?.addEventListener('input', ()=>{});
animSecondsIn?.addEventListener('change', ()=>{});
loopCalloutIn?.addEventListener('change', ()=>{});
riseWorldIn.addEventListener('input', rebuildFromFilters);
sqWorldIn.addEventListener('input', rebuildFromFilters);
lblWorldIn.addEventListener('input', rebuildFromFilters);
fontSel?.addEventListener('change', ()=>{
  currentLabelFontStack = FONT_STACKS[fontSel.value] || FONT_STACKS.helvetica;
  rebuildFromFilters();
});

distMaxIn.addEventListener('input', ()=>{
  distMaxLabel.textContent = `≤ ${distMaxIn.value}m`;
  rebuildFromFilters();
});
distMaxLabel.textContent = `≤ ${distMaxIn.value}m`;

showLabelsIn.addEventListener('change', rebuildLabels);
calloutsIn.addEventListener('change', updateCalloutsVisibility);
allCalloutsIn.addEventListener('change', updateCalloutsVisibility);

function applyExposure(){
  const v=parseFloat(exposureIn.value);
  renderer.toneMappingExposure = Number.isFinite(v) ? clamp(v,0.6,1.6) : 1.0;
}
exposureIn.addEventListener('input', applyExposure);
applyExposure();

// If mouse snap is selected, force adjustMode to point (because snap writes per-point)
placeModeSel.addEventListener('change', ()=>{
  const needsPoint = reticleEnabled();
  if (needsPoint && adjustModeSel.value !== 'point'){
    adjustModeSel.value = 'point';
    setStatus('ℹ Mouse snap enabled → Adjust mode set to Selected point.');
  }
  showReticle(reticleEnabled() && !!selected && selected.userData?.idx >= 0);
});

// --------------------
// Nudge + reset controls
// --------------------
function getYawStepDeg(){
  const v = parseFloat(yawStepPresetSel.value);
  return Number.isFinite(v) ? v : 1;
}
function getZStepM(){
  const v = parseFloat(zStepPresetSel.value);
  return Number.isFinite(v) ? v : 0.5;
}

function getSelectedOrWarn(){
  if (!selected || !selected.userData || selected.userData.idx < 0) {
    setStatus('⚠ Select a point first to adjust per-point offsets.');
    return null;
  }
  return selected;
}

function restoreSelectionByKey(sk){
  if (!sk) return;
  const match = currentMarkers.find(m=>m.userData?.candKey === sk);
  if (match){
    setSelected(match);
    setViewYawPitch(
      THREE.MathUtils.degToRad(match.userData.yawDeg),
      THREE.MathUtils.degToRad(match.userData.pitchDeg),
      true
    );
  }
}

function updateSelectedAfterAdjust(){
  const sk = selected?.userData?.candKey;
  rebuildMarkersAndList();
  restoreSelectionByKey(sk);
}

function nudgeYaw(deltaDeg){
  const s=currentSource();
  if (!s) return;

  const mode = adjustModeSel.value;
  if (mode === 'global'){
    const cur=getOffsetDeg(s.id);
    setOffsetDeg(s.id, cur + deltaDeg);
    updateSelectedAfterAdjust();
    return;
  }

  const sel = getSelectedOrWarn();
  if (!sel) return;

  const ck = sel.userData.candKey;
  const adj = getPointAdj(s.id, ck);
  adj.yaw = (adj.yaw || 0) + deltaDeg;
  setPointAdj(s.id, ck, adj);
  updateSelectedAfterAdjust();
}

function nudgePitch(deltaDeg){
  const s=currentSource();
  if (!s) return;

  const mode = adjustModeSel.value;
  if (mode === 'global'){
    setStatus('ℹ Global pitch not enabled. Use Z (global) or Selected point pitch.');
    return;
  }

  const sel = getSelectedOrWarn();
  if (!sel) return;

  const ck = sel.userData.candKey;
  const adj = getPointAdj(s.id, ck);
  adj.pitch = (adj.pitch || 0) + deltaDeg;
  setPointAdj(s.id, ck, adj);
  updateSelectedAfterAdjust();
}

function nudgeZ(deltaM){
  const s=currentSource();
  if (!s) return;

  const mode = adjustModeSel.value;
  if (mode === 'global'){
    const cur=getZOffsetM(s.id);
    setZOffsetM(s.id, cur + deltaM);
    updateSelectedAfterAdjust();
    return;
  }

  const sel = getSelectedOrWarn();
  if (!sel) return;

  const ck = sel.userData.candKey;
  const adj = getPointAdj(s.id, ck);
  adj.z = (adj.z || 0) + deltaM;
  setPointAdj(s.id, ck, adj);
  updateSelectedAfterAdjust();
}

// Arrows remain usable depending on place mode
nudgeLeft.addEventListener('click', ()=>{
  if (!arrowsEnabled()) return;
  const step = getYawStepDeg();
  nudgeYaw(+step);
});
nudgeRight.addEventListener('click', ()=>{
  if (!arrowsEnabled()) return;
  const step = getYawStepDeg();
  nudgeYaw(-step);
});
nudgeUp.addEventListener('click', ()=>{
  if (!arrowsEnabled()) return;
  const step = parseFloat(pitchStepIn.value) || 0.25;
  nudgePitch(+step);
});
nudgeDown.addEventListener('click', ()=>{
  if (!arrowsEnabled()) return;
  const step = parseFloat(pitchStepIn.value) || 0.25;
  nudgePitch(-step);
});

zUp.addEventListener('click', ()=>{
  if (!arrowsEnabled()) return;
  const step = getZStepM();
  nudgeZ(+step);
});
zDown.addEventListener('click', ()=>{
  if (!arrowsEnabled()) return;
  const step = getZStepM();
  nudgeZ(-step);
});

resetAdjBtn.addEventListener('click', ()=>{
  const s=currentSource();
  if (!s) return;

  const mode = adjustModeSel.value;
  if (mode === 'global'){
    setOffsetDeg(s.id, 0);
    updateSelectedAfterAdjust();
    setStatus(`✅ Reset GLOBAL yaw offset for ${s.id}`);
    return;
  }

  const sel = getSelectedOrWarn();
  if (!sel) return;
  resetPointAdj(s.id, sel.userData.candKey);
  updateSelectedAfterAdjust();
  setStatus(`✅ Reset POINT yaw/pitch/z for ${sel.userData.candKey}`);
});

zZero.addEventListener('click', ()=>{
  const s=currentSource();
  if (!s) return;

  const mode = adjustModeSel.value;
  if (mode === 'global'){
    setZOffsetM(s.id, 0);
    updateSelectedAfterAdjust();
    setStatus(`✅ Reset GLOBAL Z offset for ${s.id}`);
    return;
  }

  const sel = getSelectedOrWarn();
  if (!sel) return;
  const adj = getPointAdj(s.id, sel.userData.candKey);
  adj.z = 0;
  setPointAdj(s.id, sel.userData.candKey, adj);
  updateSelectedAfterAdjust();
  setStatus(`✅ Reset POINT Z for ${sel.userData.candKey}`);
});

// --------------------
// Export / Import offsets
// --------------------
function buildExportObject(){
  const out = {
    meta: {
      created_local: new Date().toISOString(),
      origin: location.origin,
      notes: "Global yaw offset degrees + global Z offset meters per pano; per-point yaw/pitch deg + z meters per pano+candidate. Exported from localStorage."
    },
    global: {},
    points: {},
    counts: { global_panos: 0, point_entries: 0 }
  };

  // --- globals from current SOURCES (ensures all panos included even if unset)
  for (const s of SOURCES){
    out.global[s.id] = {
      yaw_offset_deg: getOffsetDeg(s.id),
      z_offset_m: getZOffsetM(s.id)
    };
  }
  out.counts.global_panos = Object.keys(out.global).length;

  // --- points: FIXED parsing for key format:
  // todi_point_adj__SRCID__CANDKEY   (3 parts when split on "__")
  let parsed = 0;

  for (let i=0; i<localStorage.length; i++){
    const k = localStorage.key(i);
    if (!k || !k.startsWith("todi_point_adj__")) continue;

    const parts = k.split("__");  // ["todi_point_adj", "TPANO_52", "landmark:LMID_028"]
    if (parts.length < 3) continue;

    const srcId = parts[1];
    const candKey = parts.slice(2).join("__");

    const raw = localStorage.getItem(k);
    if (!raw) continue;

    try{
      const j = JSON.parse(raw);
      if (!j || typeof j !== "object") continue;

      out.points[srcId] ??= {};
      out.points[srcId][candKey] = {
        yaw:   Number(j.yaw ?? 0),
        pitch: Number(j.pitch ?? 0),
        z:     Number(j.z ?? 0)
      };
      parsed++;
    } catch {
      // ignore invalid point record
    }
  }

  out.counts.point_entries = parsed;
  return out;
}


exportOffsetsBtn.addEventListener('click', ()=> {
  const out = buildExportObject();

  const blob = new Blob([JSON.stringify(out, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = 'todi_offsets_export_withpoints.json';
  document.body.appendChild(a);
  a.click();
  a.remove();

  URL.revokeObjectURL(url);

  const globalPanos  = out.counts?.global_panos ?? Object.keys(out.global).length;
  const pointPanos   = Object.keys(out.points).length;
  const pointEntries = out.counts?.point_entries ?? 0;

  console.log(
    "✅ Exported offsets",
    "| global panos:", globalPanos,
    "| point panos:", pointPanos,
    "| point entries:", pointEntries
  );

  setStatus(
    `✅ Exported offsets: todi_offsets_export_withpoints.json | global: ${globalPanos} | point panos: ${pointPanos} | point entries: ${pointEntries}`
  );
});

importOffsetsIn.addEventListener('change', async ()=> {
  const file = importOffsetsIn.files?.[0];
  if (!file) return;

  try {
    const txt = await file.text();
    const j = JSON.parse(txt);

    // globals
    if (j.global && typeof j.global === 'object'){
      for (const [srcId, v] of Object.entries(j.global)){
        if (!v || typeof v !== 'object') continue;
        if (v.yaw_offset_deg != null) setOffsetDeg(srcId, Number(v.yaw_offset_deg) || 0);
        if (v.z_offset_m != null)     setZOffsetM(srcId, Number(v.z_offset_m) || 0);
      }
    }

    // points
    let importedPointEntries = 0;
    let importedPointPanos = 0;

    if (j.points && typeof j.points === 'object'){
      for (const [srcId, mp] of Object.entries(j.points)){
        if (!mp || typeof mp !== 'object') continue;
        importedPointPanos++;

        for (const [candKey, v] of Object.entries(mp)){
          if (!v || typeof v !== 'object') continue;

          setPointAdj(srcId, candKey, {
            yaw:   Number(v.yaw)   || 0,
            pitch: Number(v.pitch) || 0,
            z:     Number(v.z)     || 0
          });

          importedPointEntries++;
        }
      }
    }

    rebuildMarkersAndList();

    const importedGlobals = (j.global && typeof j.global === 'object') ? Object.keys(j.global).length : 0;
    console.log(
      "✅ Imported offsets",
      "| globals:", importedGlobals,
      "| point panos:", importedPointPanos,
      "| point entries:", importedPointEntries
    );

    setStatus(
      `✅ Imported offsets: ${file.name} | globals: ${importedGlobals} | point panos: ${importedPointPanos} | point entries: ${importedPointEntries}`
    );
  } catch (e){
    console.error(e);
    setStatus(`❌ Import failed: ${e.message}`);
  } finally {
    importOffsetsIn.value = '';
  }
});


// --------------------
// Resize
// --------------------
window.addEventListener('resize', ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});

// --------------------
// Init
// --------------------
function computeMaxDistanceFromData(){
  // set distance slider to max present for current source (default max)
  const s = currentSource();
  if (!s) return 2000;
  let maxD = 0;
  for (const c of (s.candidates||[])){
    const d = getCandidateDistanceM(c);
    if (Number.isFinite(d)) maxD = Math.max(maxD, d);
  }
  return Math.min(2000, Math.ceil(maxD));
}




// ================= Marker FX (wired to currentMarkers from verifier) =================
let markerFxMode = "loading";
let markerFxCfg = {
  helixColor: "#7efcff",
  ringColor:  "#b6ff6a",
  birdColor:  "#ffffff",
  speed: 1.0,
  dir: "cw",
  topY: 55,
  botY: -55,
  radius: 18,
  turns: 5.0,
  jitter: 2.2,
  flock: 0.35
};

function _fxColor(hex){ try{ return new THREE.Color(hex); }catch{ return new THREE.Color("#fff"); } }

function _mkPointsMaterial(hex, size, opacity=0.92){
  return new THREE.PointsMaterial({
    color: _fxColor(hex),
    size,
    transparent:true,
    opacity,
    depthWrite:false,
    depthTest:false
  });
}

function _fxDispose(group){
  try{
    group.traverse(o=>{
      o.geometry?.dispose?.();
      o.material?.dispose?.();
    });
  }catch{}
}

function _getVerifierMarkers(){
  try{
    if(typeof currentMarkers !== "undefined" && Array.isArray(currentMarkers)) return currentMarkers;
  }catch{}
  return [];
}

// --- noise helpers (cheap "murmuration" feel) ---
function _hash1(i){
  const x = Math.sin(i*127.1 + 311.7)*43758.5453;
  return x - Math.floor(x);
}
function _noise3(x,y,z){
  // cheap smooth-ish noise via sines
  return Math.sin(x*1.7 + Math.sin(y*1.3) + z*0.9);
}
function _flowVec(x,y,z,t){
  // pseudo curl-ish field (not true curl, but looks like swirly starlings)
  const nx = _noise3(x*0.12 + t*0.35, y*0.10, z*0.11);
  const ny = _noise3(x*0.10, y*0.12 + t*0.33, z*0.09);
  const nz = _noise3(x*0.11, y*0.09, z*0.12 + t*0.31);
  return new THREE.Vector3(nx, ny, nz);
}

// --- FX builders ---
function buildHelixFX(){
  const g = new THREE.Group();

  const N = 820; // denser for murmuration feel
  const pos = new Float32Array(N*3);
  const base = new Float32Array(N*3);
  const phase = new Float32Array(N);

  const topY = markerFxCfg.topY;
  const botY = markerFxCfg.botY;
  const height = (topY - botY);
  const radius0 = markerFxCfg.radius;
  const turns = markerFxCfg.turns;

  for(let i=0;i<N;i++){
    const t = i/(N-1);
    const ang = t * Math.PI * 2.0 * turns;
    const r = radius0 * (1.0 - 0.35*t);

    const x = Math.cos(ang)*r;
    const y = botY + t*height;
    const z = Math.sin(ang)*r;

    pos[i*3+0]=x; pos[i*3+1]=y; pos[i*3+2]=z;
    base[i*3+0]=x; base[i*3+1]=y; base[i*3+2]=z;
    phase[i]=_hash1(i)*Math.PI*2.0;
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.BufferAttribute(pos,3));
  geo.setAttribute("base", new THREE.BufferAttribute(base,3));
  geo.setAttribute("phase", new THREE.BufferAttribute(phase,1));

  const helix = new THREE.Points(geo, _mkPointsMaterial(markerFxCfg.helixColor, 1.15, 0.9));
  helix.userData.kind="helix";
  g.add(helix);

  // ground ring (3/4 circle)
  const M = 320;
  const pos2 = new Float32Array(M*3);
  const base2 = new Float32Array(M*3);
  const phase2= new Float32Array(M);
  for(let i=0;i<M;i++){
    const a = (i/(M-1)) * (Math.PI*1.5);
    const R = radius0 * 1.15;
    const x = Math.cos(a)*R;
    const y = botY;
    const z = Math.sin(a)*R;
    pos2[i*3+0]=x; pos2[i*3+1]=y; pos2[i*3+2]=z;
    base2[i*3+0]=x; base2[i*3+1]=y; base2[i*3+2]=z;
    phase2[i]=_hash1(1000+i)*Math.PI*2.0;
  }
  const geo2 = new THREE.BufferGeometry();
  geo2.setAttribute("position", new THREE.BufferAttribute(pos2,3));
  geo2.setAttribute("base", new THREE.BufferAttribute(base2,3));
  geo2.setAttribute("phase", new THREE.BufferAttribute(phase2,1));
  const ring = new THREE.Points(geo2, _mkPointsMaterial(markerFxCfg.ringColor, 1.6, 0.85));
  ring.userData.kind="ring";
  g.add(ring);

  // halo near top (kept as separate option)
  const B = 360;
  const pos3 = new Float32Array(B*3);
  const base3= new Float32Array(B*3);
  const phase3=new Float32Array(B);
  for(let i=0;i<B;i++){
    const a = _hash1(2000+i)*Math.PI*2;
    const r = (radius0*0.55) + _hash1(3000+i)*(radius0*0.25);
    const x = Math.cos(a)*r;
    const y = topY + (_hash1(4000+i)-0.5)*10;
    const z = Math.sin(a)*r;
    pos3[i*3+0]=x; pos3[i*3+1]=y; pos3[i*3+2]=z;
    base3[i*3+0]=x; base3[i*3+1]=y; base3[i*3+2]=z;
    phase3[i]=_hash1(5000+i)*Math.PI*2.0;
  }
  const geo3 = new THREE.BufferGeometry();
  geo3.setAttribute("position", new THREE.BufferAttribute(pos3,3));
  geo3.setAttribute("base", new THREE.BufferAttribute(base3,3));
  geo3.setAttribute("phase", new THREE.BufferAttribute(phase3,1));
  const halo = new THREE.Points(geo3, _mkPointsMaterial(markerFxCfg.birdColor, 1.35, 0.9));
  halo.userData.kind="halo";
  g.add(halo);

  // bird-shape point cloud (simple stylised 3D silhouette)
  const S = 520;
  const pos4 = new Float32Array(S*3);
  const base4= new Float32Array(S*3);
  const phase4=new Float32Array(S);
  for(let i=0;i<S;i++){
    // sample a stylised bird with two wings + body; z adds thickness
    const u = _hash1(6000+i)*2 - 1;     // -1..1 across wings
    const v = _hash1(7000+i)*2 - 1;     // -1..1 along body
    const wing = 1.0 - Math.abs(v);     // taper
    const wingCurve = 0.35*Math.sin(v*Math.PI); // camber
    let x = u * (radius0*0.65) * (0.25 + 0.75*wing);
    let y = wingCurve * (radius0*0.22) + (topY + 12) + v*(radius0*0.18);
    let z = ( _hash1(8000+i)-0.5 ) * (radius0*0.20);

    // body bias near center
    const bodyMask = Math.exp(-Math.abs(u)*3.2);
    y += bodyMask * (radius0*0.10);
    x *= (0.55 + 0.45*(1-bodyMask));

    pos4[i*3+0]=x; pos4[i*3+1]=y; pos4[i*3+2]=z;
    base4[i*3+0]=x; base4[i*3+1]=y; base4[i*3+2]=z;
    phase4[i]=_hash1(9000+i)*Math.PI*2.0;
  }
  const geo4 = new THREE.BufferGeometry();
  geo4.setAttribute("position", new THREE.BufferAttribute(pos4,3));
  geo4.setAttribute("base", new THREE.BufferAttribute(base4,3));
  geo4.setAttribute("phase", new THREE.BufferAttribute(phase4,1));
  const birdshape = new THREE.Points(geo4, _mkPointsMaterial(markerFxCfg.birdColor, 1.2, 0.95));
  birdshape.userData.kind="birdshape";
  g.add(birdshape);

  g.userData.t = 0;
  return g;
}

function _setVisibleByMode(fx){
  if(!fx) return;
  fx.traverse(o=>{
    if(!o.isPoints) return;
    const k = o.userData.kind;
    if(markerFxMode === "helix")      o.visible = (k==="helix");
    else if(markerFxMode === "ring")  o.visible = (k==="ring");
    else if(markerFxMode === "halo")  o.visible = (k==="halo");
    else if(markerFxMode === "birdshape") o.visible = (k==="birdshape");
    else if(markerFxMode === "combo") o.visible = (k==="helix"||k==="ring"||k==="halo");
    else o.visible = false;
  });
}

function applyMarkerFxToMarker(m){
  if(!m) return;
  m.userData ||= {};

  // clear existing
  if(m.userData.fxGroup){
    m.remove(m.userData.fxGroup);
    _fxDispose(m.userData.fxGroup);
    m.userData.fxGroup = null;
  }

  if(markerFxMode === "hover" || markerFxMode === "loading"){
    return; // nothing additive
  }

  const fx = buildHelixFX();
  _setVisibleByMode(fx);
  m.add(fx);
  m.userData.fxGroup = fx;
    try{ fx.traverse(o=>{ if(o.isPoints) forceTopLayer(o,2000); }); }catch(e){}
}

function updateMarkerFx(dt){
  const list = _getVerifierMarkers();
  if(!list.length) return;

  const dir = (markerFxCfg.dir === "ccw") ? -1 : 1;
  const sp  = (markerFxCfg.speed || 1.0);

  for(const m of list){
    const fx = m?.userData?.fxGroup;
    if(!fx) continue;

    fx.userData.t += dt * sp;
    const t = fx.userData.t;

    // rotate whole group gently
    fx.rotation.y = dir * t * 0.85;

    fx.traverse(o=>{
      if(!o.isPoints) return;

      // update colors live
      if(o.userData.kind==="helix") o.material.color.set(_fxColor(markerFxCfg.helixColor));
      if(o.userData.kind==="ring")  o.material.color.set(_fxColor(markerFxCfg.ringColor));
      if(o.userData.kind==="halo" || o.userData.kind==="birdshape") o.material.color.set(_fxColor(markerFxCfg.birdColor));

      // murmuration-like jitter
      const geo = o.geometry;
      const pos = geo.getAttribute("position");
      const base= geo.getAttribute("base");
      const ph  = geo.getAttribute("phase");
      if(!pos || !base || !ph) return;

      const jit = markerFxCfg.jitter;
      const flock = markerFxCfg.flock;

      for(let i=0;i<pos.count;i++){
        const bx = base.getX(i), by = base.getY(i), bz = base.getZ(i);
        const p = ph.getX(i);

        // flow field
        const fv = _flowVec(bx, by, bz, t + p);
        const w = (0.65 + 0.35*Math.sin(t*1.3 + p));

        // "flockiness" nudges toward a few moving centroids
        const cx = Math.sin(t*0.6)*8;
        const cy = Math.cos(t*0.7)*6;
        const cz = Math.sin(t*0.5)*7;

        const nx = bx + fv.x*jit*w + (cx - bx)*flock*0.02;
        const ny = by + fv.y*jit*w + (cy - by)*flock*0.02;
        const nz = bz + fv.z*jit*w + (cz - bz)*flock*0.02;

        pos.setXYZ(i, nx, ny, nz);
      }
      pos.needsUpdate = true;
    });

    // ensure correct components visible for current mode
    _setVisibleByMode(fx);
  }
}

function hookMarkerFxUI(){
  const sel = document.getElementById("markerFxSel");
  const cH = document.getElementById("fxHelixColor");
  const cR = document.getElementById("fxRingColor");
  const cB = document.getElementById("fxBirdColor");
  const sp = document.getElementById("fxSpeed");
  const dr = document.getElementById("fxDir");
  const topY = document.getElementById("fxTopY");
  const botY = document.getElementById("fxBotY");
  const rad  = document.getElementById("fxRadius");
  const trn  = document.getElementById("fxTurns");
  const jit  = document.getElementById("fxJitter");
  const flk  = document.getElementById("fxFlock");

  function reapply(){
    for(const m of _getVerifierMarkers()) applyMarkerFxToMarker(m);
  }

  if(sel){
    sel.value = markerFxMode;
    sel.onchange = ()=>{
      markerFxMode = sel.value;
      reapply();
    };
  }
  if(cH) cH.oninput = ()=> markerFxCfg.helixColor = cH.value;
  if(cR) cR.oninput = ()=> markerFxCfg.ringColor  = cR.value;
  if(cB) cB.oninput = ()=> markerFxCfg.birdColor  = cB.value;

  if(sp) sp.oninput = ()=> markerFxCfg.speed = parseFloat(sp.value || "1");
  if(dr) dr.onchange = ()=> markerFxCfg.dir = dr.value;

  if(topY) topY.oninput = ()=>{ markerFxCfg.topY = parseFloat(topY.value||"55"); reapply(); };
  if(botY) botY.oninput = ()=>{ markerFxCfg.botY = parseFloat(botY.value||"-55"); reapply(); };
  if(rad)  rad.oninput  = ()=>{ markerFxCfg.radius = parseFloat(rad.value||"18"); reapply(); };
  if(trn)  trn.oninput  = ()=>{ markerFxCfg.turns  = parseFloat(trn.value||"5"); reapply(); };
  if(jit)  jit.oninput  = ()=> markerFxCfg.jitter = parseFloat(jit.value||"2.2");
  if(flk)  flk.oninput  = ()=> markerFxCfg.flock  = parseFloat(flk.value||"0.35");
}
async function init(){
  setStatus(`Fetching ${JSON_PATH}…`);
  const res = await fetch(JSON_PATH, { cache:'no-store' });
  if (!res.ok) throw new Error(`JSON fetch failed: ${res.status} ${res.statusText}`);
  DATA = await res.json();

  // Overlay system init
  hookOverlayUI();
  hookMarkerFxUI();


    hookSkyGroundUI();
// Overlay UI hooks
  if (ovOpacity) ovOpacity.addEventListener('input', syncOverlayUI);
  if (ovOn) ovOn.addEventListener('change', ()=> loadOverlayForSource(currentSource()));
  if (ovType) ovType.addEventListener('change', ()=> loadOverlayForSource(currentSource()));
  syncOverlayUI();


  const srcs = Array.isArray(DATA.sources) ? DATA.sources : [];
  SOURCES = srcs.map(s=>({
    type: s.type || 'pano',
    id: s.id,
    yaw_deg: (s.yaw_deg==null ? null : Number(s.yaw_deg)),
    sourcefile: s.sourcefile || s.SourceFile || null,
    image: s.image || null,
    candidates: Array.isArray(s.candidates) ? s.candidates : []
  }))
  .filter(s=>!!s.id)
  .sort((a,b)=>{
    const ta=(a.type==='pano')?0:1;
    const tb=(b.type==='pano')?0:1;
    if (ta!==tb) return ta-tb;
    const na=numericKey(a.id);
    const nb=numericKey(b.id);
    if (na!==nb) return na-nb;
    return String(a.id).localeCompare(String(b.id));
  });

  if (!SOURCES.length){
    setStatus('❌ No sources found in JSON.');
    return;
  }

  buildSourceDropdown();
  await setSourceByIndex(0);

  // set distance slider default to max in this dataset (≤ 2000m cap)
  const maxD = computeMaxDistanceFromData();
  distMaxIn.value = String(maxD);
  distMaxLabel.textContent = `≤ ${distMaxIn.value}m`;

  // if mouse snap enabled on load, force point adjust mode
  if (reticleEnabled() && adjustModeSel.value !== 'point'){
    adjustModeSel.value = 'point';
  }
}

function animate(){
  requestAnimationFrame(animate);
  const _dt = (typeof clock !== 'undefined' && clock) ? clock.getDelta() : 0.016;
  updateMarkerFx(_dt);
  updateCamera();
  updateCalloutAnims();

  
  // animate / control loading circle markers (mode-aware)
  const nowSpin = performance.now();
  const dtSpin = Math.min(0.05, (nowSpin - lastSpinT)/1000);
  lastSpinT = nowSpin;

  markerGroup.children.forEach(m=>{
    const ring = m?.userData?.markerVisual;
    if (!ring || !ring.userData?.isLoadingCircle) return;

    // Modes:
    // - hover: hide loading rings entirely
    // - loading: show + animate (verifier default)
    // - helix: hide loading rings (helix provides its own motion cue)
    if (markerFxMode === "hover" || markerFxMode === "helix"){
      ring.visible = false;
      return;
    }

    // loading mode
    ring.visible = (m !== focusedMarker);

    const base = ring.userData.baseScale || ring.scale;
    const pulse = ring.userData.pulse ?? 0.18;
    const spin  = ring.userData.spin  ?? 1.4;
    const s = 1.0 + pulse * Math.sin(nowSpin * 0.006);
    ring.scale.set(base.x * s, base.y * s, 1);

    if (ring.material) ring.material.rotation = (nowSpin * 0.001) * (Math.PI * 2) * spin;
  });

  // billboard callouts so the leader line stays vertical on screen
  markerGroup.children.forEach(m=>{
    const c = m?.userData?.callout;
    if (!c) return;
    c.quaternion.copy(camera.quaternion);
  });

  // keep hover labels glued
  labelGroup.children.forEach(lbl=>{
    const m = lbl.userData.marker;
    if (!m) return;
    const dir = m.position.clone().normalize();
    lbl.position.copy(dir.multiplyScalar(MARKER_RADIUS - 10));
  });

  renderer.clear();
  renderer.render(scenePano, camera);
  renderer.render(sceneOverlay, camera);
}


// ================= SKY / GROUND MASK OVERLAY (module-scope) =================
let sgMesh=null, sgTex=null;

function makeSkyGroundMat(){
  return new THREE.ShaderMaterial({
    transparent:true,
    depthWrite:false,
    depthTest:false,
    uniforms:{
      maskTex:{value:null},
      skyColor:{value:new THREE.Color("#9bd7ff")},
      groundColor:{value:new THREE.Color("#f2e8d5")},
      skyAlpha:{value:0.35},
      groundAlpha:{value:0.18},
      skyOn:{value:1.0},
      groundOn:{value:1.0},
      invertMask:{value:0.0},
      feather:{value:0.03},
      enabled:{value:1.0},
    },
    vertexShader:`
      varying vec2 vUv;
      void main(){
        vUv=uv;
        gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
      }`,
    fragmentShader:`
      varying vec2 vUv;
      uniform sampler2D maskTex;
      uniform vec3 skyColor;
      uniform vec3 groundColor;
      uniform float skyAlpha;
      uniform float groundAlpha;
      uniform float skyOn;
      uniform float groundOn;
      uniform float invertMask;
      uniform float feather;
      uniform float enabled;

      void main(){
        if(enabled<0.5) discard;

        float m = texture2D(maskTex, vUv).r;
        if(invertMask>0.5) m = 1.0 - m;

        float f = max(feather, 0.0001);
        float skyMix = smoothstep(0.5 - f, 0.5 + f, m);

        vec3 col = mix(groundColor, skyColor, skyMix);
        float a = mix(groundAlpha*groundOn, skyAlpha*skyOn, skyMix);

        if(a<0.001) discard;
        gl_FragColor = vec4(col, a);
      }`
  });
}

function ensureSkyGroundMesh(){
  if(sgMesh) return;
  const geom = new THREE.SphereGeometry(SPHERE_RADIUS - 0.75, 64, 48);
  geom.scale(-1,1,1);
  const mat = makeSkyGroundMat();
  sgMesh = new THREE.Mesh(geom, mat);sgMesh.renderOrder = 1;
  try{ sgMesh.material.depthTest=false; sgMesh.material.depthWrite=false; }catch(e){}
  scenePano.add(sgMesh);
}

const SKY_MASK_DIR = "./images/Overlays";

function panoStemFromSource(src){
  const fn = (src?.sourcefile || src?.image || "").split(/[\\\/]/).pop() || "";
  return fn ? fn.replace(/\.[^.]+$/, "") : "";
}

function loadSkyMaskForSource(src){
  ensureSkyGroundMesh();
  const stem = panoStemFromSource(src);
  if(!stem) return;
  let url = `${SKY_MASK_DIR}/${stem}_skymask.png`;
  let altUrl = `${SKY_MASK_DIR}/${stem}_sky_mask.png`;

  const loader = new THREE.TextureLoader();
  loader.load(
    url,
    (tex)=>{
      if(sgTex) sgTex.dispose();
      sgTex = tex;
      sgTex.wrapS = sgTex.wrapT = THREE.ClampToEdgeWrapping;
      sgTex.minFilter = THREE.LinearFilter;
      sgTex.magFilter = THREE.LinearFilter;
      sgMesh.material.uniforms.maskTex.value = sgTex;
      sgMesh.material.needsUpdate = true;
    },
    undefined,
    ()=>{ 
        console.warn("[sky_mask] missing primary:", url);
        loader.load(
          altUrl,
          (tex)=>{
            if(sgTex) sgTex.dispose();
            sgTex = tex;
            sgTex.wrapS = sgTex.wrapT = THREE.ClampToEdgeWrapping;
            sgTex.minFilter = THREE.LinearFilter;
            sgTex.magFilter = THREE.LinearFilter;
            sgMesh.material.uniforms.maskTex.value = sgTex;
            sgMesh.material.needsUpdate = true;
            console.warn("[sky_mask] loaded legacy name:", altUrl);
          },
          undefined,
          ()=>{ console.warn("[sky_mask] missing both:", url, altUrl); }
        );
      }
  );
}

function hookSkyGroundUI(){
  const el = (id)=>document.getElementById(id);
  const sgEnable = el("sgEnable");
  const sgSkyOn = el("sgSkyOn");
  const sgGroundOn = el("sgGroundOn");
  const sgSkyColor = el("sgSkyColor");
  const sgGroundColor = el("sgGroundColor");
  const sgSkyAlpha = el("sgSkyAlpha");
  const sgGroundAlpha = el("sgGroundAlpha");
  const sgInvert = el("sgInvert");
  const sgFeather = el("sgFeather");

  if(!sgEnable) return;

  function clamp01(x){
    x = Number(x);
    if(!Number.isFinite(x)) return 0;
    return Math.max(0, Math.min(1, x));
  }

  function apply(){
    ensureSkyGroundMesh();
    const u = sgMesh.material.uniforms;

    u.enabled.value = sgEnable.checked ? 1.0 : 0.0;
    u.skyOn.value = sgSkyOn.checked ? 1.0 : 0.0;
    u.groundOn.value = sgGroundOn.checked ? 1.0 : 0.0;
    u.invertMask.value = sgInvert.checked ? 1.0 : 0.0;

    u.skyColor.value.set(sgSkyColor.value);
    u.groundColor.value.set(sgGroundColor.value);

    u.skyAlpha.value = clamp01(sgSkyAlpha.value);
    u.groundAlpha.value = clamp01(sgGroundAlpha.value);

    u.feather.value = Math.max(0, Math.min(0.2, Number(sgFeather.value) || 0.03));
  }

  ["input","change"].forEach(evt=>{
    [sgEnable,sgSkyOn,sgGroundOn,sgSkyColor,sgGroundColor,sgSkyAlpha,sgGroundAlpha,sgInvert,sgFeather]
      .forEach(x=>x && x.addEventListener(evt, apply));
  });

  apply();
}
// ============================================================================



// --- Edge reopen buttons (hardfix, no guessing) ---
if(!window.__edgeHardInit){
  window.__edgeHardInit = true;

  const edgeLeftBtn  = document.getElementById("edgeReopenLeft");
  const edgeRightBtn = document.getElementById("edgeReopenRight");

  const docks = Array.from(document.querySelectorAll(".dock"));
  const dv = document.getElementById("dockVerifier") || docks[0] || null;
  const dox = document.getElementById("dockOverlay")  || docks[1] || null;

  const applyBodyFlags = ()=>{
    try{
      document.body.classList.toggle("verifier-collapsed", !!dv?.classList.contains("collapsed"));
      document.body.classList.toggle("overlay-collapsed",  !!dox?.classList.contains("collapsed"));
    }catch(e){}
  };

  if(edgeLeftBtn){
    edgeLeftBtn.addEventListener("click", ()=>{
      if(!dv) return;
      dv.classList.remove("collapsed");
      applyBodyFlags();
      window.dispatchEvent(new Event("resize"));
    });
  }
  if(edgeRightBtn){
    edgeRightBtn.addEventListener("click", ()=>{
      if(!dox) return;
      dox.classList.remove("collapsed");
      applyBodyFlags();
      window.dispatchEvent(new Event("resize"));
    });
  }

  // Observe docks for collapse class changes
  try{
    const mo = new MutationObserver(()=>applyBodyFlags());
    if(dv)  mo.observe(dv,  {attributes:true, attributeFilter:["class"]});
    if(dox) mo.observe(dox, {attributes:true, attributeFilter:["class"]});
  }catch(e){}

  // Also wire the dock toggle buttons (if present) so flags update immediately
  try{
    dv?.querySelector(".dockToggle")?.addEventListener("click", ()=>setTimeout(applyBodyFlags, 0));
    dox?.querySelector(".dockToggle")?.addEventListener("click", ()=>setTimeout(applyBodyFlags, 0));
  }catch(e){}

  applyBodyFlags();
}

init().then(()=>animate()).catch(err=>{
  console.error(err);
  setStatus(`❌ ${err.message}`);
});

// ---- EDGE REOPEN (hard sync) ----
(function(){
  const leftDock = document.getElementById('leftDock');
  const rightDock = document.getElementById('rightDock');
  const bL = document.getElementById('edgeReopenLeft');
  const bR = document.getElementById('edgeReopenRight');
  function sync(){
    if(!leftDock||!rightDock||!bL||!bR) return;
    bL.style.display = leftDock.classList.contains('collapsed') ? 'flex' : 'none';
    bR.style.display = rightDock.classList.contains('collapsed') ? 'flex' : 'none';
  }
  // patch toggleDock if present
  try{
    const _toggleDock = window.toggleDock;
    if(typeof _toggleDock === 'function'){
      window.toggleDock = function(which, collapse){
        const r = _toggleDock.apply(this, arguments);
        sync();
        return r;
      };
    }
  }catch(e){}
  // initial + periodic safety sync (covers any later DOM overwrites)
  window.addEventListener('load', ()=>{ sync(); setInterval(sync, 250); }, { once:true });
  // also sync on resize
  window.addEventListener('resize', sync);
})();

</script>

<!-- ================= Overlay Controls ================= -->

<div id="uiOverlay">
  <div id="ovHeader">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
      <b>Overlay</b>
      <button id="ovCollapseBtn" type="button">Collapse</button>
    </div>

    <div class="ovRow">
      <label style="display:flex;align-items:center;gap:8px">
        <input id="toggleOverlay" type="checkbox" checked> Show overlay
      </label>

      <div style="display:flex;gap:8px">
        <button id="exportPngBtn" type="button">Export PNG</button>
        <button id="copySettingsBtn" type="button">Copy settings</button>
        <button id="shareLinkBtn" type="button">Share link</button>
      </div>
    </div>

    <div class="ovRow">
      <span>Overlay file</span>
      <select id="ovType" style="flex:1">
<option value="edges_colour">Colour edges</option>
        <option value="edges_mask">Mask</option>
      </select>
    </div>

    <div class="ovRow">
      <span>Mask file</span>
      <select id="maskKindSel" style="flex:1">
        <option value="edges_mask">Edges mask</option>
        <option value="sky_mask">Sky-only mask</option>
</select>
    </div>
  </div>

  <div id="ovBody">

  <div class="ovSection" style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,.12)">
    <div style="font-weight:800;margin-bottom:8px">Sky / Ground tint</div>

    <div class="ovRow" style="justify-content:space-between;gap:12px;flex-wrap:wrap">
      <label style="display:flex;align-items:center;gap:8px">
        <input id="sgEnable" type="checkbox" checked>
        <span>Enable</span>
      </label>

      <label style="display:flex;align-items:center;gap:8px">
        <input id="sgInvert" type="checkbox">
        <span>Invert</span>
      </label>

      <label style="display:flex;align-items:center;gap:8px">
        <span style="opacity:.75">Feather</span>
        <input id="sgFeather" type="number" step="0.005" min="0" max="0.2" value="0.03" style="width:78px">
      </label>
    </div>

    <div class="ovRow" style="gap:10px;flex-wrap:wrap">
      <label style="display:flex;align-items:center;gap:8px">
        <input id="sgSkyOn" type="checkbox" checked>
        <span>Sky</span>
      </label>
      <input id="sgSkyColor" type="color" value="#9bd7ff">
      <label style="display:flex;align-items:center;gap:6px">
        <span style="opacity:.75">α</span>
        <input id="sgSkyAlpha" type="number" step="0.01" min="0" max="1" value="0.35" style="width:78px">
      </label>
    </div>

    <div class="ovRow" style="gap:10px;flex-wrap:wrap">
      <label style="display:flex;align-items:center;gap:8px">
        <input id="sgGroundOn" type="checkbox" checked>
        <span>Ground</span>
      </label>
      <input id="sgGroundColor" type="color" value="#f2e8d5">
      <label style="display:flex;align-items:center;gap:6px">
        <span style="opacity:.75">α</span>
        <input id="sgGroundAlpha" type="number" step="0.01" min="0" max="1" value="0.18" style="width:78px">
      </label>
    </div>

    <div style="opacity:.65;font-size:12px;line-height:1.2;margin-top:6px">
      Uses <code>images/Overlays/&lt;stem&gt;_skymask.png</code> (white=sky, black=ground)
    </div>
  </div>


    <div class="ovRow">
      <span>Mode</span>
      <select id="modeSel">
        <option value="0">Original overlay colours</option>
        <option value="1">Single colour</option>
        <option value="2">Rules (ranges)</option>
      </select>
    </div>

    <div id="singleGroup" style="display:none">
      <div class="ovRow"><span>Single colour</span><input id="singleColor" type="color" value="#00ffd0"></div>
    </div>

    <div id="rulesGroup" style="display:none">
      <div class="ovSmall">
        Rules are evaluated top → bottom. First match wins.<br>
        Click on the hue bar to jump; drag to fine tune (nearest handle becomes active).
      </div>

      <div class="ovRow" style="margin-top:10px">
        <span>Rules</span>
        <button id="addRuleBtn" type="button">+ Add rule</button>
      </div>

      <div id="rulesPanel"></div>

      <div class="ovSmall">Guards (stop greys/white edges being classified)</div>
      <div class="ovRow"><span>Min saturation</span><div style="display:flex;gap:10px;align-items:center"><input id="minSat" type="range" min="0" max="1" step="0.005" value="0.16"><input id="minSatNum" type="number" min="0" max="1" step="0.005" value="0.16" style="width:76px"></div></div>
      <div class="ovRow"><span>Min value</span><div style="display:flex;gap:10px;align-items:center"><input id="minVal" type="range" min="0" max="1" step="0.005" value="0.10"><input id="minValNum" type="number" min="0" max="1" step="0.005" value="0.10" style="width:76px"></div></div>
    </div>

    <hr class="ovSep"/>

    <div class="ovRow"><span>Overlay opacity</span><div style="display:flex;gap:10px;align-items:center"><input id="overlayOpacity" type="range" min="0" max="1" step="0.005" value="0.65"><input id="overlayOpacityNum" type="number" min="0" max="1" step="0.005" value="0.65" style="width:76px"></div></div>
    <div class="ovRow"><span>Line width</span><div style="display:flex;gap:10px;align-items:center"><input id="lineWidth" type="range" min="0" max="6" step="1" value="0"><input id="lineWidthNum" type="number" min="0" max="6" step="1" value="0" style="width:76px"></div></div>
    <div class="ovRow"><span>Mask threshold</span><div style="display:flex;gap:10px;align-items:center"><input id="maskThresh" type="range" min="0" max="1" step="0.005" value="0.12"><input id="maskThreshNum" type="number" min="0" max="1" step="0.005" value="0.12" style="width:76px"></div></div>
    <div class="ovRow"><span>Pano fade</span><div style="display:flex;gap:10px;align-items:center"><input id="panoFade" type="range" min="0" max="1" step="0.01" value="1"><input id="panoFadeNum" type="number" min="0" max="1" step="0.01" value="1" style="width:76px"></div></div>
    <div class="ovRow"><span>Global background</span><input id="bgColor" type="color" value="#0b0b0b"></div>
<div class="ovRow"><span>Background opacity</span><div style="display:flex;gap:10px;align-items:center"><input id="bgOpacity" type="range" min="0" max="1" step="0.01" value="1"><input id="bgOpacityNum" type="number" min="0" max="1" step="0.01" value="1" style="width:76px"></div></div>

    <div id="ovStatus">Ready.</div>
  </div>

  <div id="ovFooter">
    <div class="ovRow" style="margin-top:0">
      <b>Presets</b>
      <span class="ovMini">always visible</span>
    </div>

    <div class="ovRow">
      <input id="presetName" type="text" placeholder="Name (e.g. Cream + Light Blue)" />
      <button id="savePresetBtn" type="button">Save</button>
    </div>

    <div class="ovRow">
      <select id="presetSel" style="width:100%"></select>
    </div>

    <div class="ovRow">
      <button id="loadPresetBtn" type="button">Load</button>
      <button id="deletePresetBtn" type="button">Delete</button>
      <button id="applySettingsBtn" type="button">Apply JSON</button>
    </div>

    <textarea id="settingsBox" placeholder="Click Copy settings → paste JSON here → Apply JSON"></textarea>
  </div>
</div>

<style>
#uiOverlay{
  position:fixed; top:14px; right:14px; z-index:20;
  width:260px; max-width:calc(100vw - 28px);
  background:rgba(0,0,0,.55);
  border:1px solid rgba(255,255,255,.15);
  border-radius:12px;
  color:#fff;
  padding:12px;
  user-select:none;
}
#uiOverlay select, #uiOverlay input[type="range"]{ accent-color:#fff; }

/* Edge reopen buttons (visible only when dock collapsed) */
.edgeReopen{
  position:fixed;
  top:50%;
  transform:translateY(-50%);
  width:30px;height:54px;
  display:flex;
  align-items:center;justify-content:center;
  background:rgba(0,0,0,.60);
  border:1px solid rgba(255,255,255,.22);
  border-radius:12px;
  color:#fff;
  cursor:pointer;
  user-select:none;
  z-index:100000;
  backdrop-filter: blur(8px);
  font-weight:900;
  opacity:0;
  pointer-events:none;
  transition: opacity .12s ease;
}
body.verifier-collapsed #edgeReopenLeft{ opacity:1; pointer-events:auto; }
body.overlay-collapsed  #edgeReopenRight{ opacity:1; pointer-events:auto; }
#edgeReopenLeft{ left:8px; }
#edgeReopenRight{ right:8px; }


/* === CLEAN EDGE REOPEN === */
.edgeReopen{
  position:fixed;
  top:50%;
  transform:translateY(-50%);
  width:34px;
  height:64px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,.65);
  border:1px solid rgba(255,255,255,.25);
  border-radius:12px;
  color:#fff;
  cursor:pointer;
  z-index:999999;
  backdrop-filter: blur(8px);
  font-weight:900;
  opacity:0;
  pointer-events:none;
}
body.verifier-collapsed #edgeReopenLeft{opacity:1;pointer-events:auto;}
body.overlay-collapsed #edgeReopenRight{opacity:1;pointer-events:auto;}
#edgeReopenLeft{left:8px;}
#edgeReopenRight{right:8px;}

</style>



</body>
</html>